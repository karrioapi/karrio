<!DOCTYPE html>
<html>
<head>
    <title>OAuth Callback</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f5f5f5;
        }
        .container {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
        }
        .success { color: #16a34a; }
        .error { color: #dc2626; }
        .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        h2 { margin-bottom: 10px; }
        p { color: #666; margin-bottom: 20px; }
        .close-hint {
            font-size: 12px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">{% if success %}✓{% else %}✗{% endif %}</div>
        <h2 class="{% if success %}success{% else %}error{% endif %}">
            {% if success %}Authorization Successful{% else %}Authorization Failed{% endif %}
        </h2>
        <p>{% if success %}You can close this window and return to the application.{% else %}{{ error_message }}{% endif %}</p>
        <p class="close-hint">This window will close automatically...</p>
    </div>
    <script>
        (async function() {
            var result = {{ result_json|safe }};

            /**
             * Encrypts data using AES-GCM with Web Crypto API.
             * Returns an object containing the encrypted data, IV, and key (all base64 encoded).
             */
            async function encryptData(data) {
                // Generate a random 256-bit key
                var key = await crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true, // extractable - needed to export the key
                    ["encrypt", "decrypt"]
                );

                // Generate a random 96-bit IV (recommended for AES-GCM)
                var iv = crypto.getRandomValues(new Uint8Array(12));

                // Encode the data as UTF-8
                var encoder = new TextEncoder();
                var encodedData = encoder.encode(data);

                // Encrypt the data
                var encryptedBuffer = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encodedData
                );

                // Export the key for storage
                var exportedKey = await crypto.subtle.exportKey("raw", key);

                // Convert to base64 for storage
                var ciphertext = btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedBuffer)));
                var ivBase64 = btoa(String.fromCharCode.apply(null, iv));
                var keyBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(exportedKey)));

                return { ciphertext: ciphertext, iv: ivBase64, key: keyBase64 };
            }

            // Store encrypted result in localStorage for the opener to read
            // Using localStorage (not sessionStorage) because popup windows have
            // separate sessionStorage contexts from their opener window.
            // Data is encrypted with AES-GCM for security.
            try {
                var encrypted = await encryptData(JSON.stringify(result));
                localStorage.setItem('karrio_oauth_result', JSON.stringify(encrypted));
            } catch (e) {
                console.error('Failed to encrypt/store OAuth result:', e);
            }

            // Try to close the window after a short delay
            setTimeout(function() {
                window.close();
            }, 2000);
        })();
    </script>
</body>
</html>
