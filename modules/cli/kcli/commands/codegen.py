import re
import sys
import typer
import importlib
from typing import Optional, List, Set
import logging
import os

app = typer.Typer()

@app.command("transform")
def transform(
    input_file: Optional[str] = typer.Argument(
        None, help="Input file path. If not provided, reads from stdin."
    ),
    output_file: Optional[str] = typer.Argument(
        None, help="Output file path. If not provided, writes to stdout."
    ),
    append_type_suffix: bool = typer.Option(
        True, help="Append 'Type' to class names", is_flag=True
    ),
):
    """
    Transform Python code generated by quicktype (using dataclasses)
    into code that uses attrs and jstruct decorators.
    """
    # Read input from file or stdin
    if input_file:
        with open(input_file, "r") as f:
            content = f.read()
    else:
        content = sys.stdin.read()

    # Transform the content
    transformed = transform_content(content, append_type_suffix)

    # Write output to file or stdout
    if output_file:
        with open(output_file, "w") as f:
            f.write(transformed)
    else:
        print(transformed)

def extract_class_names(content: str) -> Set[str]:
    """Extract all class names from the content."""
    return set(re.findall(r"class\s+(\w+)", content))

def transform_content(content: str, append_type_suffix: bool = True) -> str:
    """Transform dataclass-based code to jstruct-based code."""
    # Check if we already have a typing import
    has_typing_import = "import typing" in content

    # Replace imports
    if "from dataclasses import dataclass" in content:
        content = content.replace(
            "from dataclasses import dataclass",
            "import attr\nimport jstruct" + ("" if has_typing_import else "\nimport typing")
        )
    else:
        # If dataclasses import is not found, add the imports anyway
        imports = "import attr\nimport jstruct"
        if not has_typing_import:
            imports += "\nimport typing"
        content = imports + "\n" + content

    # Remove any "from typing import" lines completely
    content = re.sub(r"from typing import [^\n]+\n", "", content)

    # Replace @dataclass decorator with @attr.s
    content = re.sub(r"@dataclass", "@attr.s(auto_attribs=True)", content)

    # Get all class names
    class_names = extract_class_names(content)

    # Dictionary to keep track of original class names and their new versions with Type suffix
    class_name_mapping = {}

    # Create a new names dictionary if we're appending Type
    if append_type_suffix:
        for class_name in class_names:
            # If the class name already ends with 'Type', append 'ObjectType' instead
            if class_name.endswith('Type'):
                class_name_mapping[class_name] = f"{class_name}ObjectType"
            else:
                class_name_mapping[class_name] = f"{class_name}Type"

        # Rename class definitions only, not field names
        for original_name, new_name in class_name_mapping.items():
            # Replace class definitions
            content = re.sub(
                rf"class\s+{original_name}\s*:",
                f"class {new_name}:",
                content
            )

    # Process all property definitions
    lines = content.split('\n')
    for i in range(len(lines)):
        line = lines[i]

        # Skip if this is not a class property line
        if not re.search(r'^\s+\w+\s*:', line):
            continue

        # Replace typing annotations with module references
        line = re.sub(r':\s*Any\s*=', r': typing.Any =', line)  # Replace standalone Any as a type
        line = re.sub(r':\s*Union\s*=', r': typing.Union =', line)  # Replace standalone Union as a type
        line = re.sub(r':\s*Dict\s*=', r': typing.Dict =', line)  # Replace standalone Dict as a type
        line = re.sub(r'Optional\[', r'typing.Optional[', line)
        line = re.sub(r'List\[', r'typing.List[', line)
        line = re.sub(r'Union\[', r'typing.Union[', line)  # Add handling for Union types
        line = re.sub(r'Dict\[', r'typing.Dict[', line)  # Add handling for Dict types
        line = re.sub(r'(\[|,\s*)Any(\]|,|\s*\]=)', r'\1typing.Any\2', line)  # Match Any inside brackets or between commas
        line = re.sub(r'(\[|,\s*)Union(\[)', r'\1typing.Union\2', line)  # Match Union inside brackets or between commas
        line = re.sub(r'(\[|,\s*)Dict(\[)', r'\1typing.Dict\2', line)  # Match Dict inside brackets or between commas

        # Handle nested Union inside Optional
        line = re.sub(r'typing\.Optional\[(Union\[)', r'typing.Optional[typing.\1', line)

        # Handle nested Dict inside Optional
        line = re.sub(r'typing\.Optional\[(Dict\[)', r'typing.Optional[typing.\1', line)

        # Handle properties with null values (e.g., "category: None" -> "category: typing.Any = None")
        line = re.sub(r'(\w+):\s*None\s*$', r'\1: typing.Any = None', line)
        lines[i] = line

        # Handle complex type annotations for each class
        for original_name in class_names:
            class_name = class_name_mapping.get(original_name, original_name) if append_type_suffix else original_name

            # Update type annotations references only, not field names
            if append_type_suffix and original_name != class_name:
                # Replace original_name with class_name only when it's inside type annotation brackets
                # This prevents changing field names that match class names

                # Handle typing.Optional[OriginalName]
                pattern = re.compile(rf'(typing\.\w+\[)({original_name})(\])')
                lines[i] = re.sub(pattern, f'\\1{class_name}\\3', lines[i])

                # Handle Union types that contain the class name
                union_pattern = re.compile(rf'(typing\.Union\[[^,\]]*,\s*)({original_name})(\s*\]|\s*,)')
                lines[i] = re.sub(union_pattern, f'\\1{class_name}\\3', lines[i])

                # Also handle Union when the class name is the first element
                union_first_pattern = re.compile(rf'(typing\.Union\[)({original_name})(\s*,)')
                lines[i] = re.sub(union_first_pattern, f'\\1{class_name}\\3', lines[i])

                # Handle Dict with class name as key or value type
                dict_pattern = re.compile(rf'(typing\.Dict\[[^,\]]*,\s*)({original_name})(\s*\])')
                lines[i] = re.sub(dict_pattern, f'\\1{class_name}\\3', lines[i])

                # Handle Dict with class name as key type
                dict_key_pattern = re.compile(rf'(typing\.Dict\[)({original_name})(\s*,)')
                lines[i] = re.sub(dict_key_pattern, f'\\1{class_name}\\3', lines[i])

                # Handle nested types: typing.Optional[typing.List[OriginalName]]
                nested_pattern = re.compile(rf'(typing\.\w+\[typing\.\w+\[)({original_name})(\]\])')
                lines[i] = re.sub(nested_pattern, f'\\1{class_name}\\3', lines[i])

                # Handle jstruct.JStruct[OriginalName]
                jstruct_pattern = re.compile(rf'(jstruct\.JStruct\[)({original_name})(\])')
                lines[i] = re.sub(jstruct_pattern, f'\\1{class_name}\\3', lines[i])

                # Handle jstruct.JList[OriginalName]
                jlist_pattern = re.compile(rf'(jstruct\.JList\[)({original_name})(\])')
                lines[i] = re.sub(jlist_pattern, f'\\1{class_name}\\3', lines[i])

            # Check for Optional[ClassType]
            if re.search(rf'typing\.Optional\[{class_name}\]\s*=\s*None', lines[i]):
                lines[i] = re.sub(
                    rf'typing\.Optional\[{class_name}\]\s*=\s*None',
                    f'typing.Optional[{class_name}] = jstruct.JStruct[{class_name}]',
                    lines[i]
                )

            # Check for List[ClassType]
            elif re.search(rf'typing\.List\[{class_name}\]\s*=\s*None', lines[i]):
                lines[i] = re.sub(
                    rf'typing\.List\[{class_name}\]\s*=\s*None',
                    f'typing.List[{class_name}] = jstruct.JList[{class_name}]',
                    lines[i]
                )

            # Check for Optional[List[ClassType]]
            elif re.search(rf'typing\.Optional\[typing\.List\[{class_name}\]\]\s*=\s*None', lines[i]):
                lines[i] = re.sub(
                    rf'typing\.Optional\[typing\.List\[{class_name}\]\]\s*=\s*None',
                    f'typing.Optional[typing.List[{class_name}]] = jstruct.JList[{class_name}]',
                    lines[i]
                )

            # Check for Optional[Union[...]]
            elif re.search(rf'typing\.Optional\[typing\.Union\[[^\]]*{class_name}[^\]]*\]\]\s*=\s*None', lines[i]):
                # For simplicity, we're not replacing the value here since Union types are complex
                # and we don't want to make assumptions about the appropriate jstruct type
                pass

            # Check for Optional[Dict[...]]
            elif re.search(rf'typing\.Optional\[typing\.Dict\[[^\]]*{class_name}[^\]]*\]\]\s*=\s*None', lines[i]):
                # For simplicity, we're not replacing the value here since Dict types are complex
                # and we don't want to make assumptions about the appropriate jstruct type
                pass

    return '\n'.join(lines)

@app.command("generate")
def generate(
    input_file: str = typer.Argument(..., help="Input JSON schema file path"),
    output_file: Optional[str] = typer.Argument(
        None, help="Output Python file path. If not provided, writes to stdout."
    ),
    python_version: str = typer.Option("3.11", help="Python version to target"),
    just_types: bool = typer.Option(True, help="Generate just the type definitions without serialization code"),
    append_type_suffix: bool = typer.Option(True, help="Append 'Type' to class names"),
    nice_property_names: bool = typer.Option(False, help="Use nice property names"),
):
    """
    Generate Python code with jstruct from a JSON schema file using quicktype.
    """
    import subprocess

    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    # Build quicktype command
    cmd = [
        "npx",
        "quicktype",
        "--no-uuids",
        "--no-enums",
        "--no-date-times",
        "--src-lang", "json",
        "--lang", "python",
        "--all-properties-optional",
        "--no-nice-property-names",
        f"--python-version", python_version,
        "--src", input_file
    ]

    if just_types:
        cmd.append("--just-types")

    if nice_property_names:
        cmd.remove("--no-nice-property-names")

    # Run quicktype to generate Python code with dataclasses
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        logger.error(f"Error generating code for {os.path.basename(input_file)}: {result.stderr}")
        print(f"Error running quicktype: {result.stderr}", file=sys.stderr)
        sys.exit(1)

    # Transform the output to use jstruct
    transformed = transform_content(result.stdout, append_type_suffix)

    # Write output to file or stdout
    if output_file:
        with open(output_file, "w") as f:
            f.write(transformed)
        logger.info(f"Generated {os.path.basename(output_file)} from {os.path.basename(input_file)}")
    else:
        print(transformed)
        logger.info(f"Generated code from {os.path.basename(input_file)} to stdout")

def instantiate_tree(cls, indent=0, alias=""):
    tree = f"{alias}{cls.__name__}(\n"
    indent += 1
    items = cls.__annotations__.items() if hasattr(cls, "__annotations__") else []

    for name, typ in items:
        if typ.__name__ == "Optional" and hasattr(typ, "__args__"):
            typ = typ.__args__[0]
        if typ.__name__ == "List" and hasattr(typ, "__args__"):
            typ = typ.__args__[0]
            if hasattr(typ, "__annotations__"):
                tree += (
                    " " * indent * 4
                    + f"{name}=[\n"
                    + " " * (indent + 1) * 4
                    + f"{instantiate_tree(typ, indent + 1, alias=alias)}\n"
                    + " " * indent * 4
                    + "],\n"
                )
            else:
                tree += " " * indent * 4 + f"{name}=[],\n"
        elif hasattr(typ, "__annotations__"):
            tree += (
                " " * indent * 4
                + f"{name}={instantiate_tree(typ, indent, alias=alias)},\n"
            )
        else:
            tree += " " * indent * 4 + f"{name}=None,\n"

    tree += " " * (indent - 1) * 4 + ")"
    return tree


def instantiate_class_from_module(
    module_name: str,
    class_name: str,
    module_alias: str = "",
):
    module = importlib.import_module(module_name)
    cls = getattr(module, class_name)
    alias = f"{module_alias}." if module_alias != "" else ""

    return instantiate_tree(cls, alias=alias)


@app.command("create-tree")
def create_tree(
    module: str = typer.Option(..., prompt=True, help="Module containing the class"),
    class_name: str = typer.Option(..., prompt=True, help="Class name to generate a tree for"),
    module_alias: str = typer.Option("", help="Optional alias for the module in the output"),
):
    """
    Generate a Python code tree from a class definition.

    This command imports a class from a specified module and generates
    a Python code snippet that shows how to construct an instance of that class
    with all its nested properties.
    """
    if not module or not class_name:
        print("module and class_name are required")
        raise typer.Abort()

    output = instantiate_class_from_module(
        module,
        class_name,
        module_alias=module_alias,
    )
    typer.echo(output)

if __name__ == "__main__":
    app()
