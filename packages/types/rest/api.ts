/* tslint:disable */
/* eslint-disable */
/**
 * Karrio API
 *  Karrio is a multi-carrier shipping API that simplifies the integration of logistics carrier services.  The Karrio API is organized around REST. Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  The Karrio API differs for every account as we release new versions. These docs are customized to your version of the API.   ## Versioning  When backwards-incompatible changes are made to the API, a new, dated version is released. The current version is `2025.5rc30`.  Read our API changelog to learn more about backwards compatibility.  As a precaution, use API versioning to check a new API version before committing to an upgrade.   ## Environments  The Karrio API offer the possibility to create and retrieve certain objects in `test_mode`. In development, it is therefore possible to add carrier connections, get live rates, buy labels, create trackers and schedule pickups in `test_mode`.   ## Pagination  All top-level API resources have support for bulk fetches via \"list\" API methods. For instance, you can list addresses, list shipments, and list trackers. These list API methods share a common structure, taking at least these two parameters: limit, and offset.  Karrio utilizes offset-based pagination via the offset and limit parameters. Both parameters take a number as value (see below) and return objects in reverse chronological order. The offset parameter returns objects listed after an index. The limit parameter take a limit on the number of objects to be returned from 1 to 100.   ```json {     \"count\": 100,     \"next\": \"/v1/shipments?limit=25&offset=50\",     \"previous\": \"/v1/shipments?limit=25&offset=25\",     \"results\": [         { ... },     ] } ```  ## Metadata  Updateable Karrio objectsâ€”including Shipment and Order have a metadata parameter. You can use this parameter to attach key-value data to these Karrio objects.  Metadata is useful for storing additional, structured information on an object. As an example, you could store your user\'s full name and corresponding unique identifier from your system on a Karrio Order object.  Do not store any sensitive information as metadata.  ## Authentication  API keys are used to authenticate requests. You can view and manage your API keys in the Dashboard.  Your API keys carry many privileges, so be sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as GitHub, client-side code, and so forth.  Authentication to the API is performed via HTTP Basic Auth. Provide your API token as the basic auth username value. You do not need to provide a password.  ```shell $ curl https://instance.api.com/v1/shipments \\     -u key_xxxxxx: # The colon prevents curl from asking for a password. ```  If you need to authenticate via bearer auth (e.g., for a cross-origin request), use `-H \"Authorization: Token key_xxxxxx\"` instead of `-u key_xxxxxx`.  All API requests must be made over [HTTPS](http://en.wikipedia.org/wiki/HTTP_Secure). API requests without authentication will also fail. 
 *
 * The version of the OpenAPI document: 2025.5rc30
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface APIError {
    /**
     * The error or warning message
     */
    'message'?: string;
    /**
     * The message code
     */
    'code'?: string;
    /**
     * any additional details
     */
    'details'?: { [key: string]: any; };
}
export interface Address {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     */
    'company_name'?: string | null;
    /**
     * The address country code
     */
    'country_code': AddressCountryCodeEnum;
    /**
     * The party email
     */
    'email'?: string | null;
    /**
     * The party phone number.
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * Specify address validation result
     */
    'validation'?: AddressValidation | null;
}

export const AddressCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type AddressCountryCodeEnum = typeof AddressCountryCodeEnum[keyof typeof AddressCountryCodeEnum];

export interface AddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     */
    'company_name'?: string | null;
    /**
     * The address country code
     */
    'country_code': AddressDataCountryCodeEnum;
    /**
     * The party email
     */
    'email'?: string | null;
    /**
     * The party phone number.
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     */
    'validate_location'?: boolean | null;
}

export const AddressDataCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type AddressDataCountryCodeEnum = typeof AddressDataCountryCodeEnum[keyof typeof AddressDataCountryCodeEnum];

export interface AddressList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Address>;
}
export interface AddressValidation {
    /**
     * True if the address is valid
     */
    'success': boolean;
    /**
     * validation service details
     */
    'meta'?: { [key: string]: any; } | null;
}
export interface Aramex {
    'username': string;
    'password': string;
    'account_pin': string;
    'account_entity': string;
    'account_number': string;
    'account_country_code': string;
}
export interface AsendiaUs {
    'username': string;
    'password': string;
    'api_key': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface Australiapost {
    'api_key': string;
    'password': string;
    'account_number': string;
    'account_country_code'?: string | null;
}
export interface BatchObject {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The batch operation resource status
     */
    'status': BatchObjectStatusEnum;
    /**
     * Resource processing errors
     */
    'errors'?: { [key: string]: any; } | null;
}

export const BatchObjectStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Failed: 'failed',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors'
} as const;

export type BatchObjectStatusEnum = typeof BatchObjectStatusEnum[keyof typeof BatchObjectStatusEnum];

export interface BatchOperation {
    /**
     * A unique identifier
     */
    'id'?: string;
    'status': BatchOperationStatusEnum;
    'resource_type': BatchOperationResourceTypeEnum;
    'resources': Array<BatchObject>;
    'created_at': string;
    'updated_at': string;
    'test_mode': boolean;
}

export const BatchOperationStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Failed: 'failed',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors'
} as const;

export type BatchOperationStatusEnum = typeof BatchOperationStatusEnum[keyof typeof BatchOperationStatusEnum];
export const BatchOperationResourceTypeEnum = {
    Orders: 'orders',
    Shipments: 'shipments',
    Trackers: 'trackers',
    Billing: 'billing'
} as const;

export type BatchOperationResourceTypeEnum = typeof BatchOperationResourceTypeEnum[keyof typeof BatchOperationResourceTypeEnum];

export interface BatchOperations {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<BatchOperation>;
}
export interface BatchOrderData {
    /**
     * The list of orders to process.
     */
    'orders': Array<OrderData>;
}
export interface BatchShipmentData {
    /**
     * The list of shipments to process.
     */
    'shipments': Array<ShipmentDataReference>;
}
export interface BatchTrackerData {
    /**
     * The list of tracking info to process.
     */
    'trackers': Array<TrackingData>;
}
export interface Boxknight {
    'username': string;
    'password': string;
    'account_country_code'?: string | null;
}
export interface Bpost {
    'account_id': string;
    'passphrase': string;
    'account_country_code'?: string | null;
}
export interface Canadapost {
    'username': string;
    'password': string;
    'customer_number'?: string | null;
    'contract_id'?: string | null;
    /**
     * Indicates a language string
     */
    'language'?: CanadapostLanguageEnum;
    'account_country_code'?: string | null;
}

export const CanadapostLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type CanadapostLanguageEnum = typeof CanadapostLanguageEnum[keyof typeof CanadapostLanguageEnum];

export interface Canpar {
    'username': string;
    'password': string;
    /**
     * Indicates a language string
     */
    'language'?: CanparLanguageEnum;
    'account_country_code'?: string | null;
}

export const CanparLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type CanparLanguageEnum = typeof CanparLanguageEnum[keyof typeof CanparLanguageEnum];

export interface CarrierConnection {
    /**
     * A unique carrier connection identifier
     */
    'id': string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * A carrier connection type.
     */
    'carrier_name': CarrierConnectionCarrierNameEnum;
    /**
     * The carrier connection type verbose name.
     */
    'display_name'?: string;
    /**
     * A carrier connection friendly name.
     */
    'carrier_id': string;
    /**
     * Carrier connection credentials.
     */
    'credentials'?: ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The carrier connection is provided by the system admin.
     */
    'is_system': boolean;
    /**
     * The active flag indicates whether the carrier account is active or not.
     */
    'active': boolean;
    /**
     * The test flag indicates whether to use a carrier configured for test.
     */
    'test_mode': boolean;
}

export const CarrierConnectionCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierConnectionCarrierNameEnum = typeof CarrierConnectionCarrierNameEnum[keyof typeof CarrierConnectionCarrierNameEnum];

export interface CarrierConnectionData {
    /**
     * A carrier connection type.
     */
    'carrier_name': CarrierConnectionDataCarrierNameEnum;
    /**
     * A carrier connection friendly name.
     */
    'carrier_id': string;
    /**
     * Carrier connection credentials.
     */
    'credentials': ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The active flag indicates whether the carrier account is active or not.
     */
    'active'?: boolean;
}

export const CarrierConnectionDataCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierConnectionDataCarrierNameEnum = typeof CarrierConnectionDataCarrierNameEnum[keyof typeof CarrierConnectionDataCarrierNameEnum];

export interface CarrierConnectionList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<CarrierConnection>;
}
export interface CarrierDetails {
    /**
     * Indicates a carrier (type)
     */
    'carrier_name': CarrierDetailsCarrierNameEnum;
    /**
     * The carrier verbose name.
     */
    'display_name': string;
    /**
     * The carrier integration status.
     */
    'integration_status': CarrierDetailsIntegrationStatusEnum;
    /**
     * The carrier supported and enabled capabilities.
     */
    'capabilities'?: Array<string>;
    /**
     * The carrier connection fields.
     */
    'connection_fields'?: { [key: string]: any; };
    /**
     * The carrier connection config.
     */
    'config_fields'?: { [key: string]: any; };
    /**
     * The carrier shipping services.
     */
    'shipping_services'?: { [key: string]: any; };
    /**
     * The carrier shipping options.
     */
    'shipping_options'?: { [key: string]: any; };
}

export const CarrierDetailsCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierDetailsCarrierNameEnum = typeof CarrierDetailsCarrierNameEnum[keyof typeof CarrierDetailsCarrierNameEnum];
export const CarrierDetailsIntegrationStatusEnum = {
    InDevelopment: 'in-development',
    Beta: 'beta',
    ProductionReady: 'production-ready'
} as const;

export type CarrierDetailsIntegrationStatusEnum = typeof CarrierDetailsIntegrationStatusEnum[keyof typeof CarrierDetailsIntegrationStatusEnum];

export interface Charge {
    /**
     * The charge description
     */
    'name'?: string | null;
    /**
     * The charge monetary value
     */
    'amount'?: number | null;
    /**
     * The charge amount currency
     */
    'currency'?: string | null;
    /**
     * A surcharge id
     */
    'id'?: string | null;
}
export interface Chronopost {
    'account_number': string;
    'password': string;
    'id_emit'?: string | null;
    /**
     * Indicates a language string
     */
    'language'?: ChronopostLanguageEnum;
    'account_country_code'?: string | null;
}

export const ChronopostLanguageEnum = {
    EnGb: 'en_GB',
    FrFr: 'fr_FR'
} as const;

export type ChronopostLanguageEnum = typeof ChronopostLanguageEnum[keyof typeof ChronopostLanguageEnum];

export interface Colissimo {
    'password': string;
    'contract_number': string;
    'laposte_api_key'?: string | null;
    'account_country_code'?: string | null;
}
export interface Commodity {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     */
    'weight_unit': CommodityWeightUnitEnum;
    /**
     * A description of the commodity
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     */
    'value_currency'?: CommodityValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     */
    'origin_country'?: CommodityOriginCountryEnum | null;
    /**
     * The product url
     */
    'product_url'?: string | null;
    /**
     * The image url
     */
    'image_url'?: string | null;
    /**
     * The product id
     */
    'product_id'?: string | null;
    /**
     * The variant id
     */
    'variant_id'?: string | null;
    /**
     * The id of the related order line item.
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
}

export const CommodityWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type CommodityWeightUnitEnum = typeof CommodityWeightUnitEnum[keyof typeof CommodityWeightUnitEnum];
export const CommodityValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type CommodityValueCurrencyEnum = typeof CommodityValueCurrencyEnum[keyof typeof CommodityValueCurrencyEnum];
export const CommodityOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type CommodityOriginCountryEnum = typeof CommodityOriginCountryEnum[keyof typeof CommodityOriginCountryEnum];

export interface CommodityData {
    /**
     * The commodity\'s weight
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     */
    'weight_unit': CommodityDataWeightUnitEnum;
    /**
     * A description of the commodity
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     */
    'value_currency'?: CommodityDataValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     */
    'origin_country'?: CommodityDataOriginCountryEnum | null;
    /**
     * The product url
     */
    'product_url'?: string | null;
    /**
     * The image url
     */
    'image_url'?: string | null;
    /**
     * The product id
     */
    'product_id'?: string | null;
    /**
     * The variant id
     */
    'variant_id'?: string | null;
    /**
     * The id of the related order line item.
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     */
    'metadata'?: { [key: string]: any; } | null;
}

export const CommodityDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type CommodityDataWeightUnitEnum = typeof CommodityDataWeightUnitEnum[keyof typeof CommodityDataWeightUnitEnum];
export const CommodityDataValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type CommodityDataValueCurrencyEnum = typeof CommodityDataValueCurrencyEnum[keyof typeof CommodityDataValueCurrencyEnum];
export const CommodityDataOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type CommodityDataOriginCountryEnum = typeof CommodityDataOriginCountryEnum[keyof typeof CommodityDataOriginCountryEnum];

/**
 * @type ConnectionCredentialsField
 */
export type ConnectionCredentialsField = Aramex | AsendiaUs | Australiapost | Boxknight | Bpost | Canadapost | Canpar | Chronopost | Colissimo | DhlExpress | DhlParcelDe | DhlPoland | DhlUniversal | Dicom | Dpd | Dtdc | Easypost | Easyship | Eshipper | Fedex | Freightcom | Generic | Geodis | HayPost | Landmark | Laposte | Locate2u | Mydhl | Nationex | Purolator | Roadie | Royalmail | Sapient | Seko | Sendle | Shipengine | Tge | Tnt | Ups | Usps | UspsInternational | Veho | Zoom2u;

export interface Customs {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The parcel content items
     */
    'commodities'?: Array<Commodity>;
    /**
     * The payment details.<br/>         **Note that this is required for a Dutiable parcel shipped internationally.**         
     */
    'duty'?: Duty | null;
    /**
     * The duty payor address.
     */
    'duty_billing_address'?: Address | null;
    'content_type'?: CustomsContentTypeEnum | null;
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     */
    'incoterm'?: CustomsIncotermEnum | null;
    /**
     * The invoice reference number
     */
    'invoice'?: string | null;
    /**
     * The invoice date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     */
    'certify'?: boolean | null;
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     */
    'object_type'?: string;
}

export const CustomsContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other',
    Empty: ''
} as const;

export type CustomsContentTypeEnum = typeof CustomsContentTypeEnum[keyof typeof CustomsContentTypeEnum];
export const CustomsIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Dap: 'DAP',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB'
} as const;

export type CustomsIncotermEnum = typeof CustomsIncotermEnum[keyof typeof CustomsIncotermEnum];

export interface CustomsData {
    /**
     * The parcel content items
     */
    'commodities': Array<CommodityData>;
    /**
     * The payment details.<br/>         **Note that this is required for a Dutiable parcel shipped internationally.**         
     */
    'duty'?: Duty | null;
    /**
     * The duty payor address.
     */
    'duty_billing_address'?: AddressData | null;
    'content_type'?: CustomsDataContentTypeEnum | null;
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     */
    'incoterm'?: CustomsDataIncotermEnum | null;
    /**
     * The invoice reference number
     */
    'invoice'?: string | null;
    /**
     * The invoice date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     */
    'certify'?: boolean | null;
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         </details>         
     */
    'options'?: { [key: string]: any; };
}

export const CustomsDataContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other',
    Empty: ''
} as const;

export type CustomsDataContentTypeEnum = typeof CustomsDataContentTypeEnum[keyof typeof CustomsDataContentTypeEnum];
export const CustomsDataIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Dap: 'DAP',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB'
} as const;

export type CustomsDataIncotermEnum = typeof CustomsDataIncotermEnum[keyof typeof CustomsDataIncotermEnum];

export interface DhlExpress {
    'site_id': string;
    'password': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface DhlParcelDe {
    'username': string;
    'password': string;
    'dhl_api_key': string;
    'customer_number'?: string | null;
    'tracking_consumer_key'?: string | null;
    'tracking_consumer_secret'?: string | null;
    'account_country_code'?: string | null;
}
export interface DhlPoland {
    'username': string;
    'password': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface DhlUniversal {
    'consumer_key': string;
    'consumer_secret': string;
    /**
     * Indicates a language string
     */
    'language'?: DhlUniversalLanguageEnum;
    'account_country_code'?: string | null;
}

export const DhlUniversalLanguageEnum = {
    En: 'en',
    De: 'de'
} as const;

export type DhlUniversalLanguageEnum = typeof DhlUniversalLanguageEnum[keyof typeof DhlUniversalLanguageEnum];

export interface Dicom {
    'username': string;
    'password': string;
    'billing_account'?: string | null;
    'account_country_code'?: string | null;
}
export interface DocumentData {
    /**
     * The template name. **Required if template is not provided.**
     */
    'template_id'?: string;
    /**
     * The template content. **Required if template_id is not provided.**
     */
    'template'?: string;
    /**
     * The format of the document
     */
    'doc_format'?: string;
    /**
     * The file name
     */
    'doc_name'?: string;
    /**
     * The template data
     */
    'data'?: { [key: string]: any; };
    /**
     * The template rendering options
     */
    'options'?: { [key: string]: any; };
}
export interface DocumentDetails {
    /**
     * The uploaded document id.
     */
    'doc_id'?: string;
    /**
     * The uploaded document file name.
     */
    'file_name'?: string;
}
export interface DocumentFileData {
    /**
     * A base64 file to upload
     */
    'doc_file': string;
    /**
     * The file name
     */
    'doc_name': string;
    /**
     * The file format
     */
    'doc_format'?: string | null;
    /**
     *          Shipment document type          values: <br/>         `certificate_of_origin` `commercial_invoice` `pro_forma_invoice` `packing_list` `other`          For carrier specific packaging types, please consult the reference.         
     */
    'doc_type'?: string | null;
}
export interface DocumentTemplate {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The template name
     */
    'name': string;
    /**
     * The template slug
     */
    'slug': string;
    /**
     * The template content
     */
    'template': string;
    /**
     * disable template flag.
     */
    'active'?: boolean;
    /**
     * The template description
     */
    'description'?: string;
    /**
     * The template metadata
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template rendering options
     */
    'options'?: { [key: string]: any; };
    /**
     * The template related object
     */
    'related_object'?: DocumentTemplateRelatedObjectEnum;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The template preview URL
     */
    'preview_url'?: string;
}

export const DocumentTemplateRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type DocumentTemplateRelatedObjectEnum = typeof DocumentTemplateRelatedObjectEnum[keyof typeof DocumentTemplateRelatedObjectEnum];

export interface DocumentTemplateData {
    /**
     * The template name
     */
    'name': string;
    /**
     * The template slug
     */
    'slug': string;
    /**
     * The template content
     */
    'template': string;
    /**
     * disable template flag.
     */
    'active'?: boolean;
    /**
     * The template description
     */
    'description'?: string;
    /**
     * The template metadata
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template rendering options
     */
    'options'?: { [key: string]: any; };
    /**
     * The template related object
     */
    'related_object'?: DocumentTemplateDataRelatedObjectEnum;
}

export const DocumentTemplateDataRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type DocumentTemplateDataRelatedObjectEnum = typeof DocumentTemplateDataRelatedObjectEnum[keyof typeof DocumentTemplateDataRelatedObjectEnum];

export interface DocumentTemplateList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<DocumentTemplate>;
}
export interface DocumentUploadData {
    /**
     * The documents related shipment.
     */
    'shipment_id': string;
    /**
     * Shipping document files
     */
    'document_files': Array<DocumentFileData>;
    /**
     * Shipping document file reference
     */
    'reference'?: string | null;
}
export interface DocumentUploadRecord {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The shipment carrier
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     */
    'carrier_id'?: string | null;
    /**
     * the carrier shipping document ids
     */
    'documents'?: Array<DocumentDetails>;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Shipping document file reference
     */
    'reference'?: string | null;
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
}
export interface DocumentUploadRecords {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<DocumentUploadRecord>;
}
export interface Documents {
    /**
     * A shipping label in base64 string
     */
    'label'?: string | null;
    /**
     * A shipping invoice in base64 string
     */
    'invoice'?: string | null;
}
export interface Dpd {
    'delis_id': string;
    'password': string;
    'depot'?: string | null;
    'message_language'?: string | null;
    'account_country_code'?: string | null;
}
export interface Dtdc {
    'api_key': string;
    'customer_code': string;
    'username'?: string | null;
    'password'?: string | null;
    'account_country_code'?: string | null;
}
export interface Duty {
    /**
     * The duty payer
     */
    'paid_by'?: DutyPaidByEnum | null;
    /**
     * The declared value currency
     */
    'currency'?: DutyCurrencyEnum | null;
    /**
     * The package declared value
     */
    'declared_value'?: number | null;
    /**
     * The duty payment account number
     */
    'account_number'?: string | null;
}

export const DutyPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party',
    Empty: ''
} as const;

export type DutyPaidByEnum = typeof DutyPaidByEnum[keyof typeof DutyPaidByEnum];
export const DutyCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Empty: ''
} as const;

export type DutyCurrencyEnum = typeof DutyCurrencyEnum[keyof typeof DutyCurrencyEnum];

export interface Easypost {
    'api_key': string;
    'account_country_code'?: string | null;
}
export interface Easyship {
    'access_token': string;
    'account_country_code'?: string | null;
}
export interface ErrorMessages {
    /**
     * The list of error messages
     */
    'messages'?: Array<Message>;
}
export interface ErrorResponse {
    /**
     * The list of API errors
     */
    'errors'?: Array<APIError>;
}
export interface Eshipper {
    'principal': string;
    'credential': string;
    'account_country_code'?: string | null;
}
export interface Fedex {
    'api_key'?: string | null;
    'secret_key'?: string | null;
    'account_number'?: string | null;
    'track_api_key'?: string | null;
    'track_secret_key'?: string | null;
    'account_country_code'?: string | null;
}
export interface Freightcom {
    'username': string;
    'password': string;
    'account_country_code'?: string | null;
}
export interface GeneratedDocument {
    /**
     * The template name
     */
    'template_id'?: string;
    /**
     * The format of the document
     */
    'doc_format'?: string;
    /**
     * The file name
     */
    'doc_name'?: string;
    /**
     * A base64 file content
     */
    'doc_file': string;
}
export interface Generic {
    'display_name': string;
    'custom_carrier_name': string;
    'account_country_code'?: string | null;
    'account_number'?: string | null;
}
export interface Geodis {
    'api_key': string;
    'identifier': string;
    'code_client'?: string | null;
    /**
     * Indicates a language string
     */
    'language'?: GeodisLanguageEnum;
    'account_country_code'?: string | null;
}

export const GeodisLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;

export type GeodisLanguageEnum = typeof GeodisLanguageEnum[keyof typeof GeodisLanguageEnum];

export interface HayPost {
    'username': string;
    'password': string;
    'customer_id': string;
    'customer_type': string;
    'account_country_code'?: string | null;
}
export interface Images {
    /**
     * A delivery image in base64 string
     */
    'delivery_image'?: string | null;
    /**
     * A signature image in base64 string
     */
    'signature_image'?: string | null;
}
export interface Landmark {
    'username': string;
    'password': string;
    'client_id': string;
    'account_number'?: string | null;
    'region'?: string | null;
    'account_country_code'?: string | null;
}
export interface Laposte {
    'api_key': string;
    /**
     * Indicates a lang string
     */
    'lang'?: LaposteLangEnum;
    'account_country_code'?: string | null;
}

export const LaposteLangEnum = {
    FrFr: 'fr_FR',
    EnUs: 'en_US'
} as const;

export type LaposteLangEnum = typeof LaposteLangEnum[keyof typeof LaposteLangEnum];

export interface LineItem {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     */
    'weight_unit': LineItemWeightUnitEnum;
    /**
     * A description of the commodity
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     */
    'value_currency'?: LineItemValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     */
    'origin_country'?: LineItemOriginCountryEnum | null;
    /**
     * The product url
     */
    'product_url'?: string | null;
    /**
     * The image url
     */
    'image_url'?: string | null;
    /**
     * The product id
     */
    'product_id'?: string | null;
    /**
     * The variant id
     */
    'variant_id'?: string | null;
    /**
     * The id of the related order line item.
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    'unfulfilled_quantity'?: number;
}

export const LineItemWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type LineItemWeightUnitEnum = typeof LineItemWeightUnitEnum[keyof typeof LineItemWeightUnitEnum];
export const LineItemValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type LineItemValueCurrencyEnum = typeof LineItemValueCurrencyEnum[keyof typeof LineItemValueCurrencyEnum];
export const LineItemOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type LineItemOriginCountryEnum = typeof LineItemOriginCountryEnum[keyof typeof LineItemOriginCountryEnum];

export interface Locate2u {
    'client_id'?: string | null;
    'client_secret'?: string | null;
    'account_country_code'?: string | null;
}
export interface Manifest {
    /**
     * A unique manifest identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The manifest carrier
     */
    'carrier_name': string;
    /**
     * The manifest carrier configured name
     */
    'carrier_id': string;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
    /**
     * The address of the warehouse or location where the shipments originate.
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     */
    'reference'?: string | null;
    /**
     * The list of shipment identifiers you want to add to your manifest.<br/>         shipment_identifier is often a tracking_number or shipment_id returned when you purchase a label.         
     */
    'shipment_identifiers': Array<string>;
    /**
     * User metadata for the pickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The Manifest file URL
     */
    'manifest_url'?: string | null;
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
}
export interface ManifestData {
    /**
     * The manifest\'s carrier
     */
    'carrier_name': string;
    /**
     * The address of the warehouse or location where the shipments originate.
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     */
    'reference'?: string | null;
    /**
     * The list of existing shipment object ids with label purchased.
     */
    'shipment_ids': Array<string>;
}
export interface ManifestDetails {
    /**
     * A unique manifest identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The manifest carrier
     */
    'carrier_name': string;
    /**
     * The manifest carrier configured name
     */
    'carrier_id': string;
    /**
     * The manifest documents
     */
    'doc'?: ManifestDocument | null;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
}
export interface ManifestDocument {
    /**
     * A manifest file in base64 string
     */
    'manifest'?: string | null;
}
export interface ManifestList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Manifest>;
}
export interface ManifestRequest {
    /**
     * The manifest\'s carrier
     */
    'carrier_name': string;
    /**
     * The address of the warehouse or location where the shipments originate.
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     */
    'reference'?: string | null;
    /**
     * The list of shipment identifiers you want to add to your manifest.<br/>         shipment_identifier is often a tracking_number or shipment_id returned when you purchase a label.         
     */
    'shipment_identifiers': Array<string>;
}
export interface ManifestResponse {
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The manifest details
     */
    'manifest'?: ManifestDetails;
}
export interface Message {
    /**
     * The error or warning message
     */
    'message'?: string;
    /**
     * The message code
     */
    'code'?: string;
    /**
     * any additional details
     */
    'details'?: { [key: string]: any; };
    /**
     * The targeted carrier
     */
    'carrier_name'?: string;
    /**
     * The targeted carrier name (unique identifier)
     */
    'carrier_id'?: string;
}
export interface Mydhl {
    'username': string;
    'password': string;
    'account_number': string;
    'account_country_code'?: string | null;
}
export interface Nationex {
    'api_key': string;
    'customer_id': string;
    'billing_account'?: string | null;
    /**
     * Indicates a language string
     */
    'language'?: NationexLanguageEnum;
    'account_country_code'?: string | null;
}

export const NationexLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type NationexLanguageEnum = typeof NationexLanguageEnum[keyof typeof NationexLanguageEnum];

export interface Operation {
    /**
     * Operation performed
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     */
    'success': boolean;
}
export interface OperationConfirmation {
    /**
     * Operation performed
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     */
    'success': boolean;
    /**
     * The operation carrier
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     */
    'carrier_id': string;
}
export interface OperationResponse {
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The operation details
     */
    'confirmation'?: OperationConfirmation;
}
export interface Order {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The source\' order id.
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.
     */
    'source'?: string;
    /**
     * The order status.
     */
    'status'?: OrderStatusEnum;
    /**
     * The customer address for the order.
     */
    'shipping_to': Address;
    /**
     * The origin or warehouse address of the order items.
     */
    'shipping_from'?: Address | null;
    /**
     * The customer\' or shipping billing address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The order line items.
     */
    'line_items': Array<LineItem>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],             \"preferred_service\": \"fedex_express_saver\",         }         </details>         
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * system related metadata.
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The shipments associated with the order.
     */
    'shipments'?: Array<Shipment>;
    /**
     * Specify whether the order is in test mode or not.
     */
    'test_mode': boolean;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     */
    'created_at': string;
}

export const OrderStatusEnum = {
    Unfulfilled: 'unfulfilled',
    Cancelled: 'cancelled',
    Fulfilled: 'fulfilled',
    Delivered: 'delivered',
    Partial: 'partial'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

export interface OrderData {
    /**
     * The source\' order id.
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.<br/>         e.g. API, POS, ERP, Shopify, Woocommerce, etc.         
     */
    'source'?: string;
    /**
     * The customer or recipient address for the order.
     */
    'shipping_to': AddressData;
    /**
     * The origin or warehouse address of the order items.
     */
    'shipping_from'?: AddressData | null;
    /**
     * The customer\' or shipping billing address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The order line items.
     */
    'line_items': Array<CommodityData>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],             \"preferred_service\": \"fedex_express_saver\",         }         </details>         
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     */
    'metadata'?: { [key: string]: any; };
}
export interface OrderList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Order>;
}
export interface OrderUpdateData {
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"recipient\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],         }         </details>         
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
}
export interface Parcel {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The parcel\'s weight
     */
    'weight': number;
    /**
     * The parcel\'s width
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     */
    'weight_unit': ParcelWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     */
    'dimension_unit'?: ParcelDimensionUnitEnum | null;
    /**
     * The parcel items.
     */
    'items'?: Array<Commodity>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     */
    'object_type'?: string;
}

export const ParcelWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type ParcelWeightUnitEnum = typeof ParcelWeightUnitEnum[keyof typeof ParcelWeightUnitEnum];
export const ParcelDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type ParcelDimensionUnitEnum = typeof ParcelDimensionUnitEnum[keyof typeof ParcelDimensionUnitEnum];

export interface ParcelData {
    /**
     * The parcel\'s weight
     */
    'weight': number;
    /**
     * The parcel\'s width
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     */
    'weight_unit': ParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     */
    'dimension_unit'?: ParcelDataDimensionUnitEnum | null;
    /**
     * The parcel items.
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     */
    'options'?: { [key: string]: any; };
}

export const ParcelDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type ParcelDataWeightUnitEnum = typeof ParcelDataWeightUnitEnum[keyof typeof ParcelDataWeightUnitEnum];
export const ParcelDataDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type ParcelDataDimensionUnitEnum = typeof ParcelDataDimensionUnitEnum[keyof typeof ParcelDataDimensionUnitEnum];

export interface ParcelList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Parcel>;
}
export interface PatchedAddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     */
    'company_name'?: string | null;
    /**
     * The address country code
     */
    'country_code'?: PatchedAddressDataCountryCodeEnum;
    /**
     * The party email
     */
    'email'?: string | null;
    /**
     * The party phone number.
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     */
    'validate_location'?: boolean | null;
}

export const PatchedAddressDataCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type PatchedAddressDataCountryCodeEnum = typeof PatchedAddressDataCountryCodeEnum[keyof typeof PatchedAddressDataCountryCodeEnum];

export interface PatchedCarrierConnectionData {
    /**
     * A carrier connection type.
     */
    'carrier_name'?: PatchedCarrierConnectionDataCarrierNameEnum;
    /**
     * A carrier connection friendly name.
     */
    'carrier_id'?: string;
    /**
     * Carrier connection credentials.
     */
    'credentials'?: ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The active flag indicates whether the carrier account is active or not.
     */
    'active'?: boolean;
}

export const PatchedCarrierConnectionDataCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;

export type PatchedCarrierConnectionDataCarrierNameEnum = typeof PatchedCarrierConnectionDataCarrierNameEnum[keyof typeof PatchedCarrierConnectionDataCarrierNameEnum];

export interface PatchedDocumentTemplateData {
    /**
     * The template name
     */
    'name'?: string;
    /**
     * The template slug
     */
    'slug'?: string;
    /**
     * The template content
     */
    'template'?: string;
    /**
     * disable template flag.
     */
    'active'?: boolean;
    /**
     * The template description
     */
    'description'?: string;
    /**
     * The template metadata
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template rendering options
     */
    'options'?: { [key: string]: any; };
    /**
     * The template related object
     */
    'related_object'?: PatchedDocumentTemplateDataRelatedObjectEnum;
}

export const PatchedDocumentTemplateDataRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type PatchedDocumentTemplateDataRelatedObjectEnum = typeof PatchedDocumentTemplateDataRelatedObjectEnum[keyof typeof PatchedDocumentTemplateDataRelatedObjectEnum];

export interface PatchedParcelData {
    /**
     * The parcel\'s weight
     */
    'weight'?: number;
    /**
     * The parcel\'s width
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     */
    'weight_unit'?: PatchedParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     */
    'dimension_unit'?: PatchedParcelDataDimensionUnitEnum | null;
    /**
     * The parcel items.
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     */
    'options'?: { [key: string]: any; };
}

export const PatchedParcelDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type PatchedParcelDataWeightUnitEnum = typeof PatchedParcelDataWeightUnitEnum[keyof typeof PatchedParcelDataWeightUnitEnum];
export const PatchedParcelDataDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type PatchedParcelDataDimensionUnitEnum = typeof PatchedParcelDataDimensionUnitEnum[keyof typeof PatchedParcelDataDimensionUnitEnum];

export interface PatchedWebhookData {
    /**
     * The URL of the webhook endpoint.
     */
    'url'?: string;
    /**
     * An optional description of what the webhook is used for.
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     */
    'enabled_events'?: Array<PatchedWebhookDataEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     */
    'disabled'?: boolean | null;
}

export const PatchedWebhookDataEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type PatchedWebhookDataEnabledEventsEnum = typeof PatchedWebhookDataEnabledEventsEnum[keyof typeof PatchedWebhookDataEnabledEventsEnum];

export interface Payment {
    /**
     * The payor type
     */
    'paid_by'?: PaymentPaidByEnum;
    /**
     * The payment amount currency
     */
    'currency'?: PaymentCurrencyEnum | null;
    /**
     * The payor account number
     */
    'account_number'?: string | null;
}

export const PaymentPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party'
} as const;

export type PaymentPaidByEnum = typeof PaymentPaidByEnum[keyof typeof PaymentPaidByEnum];
export const PaymentCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Empty: ''
} as const;

export type PaymentCurrencyEnum = typeof PaymentCurrencyEnum[keyof typeof PaymentCurrencyEnum];

export interface Pickup {
    /**
     * A unique pickup identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The pickup carrier
     */
    'carrier_name': string;
    /**
     * The pickup carrier configured name
     */
    'carrier_id': string;
    /**
     * The pickup confirmation identifier
     */
    'confirmation_number': string;
    /**
     * The pickup date
     */
    'pickup_date'?: string | null;
    /**
     * The pickup cost details
     */
    'pickup_charge'?: Charge | null;
    /**
     * The pickup expected ready time
     */
    'ready_time'?: string | null;
    /**
     * The pickup expected closing or late time
     */
    'closing_time'?: string | null;
    /**
     * User metadata for the pickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The pickup address
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     */
    'parcels': Array<Parcel>;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
}
export interface PickupCancelData {
    /**
     * The reason of the pickup cancellation
     */
    'reason'?: string;
}
export interface PickupCancelRequest {
    /**
     * The pickup confirmation identifier
     */
    'confirmation_number': string;
    /**
     * The pickup address
     */
    'address'?: AddressData;
    /**
     * The pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'pickup_date'?: string | null;
    /**
     * The reason of the pickup cancellation
     */
    'reason'?: string;
}
export interface PickupData {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'pickup_date': string;
    /**
     * The pickup address
     */
    'address'?: AddressData;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     */
    'tracking_numbers': Array<string>;
    /**
     * User metadata for the pickup
     */
    'metadata'?: { [key: string]: any; };
}
export interface PickupList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Pickup>;
}
export interface PickupRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'pickup_date': string;
    /**
     * The pickup address
     */
    'address': AddressData;
    /**
     * The shipment parcels to pickup.
     */
    'parcels': Array<ParcelData>;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     */
    'options'?: { [key: string]: any; } | null;
}
export interface PickupResponse {
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The scheduled pickup\'s summary
     */
    'pickup'?: Pickup;
}
export interface PickupUpdateData {
    /**
     * The expected pickup date.<br/>         Date Format: YYYY-MM-DD         
     */
    'pickup_date'?: string;
    /**
     * The pickup address
     */
    'address'?: AddressData;
    /**
     * The ready time for pickup.
     */
    'ready_time'?: string | null;
    /**
     * The closing or late time of the pickup
     */
    'closing_time'?: string | null;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     */
    'tracking_numbers'?: Array<string>;
    /**
     * User metadata for the pickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * pickup identification number
     */
    'confirmation_number': string;
}
export interface PickupUpdateRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     */
    'pickup_date': string;
    /**
     * The pickup address
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     */
    'parcels': Array<Parcel>;
    /**
     * pickup identification number
     */
    'confirmation_number': string;
    /**
     * The ready time for pickup.         Time Format: `HH:MM`         
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     */
    'options'?: { [key: string]: any; } | null;
}
export interface Purolator {
    'username': string;
    'password': string;
    'account_number': string;
    'user_token'?: string | null;
    /**
     * Indicates a language string
     */
    'language'?: PurolatorLanguageEnum;
    'account_country_code'?: string | null;
}

export const PurolatorLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type PurolatorLanguageEnum = typeof PurolatorLanguageEnum[keyof typeof PurolatorLanguageEnum];

export interface Rate {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The rate\'s carrier
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     */
    'carrier_id': string;
    /**
     * The rate monetary values currency code
     */
    'currency'?: string;
    /**
     * The carrier\'s rate (quote) service
     */
    'service'?: string | null;
    /**
     * The rate\'s monetary amount of the total charge.<br/>         This is the gross amount of the rate after adding the additional charges         
     */
    'total_charge'?: number;
    /**
     * The estimated delivery transit days
     */
    'transit_days'?: number | null;
    /**
     * list of the rate\'s additional charges
     */
    'extra_charges'?: Array<Charge>;
    /**
     * The delivery estimated date
     */
    'estimated_delivery'?: string | null;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
}
export interface RateRequest {
    /**
     * The address of the party<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': AddressData;
    /**
     * The address of the party<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': AddressData;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<ParcelData>;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.         
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The list of configured carriers you wish to get rates from.
     */
    'carrier_ids'?: Array<string> | null;
}
export interface RateResponse {
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The list of returned rates
     */
    'rates': Array<Rate>;
}
export interface Roadie {
    'api_key': string;
    'account_country_code'?: string | null;
}
export interface Royalmail {
    'client_id': string;
    'client_secret': string;
    'account_country_code'?: string | null;
}
export interface Sapient {
    'client_id': string;
    'client_secret': string;
    'shipping_account_id': string;
    /**
     * Indicates a sapient_carrier_code string
     */
    'sapient_carrier_code'?: SapientSapientCarrierCodeEnum;
    'account_country_code'?: string | null;
}

export const SapientSapientCarrierCodeEnum = {
    Dx: 'DX',
    Evri: 'EVRI',
    Rm: 'RM',
    Ups: 'UPS',
    Yodel: 'YODEL'
} as const;

export type SapientSapientCarrierCodeEnum = typeof SapientSapientCarrierCodeEnum[keyof typeof SapientSapientCarrierCodeEnum];

export interface Seko {
    'access_key': string;
    'account_country_code'?: string | null;
}
export interface Sendle {
    'sendle_id': string;
    'api_key': string;
    'account_country_code'?: string | null;
}
export interface Shipengine {
    'api_key': string;
    'carrier_ids'?: string | null;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface Shipment {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     */
    'tracking_url'?: string | null;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': Address;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': Address;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     */
    'customs'?: Customs | null;
    /**
     * The list for shipment rates fetched previously
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShipmentLabelTypeEnum | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     */
    'status'?: ShipmentStatusEnum;
    /**
     * The shipment carrier
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     */
    'shipment_identifier'?: string | null;
    /**
     * The shipment selected rate
     */
    'selected_rate'?: Rate | null;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
    /**
     * The shipment label URL
     */
    'label_url'?: string | null;
    /**
     * The shipment invoice URL
     */
    'invoice_url'?: string | null;
}

export const ShipmentLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG',
    Empty: ''
} as const;

export type ShipmentLabelTypeEnum = typeof ShipmentLabelTypeEnum[keyof typeof ShipmentLabelTypeEnum];
export const ShipmentStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered',
    NeedsAttention: 'needs_attention',
    OutForDelivery: 'out_for_delivery',
    DeliveryFailed: 'delivery_failed'
} as const;

export type ShipmentStatusEnum = typeof ShipmentStatusEnum[keyof typeof ShipmentStatusEnum];

export interface ShipmentCancelRequest {
    /**
     * The shipment identifier returned during creation.
     */
    'shipment_identifier': string;
    /**
     * The selected shipment service
     */
    'service'?: string | null;
    /**
     * The shipment carrier_id for specific connection selection.
     */
    'carrier_id'?: string;
    /**
     * Advanced carrier specific cancellation options.
     */
    'options'?: { [key: string]: any; };
}
export interface ShipmentData {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShipmentDataLabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     */
    'service'?: string;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request         you could specify a service per carrier.**         
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentDataLabelTypeEnum = typeof ShipmentDataLabelTypeEnum[keyof typeof ShipmentDataLabelTypeEnum];

export interface ShipmentDataReference {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShipmentDataReferenceLabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     */
    'service'?: string;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request         you could specify a service per carrier.**         
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The shipment id.
     */
    'id'?: string;
}

export const ShipmentDataReferenceLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentDataReferenceLabelTypeEnum = typeof ShipmentDataReferenceLabelTypeEnum[keyof typeof ShipmentDataReferenceLabelTypeEnum];

export interface ShipmentPurchaseData {
    /**
     * The shipment selected rate.
     */
    'selected_rate_id': string;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShipmentPurchaseDataLabelTypeEnum;
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentPurchaseDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentPurchaseDataLabelTypeEnum = typeof ShipmentPurchaseDataLabelTypeEnum[keyof typeof ShipmentPurchaseDataLabelTypeEnum];

export interface ShipmentRateData {
    /**
     * The requested carrier service for the shipment.<br/>         Please consult [the reference](#operation/references) for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could         specify a service per carrier.**         
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
}
export interface ShipmentUpdateData {
    /**
     * The shipment label file type.
     */
    'label_type'?: ShipmentUpdateDataLabelTypeEnum;
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentUpdateDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentUpdateDataLabelTypeEnum = typeof ShipmentUpdateDataLabelTypeEnum[keyof typeof ShipmentUpdateDataLabelTypeEnum];

export interface ShippingRequest {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShippingRequestLabelTypeEnum;
    /**
     * The shipment selected rate.
     */
    'selected_rate_id': string;
    /**
     * The list for shipment rates fetched previously
     */
    'rates': Array<Rate>;
}

export const ShippingRequestLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShippingRequestLabelTypeEnum = typeof ShippingRequestLabelTypeEnum[keyof typeof ShippingRequestLabelTypeEnum];

export interface ShippingResponse {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     */
    'tracking_url'?: string | null;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'shipper': Address;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     */
    'recipient': Address;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"shipper_instructions\": \"This is a shipper instruction\",             \"recipient_instructions\": \"This is a recipient instruction\",             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     */
    'customs'?: Customs | null;
    /**
     * The list for shipment rates fetched previously
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     */
    'label_type'?: ShippingResponseLabelTypeEnum | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     */
    'status'?: ShippingResponseStatusEnum;
    /**
     * The shipment carrier
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     */
    'shipment_identifier'?: string | null;
    /**
     * The shipment selected rate
     */
    'selected_rate'?: Rate | null;
    /**
     * The shipment documents
     */
    'docs'?: Documents | null;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
}

export const ShippingResponseLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG',
    Empty: ''
} as const;

export type ShippingResponseLabelTypeEnum = typeof ShippingResponseLabelTypeEnum[keyof typeof ShippingResponseLabelTypeEnum];
export const ShippingResponseStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered',
    NeedsAttention: 'needs_attention',
    OutForDelivery: 'out_for_delivery',
    DeliveryFailed: 'delivery_failed'
} as const;

export type ShippingResponseStatusEnum = typeof ShippingResponseStatusEnum[keyof typeof ShippingResponseStatusEnum];

export interface Tge {
    'username': string;
    'password': string;
    'api_key': string;
    'toll_username': string;
    'toll_password': string;
    'my_toll_token': string;
    'my_toll_identity': string;
    'account_code'?: string | null;
    'sscc_count'?: number;
    'shipment_count'?: number;
    'account_country_code'?: string | null;
}
export interface Tnt {
    'username': string;
    'password': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface TokenObtainPair {
    'email': string;
    'password': string;
}
export interface TokenPair {
    'access': string;
    'refresh': string;
}
export interface TokenRefresh {
    'refresh': string;
    'access': string;
}
export interface TokenVerify {
    'token': string;
}
export interface TrackerDetails {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The tracking carrier
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     */
    'tracking_number': string;
    /**
     * The package and shipment tracking details
     */
    'info'?: TrackingInfo | null;
    /**
     * The tracking details events
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     */
    'status'?: TrackerDetailsStatusEnum;
    /**
     * The delivery estimated date
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The tracker documents
     */
    'images'?: Images | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
}

export const TrackerDetailsStatusEnum = {
    Pending: 'pending',
    Unknown: 'unknown',
    OnHold: 'on_hold',
    Cancelled: 'cancelled',
    Delivered: 'delivered',
    InTransit: 'in_transit',
    DeliveryDelayed: 'delivery_delayed',
    OutForDelivery: 'out_for_delivery',
    ReadyForPickup: 'ready_for_pickup',
    DeliveryFailed: 'delivery_failed',
    ReturnToSender: 'return_to_sender'
} as const;

export type TrackerDetailsStatusEnum = typeof TrackerDetailsStatusEnum[keyof typeof TrackerDetailsStatusEnum];

export interface TrackerList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<TrackingStatus>;
}
export interface TrackerUpdateData {
    /**
     * The package and shipment tracking details
     */
    'info'?: TrackingInfo | null;
    /**
     * User metadata for the tracker
     */
    'metadata'?: { [key: string]: any; };
}
export interface TrackingData {
    /**
     * The package tracking number
     */
    'tracking_number': string;
    /**
     * The tracking carrier
     */
    'carrier_name': TrackingDataCarrierNameEnum;
    /**
     * The shipper account number
     */
    'account_number'?: string | null;
    /**
     * The shipment reference
     */
    'reference'?: string | null;
    /**
     * The package and shipment tracking details
     */
    'info'?: TrackingInfo | null;
    /**
     * The carrier user metadata.
     */
    'metadata'?: { [key: string]: any; };
}

export const TrackingDataCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Fedex: 'fedex',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;

export type TrackingDataCarrierNameEnum = typeof TrackingDataCarrierNameEnum[keyof typeof TrackingDataCarrierNameEnum];

export interface TrackingEvent {
    /**
     * The tracking event\'s date. Format: `YYYY-MM-DD`
     */
    'date'?: string;
    /**
     * The tracking event\'s description
     */
    'description'?: string;
    /**
     * The tracking event\'s location
     */
    'location'?: string;
    /**
     * The tracking event\'s code
     */
    'code'?: string | null;
    /**
     * The tracking event\'s time. Format: `HH:MM AM/PM`
     */
    'time'?: string | null;
    /**
     * The tracking event\'s latitude.
     */
    'latitude'?: number | null;
    /**
     * The tracking event\'s longitude.
     */
    'longitude'?: number | null;
}
export interface TrackingInfo {
    /**
     * The carrier tracking link
     */
    'carrier_tracking_link'?: string | null;
    /**
     * The customer name
     */
    'customer_name'?: string | null;
    /**
     * The expected delivery date
     */
    'expected_delivery'?: string | null;
    /**
     * A tracking note
     */
    'note'?: string | null;
    /**
     * The package order date
     */
    'order_date'?: string | null;
    /**
     * The package order id or number
     */
    'order_id'?: string | null;
    /**
     * The package weight
     */
    'package_weight'?: string | null;
    /**
     * The package weight unit
     */
    'package_weight_unit'?: string | null;
    /**
     * The package count
     */
    'shipment_package_count'?: string | null;
    /**
     * The shipment pickup date
     */
    'shipment_pickup_date'?: string | null;
    /**
     * The shipment delivery date
     */
    'shipment_delivery_date'?: string | null;
    /**
     * The shipment service
     */
    'shipment_service'?: string | null;
    /**
     * The shipment origin country
     */
    'shipment_origin_country'?: string | null;
    /**
     * The shipment origin postal code
     */
    'shipment_origin_postal_code'?: string | null;
    /**
     * The shipment destination country
     */
    'shipment_destination_country'?: string | null;
    /**
     * The shipment destination postal code
     */
    'shipment_destination_postal_code'?: string | null;
    /**
     * The shipping date
     */
    'shipping_date'?: string | null;
    /**
     * The person who signed for the package
     */
    'signed_by'?: string | null;
    /**
     * The tracker source
     */
    'source'?: string | null;
}
export interface TrackingResponse {
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The tracking details retrieved
     */
    'tracking'?: TrackerDetails;
}
export interface TrackingStatus {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The tracking carrier
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     */
    'tracking_number': string;
    /**
     * The package and shipment tracking details
     */
    'info'?: TrackingInfo | null;
    /**
     * The tracking details events
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     */
    'status'?: TrackingStatusStatusEnum;
    /**
     * The delivery estimated date
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     */
    'messages'?: Array<Message>;
    /**
     * The shipment invoice URL
     */
    'delivery_image_url'?: string | null;
    /**
     * The shipment invoice URL
     */
    'signature_image_url'?: string | null;
}

export const TrackingStatusStatusEnum = {
    Pending: 'pending',
    Unknown: 'unknown',
    OnHold: 'on_hold',
    Cancelled: 'cancelled',
    Delivered: 'delivered',
    InTransit: 'in_transit',
    DeliveryDelayed: 'delivery_delayed',
    OutForDelivery: 'out_for_delivery',
    ReadyForPickup: 'ready_for_pickup',
    DeliveryFailed: 'delivery_failed',
    ReturnToSender: 'return_to_sender'
} as const;

export type TrackingStatusStatusEnum = typeof TrackingStatusStatusEnum[keyof typeof TrackingStatusStatusEnum];

export interface Ups {
    'client_id': string;
    'client_secret': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface Usps {
    'client_id': string;
    'client_secret': string;
    'account_number'?: string | null;
    /**
     * Indicates a account_type string
     */
    'account_type'?: UspsAccountTypeEnum;
    'manifest_MID'?: string | null;
    'CRID'?: string | null;
    'MID'?: string | null;
    'account_country_code'?: string | null;
}

export const UspsAccountTypeEnum = {
    Eps: 'EPS',
    Permit: 'PERMIT',
    Meter: 'METER'
} as const;

export type UspsAccountTypeEnum = typeof UspsAccountTypeEnum[keyof typeof UspsAccountTypeEnum];

export interface UspsInternational {
    'client_id': string;
    'client_secret': string;
    'account_number'?: string | null;
    /**
     * Indicates a account_type string
     */
    'account_type'?: UspsInternationalAccountTypeEnum;
    'manifest_MID'?: string | null;
    'CRID'?: string | null;
    'MID'?: string | null;
    'account_country_code'?: string | null;
}

export const UspsInternationalAccountTypeEnum = {
    Eps: 'EPS',
    Permit: 'PERMIT',
    Meter: 'METER'
} as const;

export type UspsInternationalAccountTypeEnum = typeof UspsInternationalAccountTypeEnum[keyof typeof UspsInternationalAccountTypeEnum];

export interface Veho {
    'api_key': string;
    'account_number'?: string | null;
    'account_country_code'?: string | null;
}
export interface VerifiedTokenObtainPair {
    'refresh': string;
    'access': string;
    /**
     * The OTP (One Time Password) token received by the user from the         configured Two Factor Authentication method.         
     */
    'otp_token': string;
}
export interface Webhook {
    /**
     * A unique identifier
     */
    'id'?: string;
    /**
     * The URL of the webhook endpoint.
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     */
    'enabled_events': Array<WebhookEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     */
    'disabled'?: boolean | null;
    /**
     * Specifies the object type
     */
    'object_type'?: string;
    /**
     * The datetime of the last event sent.
     */
    'last_event_at'?: string | null;
    /**
     * Header signature secret
     */
    'secret': string;
    /**
     * Specified whether it was created with a carrier in test mode
     */
    'test_mode': boolean;
}

export const WebhookEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookEnabledEventsEnum = typeof WebhookEnabledEventsEnum[keyof typeof WebhookEnabledEventsEnum];

export interface WebhookData {
    /**
     * The URL of the webhook endpoint.
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     */
    'enabled_events': Array<WebhookDataEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     */
    'disabled'?: boolean | null;
}

export const WebhookDataEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookDataEnabledEventsEnum = typeof WebhookDataEnabledEventsEnum[keyof typeof WebhookDataEnabledEventsEnum];

export interface WebhookList {
    'count'?: number | null;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Webhook>;
}
export interface WebhookTestRequest {
    'payload': { [key: string]: any; };
}
export interface Zoom2u {
    'api_key': string;
    'account_country_code'?: string | null;
}

/**
 * APIApi - axios parameter creator
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async data(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.data(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.data']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIApi - factory interface
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.data(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 */
export class APIApi extends BaseAPI {
    /**
     * 
     * @summary Data References
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public data(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).data(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instance Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ping(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressesApi - axios parameter creator
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (addressData: AddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressData' is not null or undefined
            assertParamExists('create', 'addressData', addressData)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedAddressData?: PatchedAddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAddressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(addressData: AddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(addressData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedAddressData?: PatchedAddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedAddressData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressesApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.create(requestParameters.addressData, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<AddressList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedAddressData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in AddressesApi.
 */
export interface AddressesApiCreateRequest {
    readonly addressData: AddressData
}

/**
 * Request parameters for discard operation in AddressesApi.
 */
export interface AddressesApiDiscardRequest {
    readonly id: string
}

/**
 * Request parameters for retrieve operation in AddressesApi.
 */
export interface AddressesApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in AddressesApi.
 */
export interface AddressesApiUpdateRequest {
    readonly id: string

    readonly patchedAddressData?: PatchedAddressData
}

/**
 * AddressesApi - object-oriented interface
 */
export class AddressesApi extends BaseAPI {
    /**
     * Create a new address.
     * @summary Create an address
     * @param {AddressesApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).create(requestParameters.addressData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard an address.
     * @summary Discard an address
     * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all addresses.
     * @summary List all addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Retrieve an address
     * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an address.
     * @summary Update an address
     * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedAddressData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (tokenObtainPair: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('authenticate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken: async (verifiedTokenObtainPair: VerifiedTokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifiedTokenObtainPair' is not null or undefined
            assertParamExists('getVerifiedToken', 'verifiedTokenObtainPair', verifiedTokenObtainPair)
            const localVarPath = `/api/token/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifiedTokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (tokenRefresh: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('refreshToken', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken: async (tokenVerify: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('verifyToken', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(tokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedToken(verifiedTokenObtainPair: VerifiedTokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerifiedToken(verifiedTokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getVerifiedToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyToken(tokenVerify: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(tokenVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {AuthApiAuthenticateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(requestParameters: AuthApiAuthenticateRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.authenticate(requestParameters.tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {AuthApiGetVerifiedTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken(requestParameters: AuthApiGetVerifiedTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.getVerifiedToken(requestParameters.verifiedTokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.refreshToken(requestParameters.tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {AuthApiVerifyTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken(requestParameters: AuthApiVerifyTokenRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.verifyToken(requestParameters.tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticate operation in AuthApi.
 */
export interface AuthApiAuthenticateRequest {
    readonly tokenObtainPair: TokenObtainPair
}

/**
 * Request parameters for getVerifiedToken operation in AuthApi.
 */
export interface AuthApiGetVerifiedTokenRequest {
    readonly verifiedTokenObtainPair: VerifiedTokenObtainPair
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 */
export interface AuthApiRefreshTokenRequest {
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for verifyToken operation in AuthApi.
 */
export interface AuthApiVerifyTokenRequest {
    readonly tokenVerify: TokenVerify
}

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate the user and return a token pair
     * @summary Obtain auth token pair
     * @param {AuthApiAuthenticateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authenticate(requestParameters: AuthApiAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticate(requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a verified JWT token pair by submitting a Two-Factor authentication code.
     * @summary Get verified JWT token
     * @param {AuthApiGetVerifiedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVerifiedToken(requestParameters: AuthApiGetVerifiedTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getVerifiedToken(requestParameters.verifiedTokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate the user and return a token pair
     * @summary Refresh auth token
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify an existent authentication token
     * @summary Verify token
     * @param {AuthApiVerifyTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyToken(requestParameters: AuthApiVerifyTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyToken(requestParameters.tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BatchesApi - axios parameter creator
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders: async (batchOrderData: BatchOrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrderData' is not null or undefined
            assertParamExists('createOrders', 'batchOrderData', batchOrderData)
            const localVarPath = `/v1/batches/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchOrderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments: async (batchShipmentData: BatchShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchShipmentData' is not null or undefined
            assertParamExists('createShipments', 'batchShipmentData', batchShipmentData)
            const localVarPath = `/v1/batches/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchShipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers: async (batchTrackerData: BatchTrackerData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchTrackerData' is not null or undefined
            assertParamExists('createTrackers', 'batchTrackerData', batchTrackerData)
            const localVarPath = `/v1/batches/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTrackerData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {ImportFileResourceTypeEnum} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (dataFile?: File, dataTemplate?: string, resourceType?: ImportFileResourceTypeEnum, resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/data/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataFile !== undefined) {
                localVarQueryParameter['data_file'] = dataFile;
            }

            if (dataTemplate !== undefined) {
                localVarQueryParameter['data_template'] = dataTemplate;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }


            if (resourceType2 !== undefined) { 
                localVarFormParams.append('resource_type', resourceType2 as any);
            }
    
            if (dataTemplate2 !== undefined) { 
                localVarFormParams.append('data_template', dataTemplate2 as any);
            }
    
            if (dataFile2 !== undefined) { 
                localVarFormParams.append('data_file', dataFile2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/batches/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrders(batchOrderData: BatchOrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrders(batchOrderData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipments(batchShipmentData: BatchShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipments(batchShipmentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createShipments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackers(batchTrackerData: BatchTrackerData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackers(batchTrackerData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createTrackers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {ImportFileResourceTypeEnum} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(dataFile?: File, dataTemplate?: string, resourceType?: ImportFileResourceTypeEnum, resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(dataFile, dataTemplate, resourceType, resourceType2, dataTemplate2, dataFile2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.importFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchesApiCreateOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders(requestParameters: BatchesApiCreateOrdersRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createOrders(requestParameters.batchOrderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchesApiCreateShipmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(requestParameters: BatchesApiCreateShipmentsRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createShipments(requestParameters.batchShipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchesApiCreateTrackersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers(requestParameters: BatchesApiCreateTrackersRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createTrackers(requestParameters.batchTrackerData, options).then((request) => request(axios, basePath));
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {BatchesApiImportFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(requestParameters: BatchesApiImportFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.importFile(requestParameters.dataFile, requestParameters.dataTemplate, requestParameters.resourceType, requestParameters.resourceType2, requestParameters.dataTemplate2, requestParameters.dataFile2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<BatchOperations> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOrders operation in BatchesApi.
 */
export interface BatchesApiCreateOrdersRequest {
    readonly batchOrderData: BatchOrderData
}

/**
 * Request parameters for createShipments operation in BatchesApi.
 */
export interface BatchesApiCreateShipmentsRequest {
    readonly batchShipmentData: BatchShipmentData
}

/**
 * Request parameters for createTrackers operation in BatchesApi.
 */
export interface BatchesApiCreateTrackersRequest {
    readonly batchTrackerData: BatchTrackerData
}

/**
 * Request parameters for importFile operation in BatchesApi.
 */
export interface BatchesApiImportFileRequest {
    readonly dataFile?: File

    /**
     * A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
     */
    readonly dataTemplate?: string

    /**
     * The type of the resource to import
     */
    readonly resourceType?: ImportFileResourceTypeEnum

    readonly resourceType2?: string

    readonly dataTemplate2?: string

    readonly dataFile2?: File
}

/**
 * Request parameters for retrieve operation in BatchesApi.
 */
export interface BatchesApiRetrieveRequest {
    readonly id: string
}

/**
 * BatchesApi - object-oriented interface
 */
export class BatchesApi extends BaseAPI {
    /**
     * Create order batch. `Beta`
     * @summary Create order batch
     * @param {BatchesApiCreateOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrders(requestParameters: BatchesApiCreateOrdersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createOrders(requestParameters.batchOrderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create shipment batch. `Beta`
     * @summary Create shipment batch
     * @param {BatchesApiCreateShipmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createShipments(requestParameters: BatchesApiCreateShipmentsRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createShipments(requestParameters.batchShipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create tracker batch. `Beta`
     * @summary Create tracker batch
     * @param {BatchesApiCreateTrackersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTrackers(requestParameters: BatchesApiCreateTrackersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createTrackers(requestParameters.batchTrackerData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
     * @summary Import data files
     * @param {BatchesApiImportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public importFile(requestParameters: BatchesApiImportFileRequest = {}, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).importFile(requestParameters.dataFile, requestParameters.dataTemplate, requestParameters.resourceType, requestParameters.resourceType2, requestParameters.dataTemplate2, requestParameters.dataFile2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all batch operations. `Beta`
     * @summary List all batch operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a batch operation. `Beta`
     * @summary Retrieve a batch operation
     * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ImportFileResourceTypeEnum = {
    Billing: 'billing',
    Order: 'order',
    Shipment: 'shipment',
    Trackers: 'trackers'
} as const;
export type ImportFileResourceTypeEnum = typeof ImportFileResourceTypeEnum[keyof typeof ImportFileResourceTypeEnum];


/**
 * CarriersApi - axios parameter creator
 */
export const CarriersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a carrier\'s details
         * @summary Get carrier details
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: async (carrierName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getDetails', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a carrier\'s options
         * @summary Get carrier options
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptions: async (carrierName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getOptions', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}/options`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (carrierName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getServices', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}/services`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarriersApi - functional programming interface
 */
export const CarriersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a carrier\'s details
         * @summary Get carrier details
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetails(carrierName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetails(carrierName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.getDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a carrier\'s options
         * @summary Get carrier options
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptions(carrierName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptions(carrierName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.getOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(carrierName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(carrierName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.getServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarrierDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CarriersApi - factory interface
 */
export const CarriersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarriersApiFp(configuration)
    return {
        /**
         * Retrieve a carrier\'s details
         * @summary Get carrier details
         * @param {CarriersApiGetDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(requestParameters: CarriersApiGetDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierDetails> {
            return localVarFp.getDetails(requestParameters.carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a carrier\'s options
         * @summary Get carrier options
         * @param {CarriersApiGetOptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptions(requestParameters: CarriersApiGetOptionsRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getOptions(requestParameters.carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getServices(requestParameters.carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<Array<CarrierDetails>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDetails operation in CarriersApi.
 */
export interface CarriersApiGetDetailsRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName: string
}

/**
 * Request parameters for getOptions operation in CarriersApi.
 */
export interface CarriersApiGetOptionsRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName: string
}

/**
 * Request parameters for getServices operation in CarriersApi.
 */
export interface CarriersApiGetServicesRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName: string
}

/**
 * CarriersApi - object-oriented interface
 */
export class CarriersApi extends BaseAPI {
    /**
     * Retrieve a carrier\'s details
     * @summary Get carrier details
     * @param {CarriersApiGetDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDetails(requestParameters: CarriersApiGetDetailsRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getDetails(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a carrier\'s options
     * @summary Get carrier options
     * @param {CarriersApiGetOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOptions(requestParameters: CarriersApiGetOptionsRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getOptions(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a carrier\'s services
     * @summary Get carrier services
     * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getServices(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of configured carriers
     * @summary List all carriers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectionsApi - axios parameter creator
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {CarrierConnectionData} carrierConnectionData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (carrierConnectionData: CarrierConnectionData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierConnectionData' is not null or undefined
            assertParamExists('add', 'carrierConnectionData', carrierConnectionData)
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(carrierConnectionData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {boolean} [active] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (active?: boolean, carrierName?: string, metadataKey?: string, metadataValue?: string, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['system_only'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {string} id 
         * @param {PatchedCarrierConnectionData} [patchedCarrierConnectionData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedCarrierConnectionData?: PatchedCarrierConnectionData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCarrierConnectionData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {CarrierConnectionData} carrierConnectionData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(carrierConnectionData: CarrierConnectionData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(carrierConnectionData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.add']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {boolean} [active] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(active?: boolean, carrierName?: string, metadataKey?: string, metadataValue?: string, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(active, carrierName, metadataKey, metadataValue, systemOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {string} id 
         * @param {PatchedCarrierConnectionData} [patchedCarrierConnectionData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedCarrierConnectionData?: PatchedCarrierConnectionData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedCarrierConnectionData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {ConnectionsApiAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(requestParameters: ConnectionsApiAddRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.add(requestParameters.carrierConnectionData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {ConnectionsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ConnectionsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CarrierConnectionList> {
            return localVarFp.list(requestParameters.active, requestParameters.carrierName, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.systemOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {ConnectionsApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: ConnectionsApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.remove(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {ConnectionsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ConnectionsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {ConnectionsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ConnectionsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedCarrierConnectionData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for add operation in ConnectionsApi.
 */
export interface ConnectionsApiAddRequest {
    readonly carrierConnectionData: CarrierConnectionData
}

/**
 * Request parameters for list operation in ConnectionsApi.
 */
export interface ConnectionsApiListRequest {
    readonly active?: boolean

    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName?: string

    readonly metadataKey?: string

    readonly metadataValue?: string

    readonly systemOnly?: boolean
}

/**
 * Request parameters for remove operation in ConnectionsApi.
 */
export interface ConnectionsApiRemoveRequest {
    readonly id: string
}

/**
 * Request parameters for retrieve operation in ConnectionsApi.
 */
export interface ConnectionsApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in ConnectionsApi.
 */
export interface ConnectionsApiUpdateRequest {
    readonly id: string

    readonly patchedCarrierConnectionData?: PatchedCarrierConnectionData
}

/**
 * ConnectionsApi - object-oriented interface
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * Add a new carrier connection.
     * @summary Add a carrier connection
     * @param {ConnectionsApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public add(requestParameters: ConnectionsApiAddRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).add(requestParameters.carrierConnectionData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all carrier connections
     * @summary List carrier connections
     * @param {ConnectionsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: ConnectionsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).list(requestParameters.active, requestParameters.carrierName, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.systemOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a carrier connection.
     * @summary Remove a carrier connection
     * @param {ConnectionsApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public remove(requestParameters: ConnectionsApiRemoveRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve carrier connection.
     * @summary Retrieve a connection
     * @param {ConnectionsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: ConnectionsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a carrier connection.
     * @summary Update a connection
     * @param {ConnectionsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: ConnectionsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedCarrierConnectionData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentTemplateData} documentTemplateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (documentTemplateData: DocumentTemplateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentTemplateData' is not null or undefined
            assertParamExists('create', 'documentTemplateData', documentTemplateData)
            const localVarPath = `/v1/documents/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentTemplateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentData} [documentData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDocument: async (documentData?: DocumentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpload: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUpload', 'id', id)
            const localVarPath = `/v1/documents/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {string} id 
         * @param {PatchedDocumentTemplateData} [patchedDocumentTemplateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedDocumentTemplateData?: PatchedDocumentTemplateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDocumentTemplateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (documentUploadData: DocumentUploadData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentUploadData' is not null or undefined
            assertParamExists('upload', 'documentUploadData', documentUploadData)
            const localVarPath = `/v1/documents/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUploadData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [shipmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploads: async (createdAfter?: string, createdBefore?: string, shipmentId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipment_id'] = shipmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentTemplateData} documentTemplateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(documentTemplateData: DocumentTemplateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(documentTemplateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentData} [documentData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateDocument(documentData?: DocumentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneratedDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateDocument(documentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.generateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpload(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpload(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.retrieveUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {string} id 
         * @param {PatchedDocumentTemplateData} [patchedDocumentTemplateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedDocumentTemplateData?: PatchedDocumentTemplateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedDocumentTemplateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(documentUploadData: DocumentUploadData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(documentUploadData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.upload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [shipmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploads(createdAfter?: string, createdBefore?: string, shipmentId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecords>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploads(createdAfter, createdBefore, shipmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: DocumentsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.create(requestParameters.documentTemplateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {DocumentsApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: DocumentsApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentsApiGenerateDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDocument(requestParameters: DocumentsApiGenerateDocumentRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GeneratedDocument> {
            return localVarFp.generateDocument(requestParameters.documentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<DocumentTemplateList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {DocumentsApiRetrieveUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpload(requestParameters: DocumentsApiRetrieveUploadRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.retrieveUpload(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {DocumentsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: DocumentsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedDocumentTemplateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.upload(requestParameters.documentUploadData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {DocumentsApiUploadsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploads(requestParameters: DocumentsApiUploadsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecords> {
            return localVarFp.uploads(requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.shipmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in DocumentsApi.
 */
export interface DocumentsApiCreateRequest {
    readonly documentTemplateData: DocumentTemplateData
}

/**
 * Request parameters for discard operation in DocumentsApi.
 */
export interface DocumentsApiDiscardRequest {
    readonly id: string
}

/**
 * Request parameters for generateDocument operation in DocumentsApi.
 */
export interface DocumentsApiGenerateDocumentRequest {
    readonly documentData?: DocumentData
}

/**
 * Request parameters for retrieve operation in DocumentsApi.
 */
export interface DocumentsApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for retrieveUpload operation in DocumentsApi.
 */
export interface DocumentsApiRetrieveUploadRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in DocumentsApi.
 */
export interface DocumentsApiUpdateRequest {
    readonly id: string

    readonly patchedDocumentTemplateData?: PatchedDocumentTemplateData
}

/**
 * Request parameters for upload operation in DocumentsApi.
 */
export interface DocumentsApiUploadRequest {
    readonly documentUploadData: DocumentUploadData
}

/**
 * Request parameters for uploads operation in DocumentsApi.
 */
export interface DocumentsApiUploadsRequest {
    readonly createdAfter?: string

    readonly createdBefore?: string

    readonly shipmentId?: string
}

/**
 * DocumentsApi - object-oriented interface
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Create a new template.
     * @summary Create a template
     * @param {DocumentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: DocumentsApiCreateRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).create(requestParameters.documentTemplateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a template.
     * @summary Delete a template
     * @param {DocumentsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public discard(requestParameters: DocumentsApiDiscardRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
     * @summary Generate a document
     * @param {DocumentsApiGenerateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateDocument(requestParameters: DocumentsApiGenerateDocumentRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).generateDocument(requestParameters.documentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all templates.
     * @summary List all templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a template.
     * @summary Retrieve a template
     * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping document upload record.
     * @summary Retrieve upload record
     * @param {DocumentsApiRetrieveUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveUpload(requestParameters: DocumentsApiRetrieveUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieveUpload(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a template.
     * @summary Update a template
     * @param {DocumentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: DocumentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedDocumentTemplateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a shipping document.
     * @summary Upload documents
     * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).upload(requestParameters.documentUploadData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipping document upload records.
     * @summary List all upload records
     * @param {DocumentsApiUploadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploads(requestParameters: DocumentsApiUploadsRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploads(requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManifestsApi - axios parameter creator
 */
export const ManifestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestData} manifestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (manifestData: ManifestData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manifestData' is not null or undefined
            assertParamExists('create', 'manifestData', manifestData)
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName?: string, createdAfter?: string, createdBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/manifests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestsApi - functional programming interface
 */
export const ManifestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManifestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestData} manifestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(manifestData: ManifestData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(manifestData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName?: string, createdAfter?: string, createdBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, createdAfter, createdBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManifestsApi - factory interface
 */
export const ManifestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManifestsApiFp(configuration)
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ManifestsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.create(requestParameters.manifestData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {ManifestsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ManifestsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ManifestList> {
            return localVarFp.list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {ManifestsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ManifestsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ManifestsApi.
 */
export interface ManifestsApiCreateRequest {
    readonly manifestData: ManifestData
}

/**
 * Request parameters for list operation in ManifestsApi.
 */
export interface ManifestsApiListRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName?: string

    readonly createdAfter?: string

    readonly createdBefore?: string
}

/**
 * Request parameters for retrieve operation in ManifestsApi.
 */
export interface ManifestsApiRetrieveRequest {
    readonly id: string
}

/**
 * ManifestsApi - object-oriented interface
 */
export class ManifestsApi extends BaseAPI {
    /**
     * Create a manifest for one or many shipments with labels already purchased.
     * @summary Create a manifest
     * @param {ManifestsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: ManifestsApiCreateRequest, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).create(requestParameters.manifestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all manifests.
     * @summary List manifests
     * @param {ManifestsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: ManifestsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping manifest.
     * @summary Retrieve a manifest
     * @param {ManifestsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: ManifestsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (orderData: OrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderData' is not null or undefined
            assertParamExists('create', 'orderData', orderData)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        dismiss: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dismiss', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, orderUpdateData?: OrderUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(orderData: OrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(orderData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async dismiss(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dismiss(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.dismiss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, orderUpdateData?: OrderUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, orderUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {OrdersApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.cancel(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrdersApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.create(requestParameters.orderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {OrdersApiDismissRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        dismiss(requestParameters: OrdersApiDismissRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.dismiss(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<OrderList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.update(requestParameters.id, requestParameters.orderUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in OrdersApi.
 */
export interface OrdersApiCancelRequest {
    readonly id: string
}

/**
 * Request parameters for create operation in OrdersApi.
 */
export interface OrdersApiCreateRequest {
    readonly orderData: OrderData
}

/**
 * Request parameters for dismiss operation in OrdersApi.
 */
export interface OrdersApiDismissRequest {
    readonly id: string
}

/**
 * Request parameters for retrieve operation in OrdersApi.
 */
export interface OrdersApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in OrdersApi.
 */
export interface OrdersApiUpdateRequest {
    readonly id: string

    readonly orderUpdateData?: OrderUpdateData
}

/**
 * OrdersApi - object-oriented interface
 */
export class OrdersApi extends BaseAPI {
    /**
     * Cancel an order.
     * @summary Cancel an order
     * @param {OrdersApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order object.
     * @summary Create an order
     * @param {OrdersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).create(requestParameters.orderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss an order from fulfillment.
     * @summary Dismiss an order
     * @param {OrdersApiDismissRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public dismiss(requestParameters: OrdersApiDismissRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).dismiss(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders.
     * @summary List all orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an order.
     * @summary Retrieve an order
     * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
     * @summary Update an order
     * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).update(requestParameters.id, requestParameters.orderUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParcelsApi - axios parameter creator
 */
export const ParcelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (parcelData: ParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parcelData' is not null or undefined
            assertParamExists('create', 'parcelData', parcelData)
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedParcelData?: PatchedParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedParcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParcelsApi - functional programming interface
 */
export const ParcelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParcelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(parcelData: ParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(parcelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedParcelData?: PatchedParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedParcelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParcelsApi - factory interface
 */
export const ParcelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParcelsApiFp(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.create(requestParameters.parcelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<ParcelList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedParcelData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ParcelsApi.
 */
export interface ParcelsApiCreateRequest {
    readonly parcelData: ParcelData
}

/**
 * Request parameters for discard operation in ParcelsApi.
 */
export interface ParcelsApiDiscardRequest {
    readonly id: string
}

/**
 * Request parameters for retrieve operation in ParcelsApi.
 */
export interface ParcelsApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in ParcelsApi.
 */
export interface ParcelsApiUpdateRequest {
    readonly id: string

    readonly patchedParcelData?: PatchedParcelData
}

/**
 * ParcelsApi - object-oriented interface
 */
export class ParcelsApi extends BaseAPI {
    /**
     * Create a new parcel.
     * @summary Create a parcel
     * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).create(requestParameters.parcelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a parcel.
     * @summary Remove a parcel
     * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored parcels.
     * @summary List all parcels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a parcel.
     * @summary Retrieve a parcel
     * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing parcel\'s details.
     * @summary Update a parcel
     * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedParcelData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PickupsApi - axios parameter creator
 */
export const PickupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, pickupCancelData?: PickupCancelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/pickups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule: async (carrierName: string, pickupData: PickupData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedule', 'carrierName', carrierName)
            // verify required parameter 'pickupData' is not null or undefined
            assertParamExists('schedule', 'pickupData', pickupData)
            const localVarPath = `/v1/pickups/{carrier_name}/schedule`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, pickupUpdateData: PickupUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'pickupUpdateData' is not null or undefined
            assertParamExists('update', 'pickupUpdateData', pickupUpdateData)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PickupsApi - functional programming interface
 */
export const PickupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PickupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, pickupCancelData?: PickupCancelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, pickupCancelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedule(carrierName: string, pickupData: PickupData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedule(carrierName, pickupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.schedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, pickupUpdateData: PickupUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, pickupUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PickupsApi - factory interface
 */
export const PickupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PickupsApiFp(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {PickupsApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.cancel(requestParameters.id, requestParameters.pickupCancelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<PickupList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.schedule(requestParameters.carrierName, requestParameters.pickupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.update(requestParameters.id, requestParameters.pickupUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in PickupsApi.
 */
export interface PickupsApiCancelRequest {
    readonly id: string

    readonly pickupCancelData?: PickupCancelData
}

/**
 * Request parameters for retrieve operation in PickupsApi.
 */
export interface PickupsApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for schedule operation in PickupsApi.
 */
export interface PickupsApiScheduleRequest {
    readonly carrierName: string

    readonly pickupData: PickupData
}

/**
 * Request parameters for update operation in PickupsApi.
 */
export interface PickupsApiUpdateRequest {
    readonly id: string

    readonly pickupUpdateData: PickupUpdateData
}

/**
 * PickupsApi - object-oriented interface
 */
export class PickupsApi extends BaseAPI {
    /**
     * Cancel a pickup of one or more shipments.
     * @summary Cancel a pickup
     * @param {PickupsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).cancel(requestParameters.id, requestParameters.pickupCancelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scheduled pickups.
     * @summary List shipment pickups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a scheduled pickup.
     * @summary Retrieve a pickup
     * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a pickup for one or many shipments with labels already purchased.
     * @summary Schedule a pickup
     * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).schedule(requestParameters.carrierName, requestParameters.pickupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a pickup for one or many shipments with labels already purchased.
     * @summary Update a pickup
     * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).update(requestParameters.id, requestParameters.pickupUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProxyApi - axios parameter creator
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel: async (shippingRequest: ShippingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingRequest' is not null or undefined
            assertParamExists('buyLabel', 'shippingRequest', shippingRequest)
            const localVarPath = `/v1/proxy/shipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {CancelPickupCarrierNameEnum} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup: async (carrierName: CancelPickupCarrierNameEnum, pickupCancelRequest: PickupCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('cancelPickup', 'carrierName', carrierName)
            // verify required parameter 'pickupCancelRequest' is not null or undefined
            assertParamExists('cancelPickup', 'pickupCancelRequest', pickupCancelRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates: async (rateRequest: RateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateRequest' is not null or undefined
            assertParamExists('fetchRates', 'rateRequest', rateRequest)
            const localVarPath = `/v1/proxy/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ManifestRequest} manifestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateManifest: async (manifestRequest: ManifestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manifestRequest' is not null or undefined
            assertParamExists('generateManifest', 'manifestRequest', manifestRequest)
            const localVarPath = `/v1/proxy/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking: async (trackingData: TrackingData, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('getTracking', 'trackingData', trackingData)
            const localVarPath = `/v1/proxy/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {SchedulePickupCarrierNameEnum} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (carrierName: SchedulePickupCarrierNameEnum, pickupRequest: PickupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedulePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupRequest' is not null or undefined
            assertParamExists('schedulePickup', 'pickupRequest', pickupRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {TrackShipmentCarrierNameEnum} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment: async (carrierName: TrackShipmentCarrierNameEnum, trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('trackShipment', 'carrierName', carrierName)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('trackShipment', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/proxy/tracking/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {UpdatePickupCarrierNameEnum} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup: async (carrierName: UpdatePickupCarrierNameEnum, pickupUpdateRequest: PickupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updatePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupUpdateRequest' is not null or undefined
            assertParamExists('updatePickup', 'pickupUpdateRequest', pickupUpdateRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/update`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {VoidLabelCarrierNameEnum} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (carrierName: VoidLabelCarrierNameEnum, shipmentCancelRequest: ShipmentCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('voidLabel', 'carrierName', carrierName)
            // verify required parameter 'shipmentCancelRequest' is not null or undefined
            assertParamExists('voidLabel', 'shipmentCancelRequest', shipmentCancelRequest)
            const localVarPath = `/v1/proxy/shipping/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buyLabel(shippingRequest: ShippingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buyLabel(shippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.buyLabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {CancelPickupCarrierNameEnum} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPickup(carrierName: CancelPickupCarrierNameEnum, pickupCancelRequest: PickupCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPickup(carrierName, pickupCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.cancelPickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRates(rateRequest: RateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRates(rateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.fetchRates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ManifestRequest} manifestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateManifest(manifestRequest: ManifestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateManifest(manifestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.generateManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTracking(trackingData: TrackingData, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTracking(trackingData, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.getTracking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {SchedulePickupCarrierNameEnum} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(carrierName: SchedulePickupCarrierNameEnum, pickupRequest: PickupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(carrierName, pickupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.schedulePickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {TrackShipmentCarrierNameEnum} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async trackShipment(carrierName: TrackShipmentCarrierNameEnum, trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackShipment(carrierName, trackingNumber, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.trackShipment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {UpdatePickupCarrierNameEnum} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePickup(carrierName: UpdatePickupCarrierNameEnum, pickupUpdateRequest: PickupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePickup(carrierName, pickupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.updatePickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {VoidLabelCarrierNameEnum} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(carrierName: VoidLabelCarrierNameEnum, shipmentCancelRequest: ShipmentCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(carrierName, shipmentCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.voidLabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProxyApi - factory interface
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig): AxiosPromise<ShippingResponse> {
            return localVarFp.buyLabel(requestParameters.shippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.cancelPickup(requestParameters.carrierName, requestParameters.pickupCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig): AxiosPromise<RateResponse> {
            return localVarFp.fetchRates(requestParameters.rateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ProxyApiGenerateManifestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateManifest(requestParameters: ProxyApiGenerateManifestRequest, options?: AxiosRequestConfig): AxiosPromise<ManifestResponse> {
            return localVarFp.generateManifest(requestParameters.manifestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {ProxyApiGetTrackingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking(requestParameters: ProxyApiGetTrackingRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingResponse> {
            return localVarFp.getTracking(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig): AxiosPromise<PickupResponse> {
            return localVarFp.schedulePickup(requestParameters.carrierName, requestParameters.pickupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingResponse> {
            return localVarFp.trackShipment(requestParameters.carrierName, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig): AxiosPromise<PickupResponse> {
            return localVarFp.updatePickup(requestParameters.carrierName, requestParameters.pickupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.voidLabel(requestParameters.carrierName, requestParameters.shipmentCancelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for buyLabel operation in ProxyApi.
 */
export interface ProxyApiBuyLabelRequest {
    readonly shippingRequest: ShippingRequest
}

/**
 * Request parameters for cancelPickup operation in ProxyApi.
 */
export interface ProxyApiCancelPickupRequest {
    readonly carrierName: CancelPickupCarrierNameEnum

    readonly pickupCancelRequest: PickupCancelRequest
}

/**
 * Request parameters for fetchRates operation in ProxyApi.
 */
export interface ProxyApiFetchRatesRequest {
    readonly rateRequest: RateRequest
}

/**
 * Request parameters for generateManifest operation in ProxyApi.
 */
export interface ProxyApiGenerateManifestRequest {
    readonly manifestRequest: ManifestRequest
}

/**
 * Request parameters for getTracking operation in ProxyApi.
 */
export interface ProxyApiGetTrackingRequest {
    readonly trackingData: TrackingData

    readonly hub?: string
}

/**
 * Request parameters for schedulePickup operation in ProxyApi.
 */
export interface ProxyApiSchedulePickupRequest {
    readonly carrierName: SchedulePickupCarrierNameEnum

    readonly pickupRequest: PickupRequest
}

/**
 * Request parameters for trackShipment operation in ProxyApi.
 */
export interface ProxyApiTrackShipmentRequest {
    readonly carrierName: TrackShipmentCarrierNameEnum

    readonly trackingNumber: string

    readonly hub?: string
}

/**
 * Request parameters for updatePickup operation in ProxyApi.
 */
export interface ProxyApiUpdatePickupRequest {
    readonly carrierName: UpdatePickupCarrierNameEnum

    readonly pickupUpdateRequest: PickupUpdateRequest
}

/**
 * Request parameters for voidLabel operation in ProxyApi.
 */
export interface ProxyApiVoidLabelRequest {
    readonly carrierName: VoidLabelCarrierNameEnum

    readonly shipmentCancelRequest: ShipmentCancelRequest
}

/**
 * ProxyApi - object-oriented interface
 */
export class ProxyApi extends BaseAPI {
    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * @summary Buy a shipment label
     * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).buyLabel(requestParameters.shippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a pickup previously scheduled
     * @summary Cancel a pickup
     * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).cancelPickup(requestParameters.carrierName, requestParameters.pickupCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * @summary Fetch shipment rates
     * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).fetchRates(requestParameters.rateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
     * @summary Create a manifest
     * @param {ProxyApiGenerateManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateManifest(requestParameters: ProxyApiGenerateManifestRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).generateManifest(requestParameters.manifestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Get tracking details
     * @param {ProxyApiGetTrackingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTracking(requestParameters: ProxyApiGetTrackingRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).getTracking(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule one or many parcels pickup
     * @summary Schedule a pickup
     * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).schedulePickup(requestParameters.carrierName, requestParameters.pickupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Track a shipment
     * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).trackShipment(requestParameters.carrierName, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a scheduled pickup
     * @summary Update a pickup
     * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).updatePickup(requestParameters.carrierName, requestParameters.pickupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a shipment and the label previously created
     * @summary Void a shipment label
     * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).voidLabel(requestParameters.carrierName, requestParameters.shipmentCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CancelPickupCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type CancelPickupCarrierNameEnum = typeof CancelPickupCarrierNameEnum[keyof typeof CancelPickupCarrierNameEnum];
export const SchedulePickupCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type SchedulePickupCarrierNameEnum = typeof SchedulePickupCarrierNameEnum[keyof typeof SchedulePickupCarrierNameEnum];
export const TrackShipmentCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Fedex: 'fedex',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type TrackShipmentCarrierNameEnum = typeof TrackShipmentCarrierNameEnum[keyof typeof TrackShipmentCarrierNameEnum];
export const UpdatePickupCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type UpdatePickupCarrierNameEnum = typeof UpdatePickupCarrierNameEnum[keyof typeof UpdatePickupCarrierNameEnum];
export const VoidLabelCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Shipengine: 'shipengine',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type VoidLabelCarrierNameEnum = typeof VoidLabelCarrierNameEnum[keyof typeof VoidLabelCarrierNameEnum];


/**
 * ShipmentsApi - axios parameter creator
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/shipments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (shipmentData: ShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentData' is not null or undefined
            assertParamExists('create', 'shipmentData', shipmentData)
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {boolean} [hasManifest] 
         * @param {boolean} [hasTracker] 
         * @param {string} [id] 
         * @param {string} [keyword] 
         * @param {string} [metaKey] 
         * @param {string} [metaValue] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {string} [status] Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (address?: string, carrierName?: string, createdAfter?: string, createdBefore?: string, hasManifest?: boolean, hasTracker?: boolean, id?: string, keyword?: string, metaKey?: string, metaValue?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: string, trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (hasManifest !== undefined) {
                localVarQueryParameter['has_manifest'] = hasManifest;
            }

            if (hasTracker !== undefined) {
                localVarQueryParameter['has_tracker'] = hasTracker;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (metaKey !== undefined) {
                localVarQueryParameter['meta_key'] = metaKey;
            }

            if (metaValue !== undefined) {
                localVarQueryParameter['meta_value'] = metaValue;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (optionKey !== undefined) {
                localVarQueryParameter['option_key'] = optionKey;
            }

            if (optionValue !== undefined) {
                localVarQueryParameter['option_value'] = optionValue;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (id: string, shipmentPurchaseData: ShipmentPurchaseData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchase', 'id', id)
            // verify required parameter 'shipmentPurchaseData' is not null or undefined
            assertParamExists('purchase', 'shipmentPurchaseData', shipmentPurchaseData)
            const localVarPath = `/v1/shipments/{id}/purchase`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentPurchaseData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates: async (id: string, shipmentRateData?: ShipmentRateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rates', 'id', id)
            const localVarPath = `/v1/shipments/{id}/rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentRateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, shipmentUpdateData?: ShipmentUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(shipmentData: ShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(shipmentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {boolean} [hasManifest] 
         * @param {boolean} [hasTracker] 
         * @param {string} [id] 
         * @param {string} [keyword] 
         * @param {string} [metaKey] 
         * @param {string} [metaValue] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {string} [status] Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(address?: string, carrierName?: string, createdAfter?: string, createdBefore?: string, hasManifest?: boolean, hasTracker?: boolean, id?: string, keyword?: string, metaKey?: string, metaValue?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: string, trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(address, carrierName, createdAfter, createdBefore, hasManifest, hasTracker, id, keyword, metaKey, metaValue, metadataKey, metadataValue, optionKey, optionValue, reference, service, status, trackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(id: string, shipmentPurchaseData: ShipmentPurchaseData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(id, shipmentPurchaseData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.purchase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rates(id: string, shipmentRateData?: ShipmentRateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rates(id, shipmentRateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.rates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, shipmentUpdateData?: ShipmentUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, shipmentUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShipmentsApi - factory interface
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipmentsApiFp(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.cancel(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.create(requestParameters.shipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {ShipmentsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.list(requestParameters.address, requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.hasManifest, requestParameters.hasTracker, requestParameters.id, requestParameters.keyword, requestParameters.metaKey, requestParameters.metaValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.optionKey, requestParameters.optionValue, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.purchase(requestParameters.id, requestParameters.shipmentPurchaseData, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.rates(requestParameters.id, requestParameters.shipmentRateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.update(requestParameters.id, requestParameters.shipmentUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in ShipmentsApi.
 */
export interface ShipmentsApiCancelRequest {
    readonly id: string
}

/**
 * Request parameters for create operation in ShipmentsApi.
 */
export interface ShipmentsApiCreateRequest {
    readonly shipmentData: ShipmentData
}

/**
 * Request parameters for list operation in ShipmentsApi.
 */
export interface ShipmentsApiListRequest {
    readonly address?: string

    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName?: string

    readonly createdAfter?: string

    readonly createdBefore?: string

    readonly hasManifest?: boolean

    readonly hasTracker?: boolean

    readonly id?: string

    readonly keyword?: string

    readonly metaKey?: string

    readonly metaValue?: string

    readonly metadataKey?: string

    readonly metadataValue?: string

    readonly optionKey?: string

    readonly optionValue?: string

    readonly reference?: string

    readonly service?: string

    /**
     * Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
     */
    readonly status?: string

    readonly trackingNumber?: string
}

/**
 * Request parameters for purchase operation in ShipmentsApi.
 */
export interface ShipmentsApiPurchaseRequest {
    readonly id: string

    readonly shipmentPurchaseData: ShipmentPurchaseData
}

/**
 * Request parameters for rates operation in ShipmentsApi.
 */
export interface ShipmentsApiRatesRequest {
    readonly id: string

    readonly shipmentRateData?: ShipmentRateData
}

/**
 * Request parameters for retrieve operation in ShipmentsApi.
 */
export interface ShipmentsApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for update operation in ShipmentsApi.
 */
export interface ShipmentsApiUpdateRequest {
    readonly id: string

    readonly shipmentUpdateData?: ShipmentUpdateData
}

/**
 * ShipmentsApi - object-oriented interface
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Void a shipment with the associated label.
     * @summary Cancel a shipment
     * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipment instance.
     * @summary Create a shipment
     * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).create(requestParameters.shipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipments.
     * @summary List all shipments
     * @param {ShipmentsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).list(requestParameters.address, requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.hasManifest, requestParameters.hasTracker, requestParameters.id, requestParameters.keyword, requestParameters.metaKey, requestParameters.metaValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.optionKey, requestParameters.optionValue, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select your preferred rates to buy a shipment label.
     * @summary Buy a shipment label
     * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).purchase(requestParameters.id, requestParameters.shipmentPurchaseData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the list of the shipment rates
     * @summary Fetch new shipment rates
     * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).rates(requestParameters.id, requestParameters.shipmentRateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment.
     * @summary Retrieve a shipment
     * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
     * @summary Update a shipment
     * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).update(requestParameters.id, requestParameters.shipmentUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrackersApi - axios parameter creator
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {boolean} [pendingPickup] Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (trackingData: TrackingData, hub?: string, pendingPickup?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('add', 'trackingData', trackingData)
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }

            if (pendingPickup !== undefined) {
                localVarQueryParameter['pending_pickup'] = pendingPickup;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {CreateCarrierNameEnum} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create: async (carrierName: string, carrierName2: CreateCarrierNameEnum, trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('create', 'carrierName', carrierName)
            // verify required parameter 'carrierName2' is not null or undefined
            assertParamExists('create', 'carrierName2', carrierName2)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('create', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/trackers/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName2 !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName2;
            }

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [status] Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;cancelled&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;, &#x60;return_to_sender&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName?: string, createdAfter?: string, createdBefore?: string, status?: string, trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('remove', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('retrieve', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {string} idOrTrackingNumber 
         * @param {TrackerUpdateData} [trackerUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (idOrTrackingNumber: string, trackerUpdateData?: TrackerUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('update', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {boolean} [pendingPickup] Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(trackingData: TrackingData, hub?: string, pendingPickup?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(trackingData, hub, pendingPickup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.add']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {CreateCarrierNameEnum} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async create(carrierName: string, carrierName2: CreateCarrierNameEnum, trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(carrierName, carrierName2, trackingNumber, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [status] Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;cancelled&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;, &#x60;return_to_sender&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName?: string, createdAfter?: string, createdBefore?: string, status?: string, trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, createdAfter, createdBefore, status, trackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(idOrTrackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(idOrTrackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {string} idOrTrackingNumber 
         * @param {TrackerUpdateData} [trackerUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(idOrTrackingNumber: string, trackerUpdateData?: TrackerUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(idOrTrackingNumber, trackerUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrackersApi - factory interface
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackersApiAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(requestParameters: TrackersApiAddRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.add(requestParameters.trackingData, requestParameters.hub, requestParameters.pendingPickup, options).then((request) => request(axios, basePath));
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {TrackersApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.create(requestParameters.carrierName, requestParameters.carrierName2, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {TrackersApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TrackerList> {
            return localVarFp.list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.remove(requestParameters.idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {TrackersApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: TrackersApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.retrieve(requestParameters.idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {TrackersApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: TrackersApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.update(requestParameters.idOrTrackingNumber, requestParameters.trackerUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for add operation in TrackersApi.
 */
export interface TrackersApiAddRequest {
    readonly trackingData: TrackingData

    readonly hub?: string

    /**
     * Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
     */
    readonly pendingPickup?: boolean
}

/**
 * Request parameters for create operation in TrackersApi.
 */
export interface TrackersApiCreateRequest {
    readonly carrierName: string

    readonly carrierName2: CreateCarrierNameEnum

    readonly trackingNumber: string

    readonly hub?: string
}

/**
 * Request parameters for list operation in TrackersApi.
 */
export interface TrackersApiListRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dtdc&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;landmark&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;mydhl&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;shipengine&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;veho&#x60;, &#x60;zoom2u&#x60;
     */
    readonly carrierName?: string

    readonly createdAfter?: string

    readonly createdBefore?: string

    /**
     * Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;cancelled&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;, &#x60;return_to_sender&#x60;
     */
    readonly status?: string

    readonly trackingNumber?: string
}

/**
 * Request parameters for remove operation in TrackersApi.
 */
export interface TrackersApiRemoveRequest {
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for retrieve operation in TrackersApi.
 */
export interface TrackersApiRetrieveRequest {
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for update operation in TrackersApi.
 */
export interface TrackersApiUpdateRequest {
    readonly idOrTrackingNumber: string

    readonly trackerUpdateData?: TrackerUpdateData
}

/**
 * TrackersApi - object-oriented interface
 */
export class TrackersApi extends BaseAPI {
    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Add a package tracker
     * @param {TrackersApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public add(requestParameters: TrackersApiAddRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).add(requestParameters.trackingData, requestParameters.hub, requestParameters.pendingPickup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Create a package tracker
     * @param {TrackersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).create(requestParameters.carrierName, requestParameters.carrierName2, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipment trackers.
     * @summary List all package trackers
     * @param {TrackersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a package tracker.
     * @summary Discard a package tracker
     * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).remove(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a package tracker
     * @summary Retrieves a package tracker
     * @param {TrackersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: TrackersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).retrieve(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to log requests
     * @summary Update tracker data
     * @param {TrackersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: TrackersApiUpdateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).update(requestParameters.idOrTrackingNumber, requestParameters.trackerUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CreateCarrierNameEnum = {
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dtdc: 'dtdc',
    Fedex: 'fedex',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Landmark: 'landmark',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Mydhl: 'mydhl',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Veho: 'veho',
    Zoom2u: 'zoom2u'
} as const;
export type CreateCarrierNameEnum = typeof CreateCarrierNameEnum[keyof typeof CreateCarrierNameEnum];


/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (webhookData: WebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookData' is not null or undefined
            assertParamExists('create', 'webhookData', webhookData)
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, webhookTestRequest: WebhookTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'webhookTestRequest' is not null or undefined
            assertParamExists('test', 'webhookTestRequest', webhookTestRequest)
            const localVarPath = `/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedWebhookData?: PatchedWebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(webhookData: WebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(webhookData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, webhookTestRequest: WebhookTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, webhookTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedWebhookData?: PatchedWebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedWebhookData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.create(requestParameters.webhookData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<WebhookList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<Operation> {
            return localVarFp.remove(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {WebhooksApiTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig): AxiosPromise<Operation> {
            return localVarFp.test(requestParameters.id, requestParameters.webhookTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedWebhookData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in WebhooksApi.
 */
export interface WebhooksApiCreateRequest {
    readonly webhookData: WebhookData
}

/**
 * Request parameters for remove operation in WebhooksApi.
 */
export interface WebhooksApiRemoveRequest {
    readonly id: string
}

/**
 * Request parameters for retrieve operation in WebhooksApi.
 */
export interface WebhooksApiRetrieveRequest {
    readonly id: string
}

/**
 * Request parameters for test operation in WebhooksApi.
 */
export interface WebhooksApiTestRequest {
    readonly id: string

    readonly webhookTestRequest: WebhookTestRequest
}

/**
 * Request parameters for update operation in WebhooksApi.
 */
export interface WebhooksApiUpdateRequest {
    readonly id: string

    readonly patchedWebhookData?: PatchedWebhookData
}

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a webhook
     * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).create(requestParameters.webhookData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhooks.
     * @summary List all webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a webhook.
     * @summary Remove a webhook
     * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a webhook.
     * @summary Retrieve a webhook
     * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * test a webhook.
     * @summary Test a webhook
     * @param {WebhooksApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).test(requestParameters.id, requestParameters.webhookTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a webhook.
     * @summary Update a webhook
     * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedWebhookData, options).then((request) => request(this.axios, this.basePath));
    }
}



