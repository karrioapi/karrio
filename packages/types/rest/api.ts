/* tslint:disable */
/* eslint-disable */
/**
 * Karrio API
 *  Karrio is a multi-carrier shipping API that simplifies the integration of logistics carrier services.  The Karrio API is organized around REST. Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  The Karrio API differs for every account as we release new versions. These docs are customized to your version of the API.   ## Versioning  When backwards-incompatible changes are made to the API, a new, dated version is released. The current version is `2024.12rc12`.  Read our API changelog to learn more about backwards compatibility.  As a precaution, use API versioning to check a new API version before committing to an upgrade.   ## Environments  The Karrio API offer the possibility to create and retrieve certain objects in `test_mode`. In development, it is therefore possible to add carrier connections, get live rates, buy labels, create trackers and schedule pickups in `test_mode`.   ## Pagination  All top-level API resources have support for bulk fetches via \"list\" API methods. For instance, you can list addresses, list shipments, and list trackers. These list API methods share a common structure, taking at least these two parameters: limit, and offset.  Karrio utilizes offset-based pagination via the offset and limit parameters. Both parameters take a number as value (see below) and return objects in reverse chronological order. The offset parameter returns objects listed after an index. The limit parameter take a limit on the number of objects to be returned from 1 to 100.   ```json {     \"count\": 100,     \"next\": \"/v1/shipments?limit=25&offset=50\",     \"previous\": \"/v1/shipments?limit=25&offset=25\",     \"results\": [         { ... },     ] } ```  ## Metadata  Updateable Karrio objectsâ€”including Shipment and Order have a metadata parameter. You can use this parameter to attach key-value data to these Karrio objects.  Metadata is useful for storing additional, structured information on an object. As an example, you could store your user\'s full name and corresponding unique identifier from your system on a Karrio Order object.  Do not store any sensitive information as metadata.  ## Authentication  API keys are used to authenticate requests. You can view and manage your API keys in the Dashboard.  Your API keys carry many privileges, so be sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as GitHub, client-side code, and so forth.  Authentication to the API is performed via HTTP Basic Auth. Provide your API token as the basic auth username value. You do not need to provide a password.  ```shell $ curl https://instance.api.com/v1/shipments \\     -u key_xxxxxx: # The colon prevents curl from asking for a password. ```  If you need to authenticate via bearer auth (e.g., for a cross-origin request), use `-H \"Authorization: Token key_xxxxxx\"` instead of `-u key_xxxxxx`.  All API requests must be made over [HTTPS](http://en.wikipedia.org/wiki/HTTP_Secure). API requests without authentication will also fail. 
 *
 * The version of the OpenAPI document: 2024.12rc12
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * The error or warning message
     * @type {string}
     * @memberof APIError
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof APIError
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: any; }}
     * @memberof APIError
     */
    'details'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Address
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof Address
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof Address
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof Address
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof Address
     */
    'country_code': AddressCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof Address
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof Address
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof Address
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof Address
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     * @type {string}
     * @memberof Address
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof Address
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof Address
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Address
     */
    'object_type'?: string;
    /**
     * Specify address validation result
     * @type {AddressValidation}
     * @memberof Address
     */
    'validation'?: AddressValidation | null;
}

export const AddressCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type AddressCountryCodeEnum = typeof AddressCountryCodeEnum[keyof typeof AddressCountryCodeEnum];

/**
 * 
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof AddressData
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof AddressData
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof AddressData
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof AddressData
     */
    'country_code': AddressDataCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof AddressData
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof AddressData
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof AddressData
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof AddressData
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     * @type {string}
     * @memberof AddressData
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof AddressData
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof AddressData
     */
    'validate_location'?: boolean | null;
}

export const AddressDataCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type AddressDataCountryCodeEnum = typeof AddressDataCountryCodeEnum[keyof typeof AddressDataCountryCodeEnum];

/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {number}
     * @memberof AddressList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'results': Array<Address>;
}
/**
 * 
 * @export
 * @interface AddressValidation
 */
export interface AddressValidation {
    /**
     * True if the address is valid
     * @type {boolean}
     * @memberof AddressValidation
     */
    'success': boolean;
    /**
     * validation service details
     * @type {{ [key: string]: any; }}
     * @memberof AddressValidation
     */
    'meta'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface AlliedExpress
 */
export interface AlliedExpress {
    /**
     * 
     * @type {string}
     * @memberof AlliedExpress
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AlliedExpress
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AlliedExpress
     */
    'account'?: string;
    /**
     * Indicates a service_type string
     * @type {string}
     * @memberof AlliedExpress
     */
    'service_type'?: AlliedExpressServiceTypeEnum;
}

export const AlliedExpressServiceTypeEnum = {
    R: 'R',
    P: 'P',
    Pt: 'PT',
    Pt2: 'PT2'
} as const;

export type AlliedExpressServiceTypeEnum = typeof AlliedExpressServiceTypeEnum[keyof typeof AlliedExpressServiceTypeEnum];

/**
 * 
 * @export
 * @interface AlliedExpressLocal
 */
export interface AlliedExpressLocal {
    /**
     * 
     * @type {string}
     * @memberof AlliedExpressLocal
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AlliedExpressLocal
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AlliedExpressLocal
     */
    'account'?: string;
    /**
     * Indicates a service_type string
     * @type {string}
     * @memberof AlliedExpressLocal
     */
    'service_type'?: AlliedExpressLocalServiceTypeEnum;
}

export const AlliedExpressLocalServiceTypeEnum = {
    R: 'R',
    P: 'P',
    Pt: 'PT',
    Pt2: 'PT2'
} as const;

export type AlliedExpressLocalServiceTypeEnum = typeof AlliedExpressLocalServiceTypeEnum[keyof typeof AlliedExpressLocalServiceTypeEnum];

/**
 * 
 * @export
 * @interface AmazonShipping
 */
export interface AmazonShipping {
    /**
     * 
     * @type {string}
     * @memberof AmazonShipping
     */
    'seller_id': string;
    /**
     * 
     * @type {string}
     * @memberof AmazonShipping
     */
    'developer_id': string;
    /**
     * 
     * @type {string}
     * @memberof AmazonShipping
     */
    'mws_auth_token': string;
    /**
     * 
     * @type {string}
     * @memberof AmazonShipping
     */
    'aws_region'?: string;
    /**
     * 
     * @type {string}
     * @memberof AmazonShipping
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface Aramex
 */
export interface Aramex {
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'account_pin': string;
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'account_entity': string;
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof Aramex
     */
    'account_country_code': string;
}
/**
 * 
 * @export
 * @interface AsendiaUs
 */
export interface AsendiaUs {
    /**
     * 
     * @type {string}
     * @memberof AsendiaUs
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AsendiaUs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AsendiaUs
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof AsendiaUs
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface Australiapost
 */
export interface Australiapost {
    /**
     * 
     * @type {string}
     * @memberof Australiapost
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof Australiapost
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Australiapost
     */
    'account_number': string;
}
/**
 * 
 * @export
 * @interface BatchObject
 */
export interface BatchObject {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchObject
     */
    'id'?: string;
    /**
     * The batch operation resource status
     * @type {string}
     * @memberof BatchObject
     */
    'status': BatchObjectStatusEnum;
    /**
     * Resource processing errors
     * @type {{ [key: string]: any; }}
     * @memberof BatchObject
     */
    'errors'?: { [key: string]: any; } | null;
}

export const BatchObjectStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Failed: 'failed',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors'
} as const;

export type BatchObjectStatusEnum = typeof BatchObjectStatusEnum[keyof typeof BatchObjectStatusEnum];

/**
 * 
 * @export
 * @interface BatchOperation
 */
export interface BatchOperation {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchOperation
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'status': BatchOperationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'resource_type': BatchOperationResourceTypeEnum;
    /**
     * 
     * @type {Array<BatchObject>}
     * @memberof BatchOperation
     */
    'resources': Array<BatchObject>;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof BatchOperation
     */
    'test_mode': boolean;
}

export const BatchOperationStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Failed: 'failed',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors'
} as const;

export type BatchOperationStatusEnum = typeof BatchOperationStatusEnum[keyof typeof BatchOperationStatusEnum];
export const BatchOperationResourceTypeEnum = {
    Orders: 'orders',
    Shipments: 'shipments',
    Trackers: 'trackers',
    Billing: 'billing'
} as const;

export type BatchOperationResourceTypeEnum = typeof BatchOperationResourceTypeEnum[keyof typeof BatchOperationResourceTypeEnum];

/**
 * 
 * @export
 * @interface BatchOperations
 */
export interface BatchOperations {
    /**
     * 
     * @type {number}
     * @memberof BatchOperations
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BatchOperation>}
     * @memberof BatchOperations
     */
    'results': Array<BatchOperation>;
}
/**
 * 
 * @export
 * @interface BatchOrderData
 */
export interface BatchOrderData {
    /**
     * The list of orders to process.
     * @type {Array<OrderData>}
     * @memberof BatchOrderData
     */
    'orders': Array<OrderData>;
}
/**
 * 
 * @export
 * @interface BatchShipmentData
 */
export interface BatchShipmentData {
    /**
     * The list of shipments to process.
     * @type {Array<ShipmentDataReference>}
     * @memberof BatchShipmentData
     */
    'shipments': Array<ShipmentDataReference>;
}
/**
 * 
 * @export
 * @interface BatchTrackerData
 */
export interface BatchTrackerData {
    /**
     * The list of tracking info to process.
     * @type {Array<TrackingData>}
     * @memberof BatchTrackerData
     */
    'trackers': Array<TrackingData>;
}
/**
 * 
 * @export
 * @interface Boxknight
 */
export interface Boxknight {
    /**
     * 
     * @type {string}
     * @memberof Boxknight
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Boxknight
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Bpost
 */
export interface Bpost {
    /**
     * 
     * @type {string}
     * @memberof Bpost
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof Bpost
     */
    'passphrase': string;
}
/**
 * 
 * @export
 * @interface Canadapost
 */
export interface Canadapost {
    /**
     * 
     * @type {string}
     * @memberof Canadapost
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Canadapost
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Canadapost
     */
    'customer_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Canadapost
     */
    'contract_id'?: string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Canadapost
     */
    'language'?: CanadapostLanguageEnum;
}

export const CanadapostLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type CanadapostLanguageEnum = typeof CanadapostLanguageEnum[keyof typeof CanadapostLanguageEnum];

/**
 * 
 * @export
 * @interface Canpar
 */
export interface Canpar {
    /**
     * 
     * @type {string}
     * @memberof Canpar
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Canpar
     */
    'password': string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Canpar
     */
    'language'?: CanparLanguageEnum;
}

export const CanparLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type CanparLanguageEnum = typeof CanparLanguageEnum[keyof typeof CanparLanguageEnum];

/**
 * 
 * @export
 * @interface CarrierConnection
 */
export interface CarrierConnection {
    /**
     * A unique carrier connection identifier
     * @type {string}
     * @memberof CarrierConnection
     */
    'id': string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof CarrierConnection
     */
    'object_type'?: string;
    /**
     * A carrier connection type.
     * @type {string}
     * @memberof CarrierConnection
     */
    'carrier_name': CarrierConnectionCarrierNameEnum;
    /**
     * The carrier connection type verbose name.
     * @type {string}
     * @memberof CarrierConnection
     */
    'display_name'?: string;
    /**
     * A carrier connection friendly name.
     * @type {string}
     * @memberof CarrierConnection
     */
    'carrier_id': string;
    /**
     * Carrier connection credentials.
     * @type {ConnectionCredentialsField}
     * @memberof CarrierConnection
     */
    'credentials'?: ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     * @type {Array<string>}
     * @memberof CarrierConnection
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierConnection
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierConnection
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The carrier connection is provided by the system admin.
     * @type {boolean}
     * @memberof CarrierConnection
     */
    'is_system': boolean;
    /**
     * The active flag indicates whether the carrier account is active or not.
     * @type {boolean}
     * @memberof CarrierConnection
     */
    'active': boolean;
    /**
     * The test flag indicates whether to use a carrier configured for test.
     * @type {boolean}
     * @memberof CarrierConnection
     */
    'test_mode': boolean;
}

export const CarrierConnectionCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierConnectionCarrierNameEnum = typeof CarrierConnectionCarrierNameEnum[keyof typeof CarrierConnectionCarrierNameEnum];

/**
 * 
 * @export
 * @interface CarrierConnectionData
 */
export interface CarrierConnectionData {
    /**
     * A carrier connection type.
     * @type {string}
     * @memberof CarrierConnectionData
     */
    'carrier_name': CarrierConnectionDataCarrierNameEnum;
    /**
     * A carrier connection friendly name.
     * @type {string}
     * @memberof CarrierConnectionData
     */
    'carrier_id': string;
    /**
     * Carrier connection credentials.
     * @type {ConnectionCredentialsField}
     * @memberof CarrierConnectionData
     */
    'credentials': ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     * @type {Array<string>}
     * @memberof CarrierConnectionData
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierConnectionData
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierConnectionData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The active flag indicates whether the carrier account is active or not.
     * @type {boolean}
     * @memberof CarrierConnectionData
     */
    'active'?: boolean;
}

export const CarrierConnectionDataCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierConnectionDataCarrierNameEnum = typeof CarrierConnectionDataCarrierNameEnum[keyof typeof CarrierConnectionDataCarrierNameEnum];

/**
 * 
 * @export
 * @interface CarrierConnectionList
 */
export interface CarrierConnectionList {
    /**
     * 
     * @type {number}
     * @memberof CarrierConnectionList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierConnectionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierConnectionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CarrierConnection>}
     * @memberof CarrierConnectionList
     */
    'results': Array<CarrierConnection>;
}
/**
 * 
 * @export
 * @interface CarrierDetails
 */
export interface CarrierDetails {
    /**
     * Indicates a carrier (type)
     * @type {string}
     * @memberof CarrierDetails
     */
    'carrier_name': CarrierDetailsCarrierNameEnum;
    /**
     * The carrier verbose name.
     * @type {string}
     * @memberof CarrierDetails
     */
    'display_name': string;
    /**
     * The carrier supported and enabled capabilities.
     * @type {Array<string>}
     * @memberof CarrierDetails
     */
    'capabilities'?: Array<string>;
    /**
     * The carrier connection fields.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierDetails
     */
    'connection_fields'?: { [key: string]: any; };
    /**
     * The carrier connection config.
     * @type {{ [key: string]: any; }}
     * @memberof CarrierDetails
     */
    'config_fields'?: { [key: string]: any; };
}

export const CarrierDetailsCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;

export type CarrierDetailsCarrierNameEnum = typeof CarrierDetailsCarrierNameEnum[keyof typeof CarrierDetailsCarrierNameEnum];

/**
 * 
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The charge description
     * @type {string}
     * @memberof Charge
     */
    'name'?: string | null;
    /**
     * The charge monetary value
     * @type {number}
     * @memberof Charge
     */
    'amount'?: number | null;
    /**
     * The charge amount currency
     * @type {string}
     * @memberof Charge
     */
    'currency'?: string | null;
}
/**
 * 
 * @export
 * @interface Chronopost
 */
export interface Chronopost {
    /**
     * 
     * @type {string}
     * @memberof Chronopost
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof Chronopost
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Chronopost
     */
    'id_emit'?: string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Chronopost
     */
    'language'?: ChronopostLanguageEnum;
}

export const ChronopostLanguageEnum = {
    EnGb: 'en_GB',
    FrFr: 'fr_FR'
} as const;

export type ChronopostLanguageEnum = typeof ChronopostLanguageEnum[keyof typeof ChronopostLanguageEnum];

/**
 * 
 * @export
 * @interface Colissimo
 */
export interface Colissimo {
    /**
     * 
     * @type {string}
     * @memberof Colissimo
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Colissimo
     */
    'contract_number': string;
    /**
     * 
     * @type {string}
     * @memberof Colissimo
     */
    'laposte_api_key'?: string;
}
/**
 * 
 * @export
 * @interface Commodity
 */
export interface Commodity {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Commodity
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof Commodity
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof Commodity
     */
    'weight_unit': CommodityWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof Commodity
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof Commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof Commodity
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof Commodity
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof Commodity
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof Commodity
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof Commodity
     */
    'value_currency'?: CommodityValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof Commodity
     */
    'origin_country'?: CommodityOriginCountryEnum | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof Commodity
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Commodity
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Commodity
     */
    'object_type'?: string;
}

export const CommodityWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type CommodityWeightUnitEnum = typeof CommodityWeightUnitEnum[keyof typeof CommodityWeightUnitEnum];
export const CommodityValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Null: 'null'
} as const;

export type CommodityValueCurrencyEnum = typeof CommodityValueCurrencyEnum[keyof typeof CommodityValueCurrencyEnum];
export const CommodityOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX',
    Null: 'null'
} as const;

export type CommodityOriginCountryEnum = typeof CommodityOriginCountryEnum[keyof typeof CommodityOriginCountryEnum];

/**
 * 
 * @export
 * @interface CommodityData
 */
export interface CommodityData {
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof CommodityData
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof CommodityData
     */
    'weight_unit': CommodityDataWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof CommodityData
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof CommodityData
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof CommodityData
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof CommodityData
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof CommodityData
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof CommodityData
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof CommodityData
     */
    'value_currency'?: CommodityDataValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof CommodityData
     */
    'origin_country'?: CommodityDataOriginCountryEnum | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof CommodityData
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof CommodityData
     */
    'metadata'?: { [key: string]: any; } | null;
}

export const CommodityDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type CommodityDataWeightUnitEnum = typeof CommodityDataWeightUnitEnum[keyof typeof CommodityDataWeightUnitEnum];
export const CommodityDataValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Null: 'null'
} as const;

export type CommodityDataValueCurrencyEnum = typeof CommodityDataValueCurrencyEnum[keyof typeof CommodityDataValueCurrencyEnum];
export const CommodityDataOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX',
    Null: 'null'
} as const;

export type CommodityDataOriginCountryEnum = typeof CommodityDataOriginCountryEnum[keyof typeof CommodityDataOriginCountryEnum];

/**
 * @type ConnectionCredentialsField
 * @export
 */
export type ConnectionCredentialsField = AlliedExpress | AlliedExpressLocal | AmazonShipping | Aramex | AsendiaUs | Australiapost | Boxknight | Bpost | Canadapost | Canpar | Chronopost | Colissimo | DhlExpress | DhlParcelDe | DhlPoland | DhlUniversal | Dicom | Dpd | Dpdhl | Easypost | Easyship | Eshipper | Fedex | FedexWs | Freightcom | Generic | Geodis | HayPost | Laposte | Locate2u | Nationex | Purolator | Roadie | Royalmail | Sapient | Seko | Sendle | Tge | Tnt | Ups | Usps | UspsInternational | UspsWt | UspsWtInternational | Zoom2u;

/**
 * 
 * @export
 * @interface Customs
 */
export interface Customs {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Customs
     */
    'id'?: string;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof Customs
     */
    'commodities'?: Array<Commodity>;
    /**
     * The payment details.<br/>         **Note that this is required for a Dutiable parcel shipped internationally.**         
     * @type {Duty}
     * @memberof Customs
     */
    'duty'?: Duty | null;
    /**
     * The duty payor address.
     * @type {Address}
     * @memberof Customs
     */
    'duty_billing_address'?: Address | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'content_type'?: CustomsContentTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof Customs
     */
    'incoterm'?: CustomsIncotermEnum | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof Customs
     */
    'invoice'?: string | null;
    /**
     * The invoice date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof Customs
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof Customs
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof Customs
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Customs
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Customs
     */
    'object_type'?: string;
}

export const CustomsContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other',
    Empty: '',
    Null: 'null'
} as const;

export type CustomsContentTypeEnum = typeof CustomsContentTypeEnum[keyof typeof CustomsContentTypeEnum];
export const CustomsIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB',
    Null: 'null'
} as const;

export type CustomsIncotermEnum = typeof CustomsIncotermEnum[keyof typeof CustomsIncotermEnum];

/**
 * 
 * @export
 * @interface CustomsData
 */
export interface CustomsData {
    /**
     * The parcel content items
     * @type {Array<CommodityData>}
     * @memberof CustomsData
     */
    'commodities': Array<CommodityData>;
    /**
     * The payment details.<br/>         **Note that this is required for a Dutiable parcel shipped internationally.**         
     * @type {Duty}
     * @memberof CustomsData
     */
    'duty'?: Duty | null;
    /**
     * The duty payor address.
     * @type {AddressData}
     * @memberof CustomsData
     */
    'duty_billing_address'?: AddressData | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'content_type'?: CustomsDataContentTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof CustomsData
     */
    'incoterm'?: CustomsDataIncotermEnum | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof CustomsData
     */
    'invoice'?: string | null;
    /**
     * The invoice date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof CustomsData
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof CustomsData
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof CustomsData
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof CustomsData
     */
    'options'?: { [key: string]: any; };
}

export const CustomsDataContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other',
    Empty: '',
    Null: 'null'
} as const;

export type CustomsDataContentTypeEnum = typeof CustomsDataContentTypeEnum[keyof typeof CustomsDataContentTypeEnum];
export const CustomsDataIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB',
    Null: 'null'
} as const;

export type CustomsDataIncotermEnum = typeof CustomsDataIncotermEnum[keyof typeof CustomsDataIncotermEnum];

/**
 * 
 * @export
 * @interface DhlExpress
 */
export interface DhlExpress {
    /**
     * 
     * @type {string}
     * @memberof DhlExpress
     */
    'site_id': string;
    /**
     * 
     * @type {string}
     * @memberof DhlExpress
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof DhlExpress
     */
    'account_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DhlExpress
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface DhlParcelDe
 */
export interface DhlParcelDe {
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'dhl_api_key': string;
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'customer_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'tracking_consumer_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DhlParcelDe
     */
    'tracking_consumer_secret'?: string;
}
/**
 * 
 * @export
 * @interface DhlPoland
 */
export interface DhlPoland {
    /**
     * 
     * @type {string}
     * @memberof DhlPoland
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof DhlPoland
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof DhlPoland
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface DhlUniversal
 */
export interface DhlUniversal {
    /**
     * 
     * @type {string}
     * @memberof DhlUniversal
     */
    'consumer_key': string;
    /**
     * 
     * @type {string}
     * @memberof DhlUniversal
     */
    'consumer_secret': string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof DhlUniversal
     */
    'language'?: DhlUniversalLanguageEnum;
}

export const DhlUniversalLanguageEnum = {
    En: 'en',
    De: 'de'
} as const;

export type DhlUniversalLanguageEnum = typeof DhlUniversalLanguageEnum[keyof typeof DhlUniversalLanguageEnum];

/**
 * 
 * @export
 * @interface Dicom
 */
export interface Dicom {
    /**
     * 
     * @type {string}
     * @memberof Dicom
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Dicom
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Dicom
     */
    'billing_account'?: string;
}
/**
 * 
 * @export
 * @interface DocumentData
 */
export interface DocumentData {
    /**
     * The template name. **Required if template is not provided.**
     * @type {string}
     * @memberof DocumentData
     */
    'template_id'?: string;
    /**
     * The template content. **Required if template_id is not provided.**
     * @type {string}
     * @memberof DocumentData
     */
    'template'?: string;
    /**
     * The format of the document
     * @type {string}
     * @memberof DocumentData
     */
    'doc_format'?: string;
    /**
     * The file name
     * @type {string}
     * @memberof DocumentData
     */
    'doc_name'?: string;
    /**
     * The template data
     * @type {{ [key: string]: any; }}
     * @memberof DocumentData
     */
    'data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DocumentDetails
 */
export interface DocumentDetails {
    /**
     * The uploaded document id.
     * @type {string}
     * @memberof DocumentDetails
     */
    'doc_id'?: string;
    /**
     * The uploaded document file name.
     * @type {string}
     * @memberof DocumentDetails
     */
    'file_name'?: string;
}
/**
 * 
 * @export
 * @interface DocumentFileData
 */
export interface DocumentFileData {
    /**
     * A base64 file to upload
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_file': string;
    /**
     * The file name
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_name': string;
    /**
     * The file format
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_format'?: string | null;
    /**
     *          Shipment document type          values: <br/>         `certificate_of_origin` `commercial_invoice` `pro_forma_invoice` `packing_list` `other`          For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_type'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentTemplate
 */
export interface DocumentTemplate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof DocumentTemplate
     */
    'id'?: string;
    /**
     * The template name
     * @type {string}
     * @memberof DocumentTemplate
     */
    'name': string;
    /**
     * The template slug
     * @type {string}
     * @memberof DocumentTemplate
     */
    'slug': string;
    /**
     * The template content
     * @type {string}
     * @memberof DocumentTemplate
     */
    'template': string;
    /**
     * disable template flag.
     * @type {boolean}
     * @memberof DocumentTemplate
     */
    'active'?: boolean;
    /**
     * The template description
     * @type {string}
     * @memberof DocumentTemplate
     */
    'description'?: string;
    /**
     * The template metadata
     * @type {{ [key: string]: any; }}
     * @memberof DocumentTemplate
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template related object
     * @type {string}
     * @memberof DocumentTemplate
     */
    'related_object'?: DocumentTemplateRelatedObjectEnum;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof DocumentTemplate
     */
    'object_type'?: string;
}

export const DocumentTemplateRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type DocumentTemplateRelatedObjectEnum = typeof DocumentTemplateRelatedObjectEnum[keyof typeof DocumentTemplateRelatedObjectEnum];

/**
 * 
 * @export
 * @interface DocumentTemplateData
 */
export interface DocumentTemplateData {
    /**
     * The template name
     * @type {string}
     * @memberof DocumentTemplateData
     */
    'name': string;
    /**
     * The template slug
     * @type {string}
     * @memberof DocumentTemplateData
     */
    'slug': string;
    /**
     * The template content
     * @type {string}
     * @memberof DocumentTemplateData
     */
    'template': string;
    /**
     * disable template flag.
     * @type {boolean}
     * @memberof DocumentTemplateData
     */
    'active'?: boolean;
    /**
     * The template description
     * @type {string}
     * @memberof DocumentTemplateData
     */
    'description'?: string;
    /**
     * The template metadata
     * @type {{ [key: string]: any; }}
     * @memberof DocumentTemplateData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template related object
     * @type {string}
     * @memberof DocumentTemplateData
     */
    'related_object'?: DocumentTemplateDataRelatedObjectEnum;
}

export const DocumentTemplateDataRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type DocumentTemplateDataRelatedObjectEnum = typeof DocumentTemplateDataRelatedObjectEnum[keyof typeof DocumentTemplateDataRelatedObjectEnum];

/**
 * 
 * @export
 * @interface DocumentTemplateList
 */
export interface DocumentTemplateList {
    /**
     * 
     * @type {number}
     * @memberof DocumentTemplateList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentTemplateList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentTemplateList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DocumentTemplate>}
     * @memberof DocumentTemplateList
     */
    'results': Array<DocumentTemplate>;
}
/**
 * 
 * @export
 * @interface DocumentUploadData
 */
export interface DocumentUploadData {
    /**
     * The documents related shipment.
     * @type {string}
     * @memberof DocumentUploadData
     */
    'shipment_id': string;
    /**
     * Shipping document files
     * @type {Array<DocumentFileData>}
     * @memberof DocumentUploadData
     */
    'document_files': Array<DocumentFileData>;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadData
     */
    'reference'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecord
 */
export interface DocumentUploadRecord {
    /**
     * A unique identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'id'?: string;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_id'?: string | null;
    /**
     * the carrier shipping document ids
     * @type {Array<DocumentDetails>}
     * @memberof DocumentUploadRecord
     */
    'documents'?: Array<DocumentDetails>;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof DocumentUploadRecord
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'reference'?: string | null;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof DocumentUploadRecord
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecords
 */
export interface DocumentUploadRecords {
    /**
     * 
     * @type {number}
     * @memberof DocumentUploadRecords
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DocumentUploadRecord>}
     * @memberof DocumentUploadRecords
     */
    'results': Array<DocumentUploadRecord>;
}
/**
 * 
 * @export
 * @interface Documents
 */
export interface Documents {
    /**
     * A shipping label in base64 string
     * @type {string}
     * @memberof Documents
     */
    'label'?: string | null;
    /**
     * A shipping invoice in base64 string
     * @type {string}
     * @memberof Documents
     */
    'invoice'?: string | null;
}
/**
 * 
 * @export
 * @interface Dpd
 */
export interface Dpd {
    /**
     * 
     * @type {string}
     * @memberof Dpd
     */
    'delis_id': string;
    /**
     * 
     * @type {string}
     * @memberof Dpd
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Dpd
     */
    'depot'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpd
     */
    'message_language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpd
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface Dpdhl
 */
export interface Dpdhl {
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'app_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'app_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'zt_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'zt_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dpdhl
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface Duty
 */
export interface Duty {
    /**
     * The duty payer
     * @type {string}
     * @memberof Duty
     */
    'paid_by'?: DutyPaidByEnum | null;
    /**
     * The declared value currency
     * @type {string}
     * @memberof Duty
     */
    'currency'?: DutyCurrencyEnum | null;
    /**
     * The package declared value
     * @type {number}
     * @memberof Duty
     */
    'declared_value'?: number | null;
    /**
     * The duty payment account number
     * @type {string}
     * @memberof Duty
     */
    'account_number'?: string | null;
}

export const DutyPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party',
    Empty: '',
    Null: 'null'
} as const;

export type DutyPaidByEnum = typeof DutyPaidByEnum[keyof typeof DutyPaidByEnum];
export const DutyCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Empty: '',
    Null: 'null'
} as const;

export type DutyCurrencyEnum = typeof DutyCurrencyEnum[keyof typeof DutyCurrencyEnum];

/**
 * 
 * @export
 * @interface Easypost
 */
export interface Easypost {
    /**
     * 
     * @type {string}
     * @memberof Easypost
     */
    'api_key': string;
}
/**
 * 
 * @export
 * @interface Easyship
 */
export interface Easyship {
    /**
     * 
     * @type {string}
     * @memberof Easyship
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface ErrorMessages
 */
export interface ErrorMessages {
    /**
     * The list of error messages
     * @type {Array<Message>}
     * @memberof ErrorMessages
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The list of API errors
     * @type {Array<APIError>}
     * @memberof ErrorResponse
     */
    'errors'?: Array<APIError>;
}
/**
 * 
 * @export
 * @interface Eshipper
 */
export interface Eshipper {
    /**
     * 
     * @type {string}
     * @memberof Eshipper
     */
    'principal': string;
    /**
     * 
     * @type {string}
     * @memberof Eshipper
     */
    'credential': string;
}
/**
 * 
 * @export
 * @interface Fedex
 */
export interface Fedex {
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'account_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'track_api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'track_secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fedex
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface FedexWs
 */
export interface FedexWs {
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'meter_number': string;
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'user_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'language_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FedexWs
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface Freightcom
 */
export interface Freightcom {
    /**
     * 
     * @type {string}
     * @memberof Freightcom
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Freightcom
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface GeneratedDocument
 */
export interface GeneratedDocument {
    /**
     * The template name
     * @type {string}
     * @memberof GeneratedDocument
     */
    'template_id'?: string;
    /**
     * The format of the document
     * @type {string}
     * @memberof GeneratedDocument
     */
    'doc_format'?: string;
    /**
     * The file name
     * @type {string}
     * @memberof GeneratedDocument
     */
    'doc_name'?: string;
    /**
     * A base64 file content
     * @type {string}
     * @memberof GeneratedDocument
     */
    'doc_file': string;
}
/**
 * 
 * @export
 * @interface Generic
 */
export interface Generic {
    /**
     * 
     * @type {string}
     * @memberof Generic
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof Generic
     */
    'custom_carrier_name': string;
    /**
     * 
     * @type {string}
     * @memberof Generic
     */
    'account_country_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Generic
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface Geodis
 */
export interface Geodis {
    /**
     * 
     * @type {string}
     * @memberof Geodis
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof Geodis
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof Geodis
     */
    'code_client'?: string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Geodis
     */
    'language'?: GeodisLanguageEnum;
}

export const GeodisLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;

export type GeodisLanguageEnum = typeof GeodisLanguageEnum[keyof typeof GeodisLanguageEnum];

/**
 * 
 * @export
 * @interface HayPost
 */
export interface HayPost {
    /**
     * 
     * @type {string}
     * @memberof HayPost
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof HayPost
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof HayPost
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof HayPost
     */
    'customer_type': string;
}
/**
 * 
 * @export
 * @interface Images
 */
export interface Images {
    /**
     * A delivery image in base64 string
     * @type {string}
     * @memberof Images
     */
    'delivery_image'?: string | null;
    /**
     * A signature image in base64 string
     * @type {string}
     * @memberof Images
     */
    'signature_image'?: string | null;
}
/**
 * 
 * @export
 * @interface Laposte
 */
export interface Laposte {
    /**
     * 
     * @type {string}
     * @memberof Laposte
     */
    'api_key': string;
    /**
     * Indicates a lang string
     * @type {string}
     * @memberof Laposte
     */
    'lang'?: LaposteLangEnum;
}

export const LaposteLangEnum = {
    FrFr: 'fr_FR',
    EnUs: 'en_US'
} as const;

export type LaposteLangEnum = typeof LaposteLangEnum[keyof typeof LaposteLangEnum];

/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * A unique identifier
     * @type {string}
     * @memberof LineItem
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof LineItem
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof LineItem
     */
    'weight_unit': LineItemWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof LineItem
     */
    'title'?: string | null;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof LineItem
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof LineItem
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof LineItem
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof LineItem
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof LineItem
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof LineItem
     */
    'value_currency'?: LineItemValueCurrencyEnum | null;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof LineItem
     */
    'origin_country'?: LineItemOriginCountryEnum | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof LineItem
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof LineItem
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof LineItem
     */
    'object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'unfulfilled_quantity'?: number;
}

export const LineItemWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type LineItemWeightUnitEnum = typeof LineItemWeightUnitEnum[keyof typeof LineItemWeightUnitEnum];
export const LineItemValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Null: 'null'
} as const;

export type LineItemValueCurrencyEnum = typeof LineItemValueCurrencyEnum[keyof typeof LineItemValueCurrencyEnum];
export const LineItemOriginCountryEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX',
    Null: 'null'
} as const;

export type LineItemOriginCountryEnum = typeof LineItemOriginCountryEnum[keyof typeof LineItemOriginCountryEnum];

/**
 * 
 * @export
 * @interface Locate2u
 */
export interface Locate2u {
    /**
     * 
     * @type {string}
     * @memberof Locate2u
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Locate2u
     */
    'client_secret'?: string;
}
/**
 * 
 * @export
 * @interface Manifest
 */
export interface Manifest {
    /**
     * A unique manifest identifier
     * @type {string}
     * @memberof Manifest
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Manifest
     */
    'object_type'?: string;
    /**
     * The manifest carrier
     * @type {string}
     * @memberof Manifest
     */
    'carrier_name': string;
    /**
     * The manifest carrier configured name
     * @type {string}
     * @memberof Manifest
     */
    'carrier_id': string;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Manifest
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Manifest
     */
    'test_mode': boolean;
    /**
     * The address of the warehouse or location where the shipments originate.
     * @type {AddressData}
     * @memberof Manifest
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Manifest
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     * @type {string}
     * @memberof Manifest
     */
    'reference'?: string | null;
    /**
     * The list of shipment identifiers you want to add to your manifest.<br/>         shipment_identifier is often a tracking_number or shipment_id returned when you purchase a label.         
     * @type {Array<string>}
     * @memberof Manifest
     */
    'shipment_identifiers': Array<string>;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof Manifest
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The Manifest file URL
     * @type {string}
     * @memberof Manifest
     */
    'manifest_url'?: string | null;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof Manifest
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface ManifestData
 */
export interface ManifestData {
    /**
     * The manifest\'s carrier
     * @type {string}
     * @memberof ManifestData
     */
    'carrier_name': string;
    /**
     * The address of the warehouse or location where the shipments originate.
     * @type {AddressData}
     * @memberof ManifestData
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ManifestData
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     * @type {string}
     * @memberof ManifestData
     */
    'reference'?: string | null;
    /**
     * The list of existing shipment object ids with label purchased.
     * @type {Array<string>}
     * @memberof ManifestData
     */
    'shipment_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface ManifestDetails
 */
export interface ManifestDetails {
    /**
     * A unique manifest identifier
     * @type {string}
     * @memberof ManifestDetails
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ManifestDetails
     */
    'object_type'?: string;
    /**
     * The manifest carrier
     * @type {string}
     * @memberof ManifestDetails
     */
    'carrier_name': string;
    /**
     * The manifest carrier configured name
     * @type {string}
     * @memberof ManifestDetails
     */
    'carrier_id': string;
    /**
     * The manifest documents
     * @type {ManifestDocument}
     * @memberof ManifestDetails
     */
    'doc'?: ManifestDocument | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof ManifestDetails
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof ManifestDetails
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface ManifestDocument
 */
export interface ManifestDocument {
    /**
     * A manifest file in base64 string
     * @type {string}
     * @memberof ManifestDocument
     */
    'manifest'?: string | null;
}
/**
 * 
 * @export
 * @interface ManifestList
 */
export interface ManifestList {
    /**
     * 
     * @type {number}
     * @memberof ManifestList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ManifestList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ManifestList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Manifest>}
     * @memberof ManifestList
     */
    'results': Array<Manifest>;
}
/**
 * 
 * @export
 * @interface ManifestRequest
 */
export interface ManifestRequest {
    /**
     * The manifest\'s carrier
     * @type {string}
     * @memberof ManifestRequest
     */
    'carrier_name': string;
    /**
     * The address of the warehouse or location where the shipments originate.
     * @type {AddressData}
     * @memberof ManifestRequest
     */
    'address': AddressData;
    /**
     * <details>         <summary>The options available for the manifest.</summary>          {             \"shipments\": [                 {                     \"tracking_number\": \"123456789\",                     ...                     \"meta\": {...}                 }             ]         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ManifestRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The manifest reference
     * @type {string}
     * @memberof ManifestRequest
     */
    'reference'?: string | null;
    /**
     * The list of shipment identifiers you want to add to your manifest.<br/>         shipment_identifier is often a tracking_number or shipment_id returned when you purchase a label.         
     * @type {Array<string>}
     * @memberof ManifestRequest
     */
    'shipment_identifiers': Array<string>;
}
/**
 * 
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof ManifestResponse
     */
    'messages'?: Array<Message>;
    /**
     * The manifest details
     * @type {ManifestDetails}
     * @memberof ManifestResponse
     */
    'manifest'?: ManifestDetails;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The error or warning message
     * @type {string}
     * @memberof Message
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof Message
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: any; }}
     * @memberof Message
     */
    'details'?: { [key: string]: any; };
    /**
     * The targeted carrier
     * @type {string}
     * @memberof Message
     */
    'carrier_name'?: string;
    /**
     * The targeted carrier name (unique identifier)
     * @type {string}
     * @memberof Message
     */
    'carrier_id'?: string;
}
/**
 * 
 * @export
 * @interface Nationex
 */
export interface Nationex {
    /**
     * 
     * @type {string}
     * @memberof Nationex
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof Nationex
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof Nationex
     */
    'billing_account'?: string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Nationex
     */
    'language'?: NationexLanguageEnum;
}

export const NationexLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type NationexLanguageEnum = typeof NationexLanguageEnum[keyof typeof NationexLanguageEnum];

/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * Operation performed
     * @type {string}
     * @memberof Operation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof Operation
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface OperationConfirmation
 */
export interface OperationConfirmation {
    /**
     * Operation performed
     * @type {string}
     * @memberof OperationConfirmation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof OperationConfirmation
     */
    'success': boolean;
    /**
     * The operation carrier
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_id': string;
}
/**
 * 
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof OperationResponse
     */
    'messages'?: Array<Message>;
    /**
     * The operation details
     * @type {OperationConfirmation}
     * @memberof OperationResponse
     */
    'confirmation'?: OperationConfirmation;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Order
     */
    'object_type'?: string;
    /**
     * The source\' order id.
     * @type {string}
     * @memberof Order
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof Order
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.
     * @type {string}
     * @memberof Order
     */
    'source'?: string;
    /**
     * The order status.
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * The customer address for the order.
     * @type {Address}
     * @memberof Order
     */
    'shipping_to': Address;
    /**
     * The origin or warehouse address of the order items.
     * @type {Address}
     * @memberof Order
     */
    'shipping_from'?: Address | null;
    /**
     * The customer\' or shipping billing address.
     * @type {AddressData}
     * @memberof Order
     */
    'billing_address'?: AddressData | null;
    /**
     * The order line items.
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'line_items': Array<LineItem>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],             \"preferred_service\": \"fedex_express_saver\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * system related metadata.
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The shipments associated with the order.
     * @type {Array<Shipment>}
     * @memberof Order
     */
    'shipments'?: Array<Shipment>;
    /**
     * Specify whether the order is in test mode or not.
     * @type {boolean}
     * @memberof Order
     */
    'test_mode': boolean;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
}

export const OrderStatusEnum = {
    Unfulfilled: 'unfulfilled',
    Cancelled: 'cancelled',
    Fulfilled: 'fulfilled',
    Delivered: 'delivered',
    Partial: 'partial'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

/**
 * 
 * @export
 * @interface OrderData
 */
export interface OrderData {
    /**
     * The source\' order id.
     * @type {string}
     * @memberof OrderData
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof OrderData
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.<br/>         e.g. API, POS, ERP, Shopify, Woocommerce, etc.         
     * @type {string}
     * @memberof OrderData
     */
    'source'?: string;
    /**
     * The customer or recipient address for the order.
     * @type {AddressData}
     * @memberof OrderData
     */
    'shipping_to': AddressData;
    /**
     * The origin or warehouse address of the order items.
     * @type {AddressData}
     * @memberof OrderData
     */
    'shipping_from'?: AddressData | null;
    /**
     * The customer\' or shipping billing address.
     * @type {AddressData}
     * @memberof OrderData
     */
    'billing_address'?: AddressData | null;
    /**
     * The order line items.
     * @type {Array<CommodityData>}
     * @memberof OrderData
     */
    'line_items': Array<CommodityData>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],             \"preferred_service\": \"fedex_express_saver\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof OrderData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     * @type {{ [key: string]: any; }}
     * @memberof OrderData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderList
     */
    'results': Array<Order>;
}
/**
 * 
 * @export
 * @interface OrderUpdateData
 */
export interface OrderUpdateData {
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"recipient\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof OrderUpdateData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof OrderUpdateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Parcel
     */
    'id'?: string;
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof Parcel
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof Parcel
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof Parcel
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof Parcel
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof Parcel
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof Parcel
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof Parcel
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof Parcel
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof Parcel
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof Parcel
     */
    'weight_unit': ParcelWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof Parcel
     */
    'dimension_unit'?: ParcelDimensionUnitEnum | null;
    /**
     * The parcel items.
     * @type {Array<Commodity>}
     * @memberof Parcel
     */
    'items'?: Array<Commodity>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof Parcel
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof Parcel
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Parcel
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Parcel
     */
    'object_type'?: string;
}

export const ParcelWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type ParcelWeightUnitEnum = typeof ParcelWeightUnitEnum[keyof typeof ParcelWeightUnitEnum];
export const ParcelDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN',
    Null: 'null'
} as const;

export type ParcelDimensionUnitEnum = typeof ParcelDimensionUnitEnum[keyof typeof ParcelDimensionUnitEnum];

/**
 * 
 * @export
 * @interface ParcelData
 */
export interface ParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof ParcelData
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof ParcelData
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof ParcelData
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof ParcelData
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof ParcelData
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof ParcelData
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof ParcelData
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof ParcelData
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof ParcelData
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof ParcelData
     */
    'weight_unit': ParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof ParcelData
     */
    'dimension_unit'?: ParcelDataDimensionUnitEnum | null;
    /**
     * The parcel items.
     * @type {Array<CommodityData>}
     * @memberof ParcelData
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof ParcelData
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof ParcelData
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ParcelData
     */
    'options'?: { [key: string]: any; };
}

export const ParcelDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type ParcelDataWeightUnitEnum = typeof ParcelDataWeightUnitEnum[keyof typeof ParcelDataWeightUnitEnum];
export const ParcelDataDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN',
    Null: 'null'
} as const;

export type ParcelDataDimensionUnitEnum = typeof ParcelDataDimensionUnitEnum[keyof typeof ParcelDataDimensionUnitEnum];

/**
 * 
 * @export
 * @interface ParcelList
 */
export interface ParcelList {
    /**
     * 
     * @type {number}
     * @memberof ParcelList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Parcel>}
     * @memberof ParcelList
     */
    'results': Array<Parcel>;
}
/**
 * 
 * @export
 * @interface PatchedAddressData
 */
export interface PatchedAddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof PatchedAddressData
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof PatchedAddressData
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof PatchedAddressData
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof PatchedAddressData
     */
    'country_code'?: PatchedAddressDataCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof PatchedAddressData
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof PatchedAddressData
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof PatchedAddressData
     */
    'state_code'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof PatchedAddressData
     */
    'residential'?: boolean | null;
    /**
     * The address street number
     * @type {string}
     * @memberof PatchedAddressData
     */
    'street_number'?: string | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof PatchedAddressData
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof PatchedAddressData
     */
    'validate_location'?: boolean | null;
}

export const PatchedAddressDataCountryCodeEnum = {
    Ac: 'AC',
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW',
    Eh: 'EH',
    Im: 'IM',
    Bl: 'BL',
    Mf: 'MF',
    Sx: 'SX'
} as const;

export type PatchedAddressDataCountryCodeEnum = typeof PatchedAddressDataCountryCodeEnum[keyof typeof PatchedAddressDataCountryCodeEnum];

/**
 * 
 * @export
 * @interface PatchedCarrierConnectionData
 */
export interface PatchedCarrierConnectionData {
    /**
     * A carrier connection type.
     * @type {string}
     * @memberof PatchedCarrierConnectionData
     */
    'carrier_name'?: PatchedCarrierConnectionDataCarrierNameEnum;
    /**
     * A carrier connection friendly name.
     * @type {string}
     * @memberof PatchedCarrierConnectionData
     */
    'carrier_id'?: string;
    /**
     * Carrier connection credentials.
     * @type {ConnectionCredentialsField}
     * @memberof PatchedCarrierConnectionData
     */
    'credentials'?: ConnectionCredentialsField;
    /**
     * The carrier enabled capabilities.
     * @type {Array<string>}
     * @memberof PatchedCarrierConnectionData
     */
    'capabilities'?: Array<string> | null;
    /**
     * Carrier connection custom config.
     * @type {{ [key: string]: any; }}
     * @memberof PatchedCarrierConnectionData
     */
    'config'?: { [key: string]: any; };
    /**
     * User metadata for the carrier.
     * @type {{ [key: string]: any; }}
     * @memberof PatchedCarrierConnectionData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The active flag indicates whether the carrier account is active or not.
     * @type {boolean}
     * @memberof PatchedCarrierConnectionData
     */
    'active'?: boolean;
}

export const PatchedCarrierConnectionDataCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;

export type PatchedCarrierConnectionDataCarrierNameEnum = typeof PatchedCarrierConnectionDataCarrierNameEnum[keyof typeof PatchedCarrierConnectionDataCarrierNameEnum];

/**
 * 
 * @export
 * @interface PatchedDocumentTemplateData
 */
export interface PatchedDocumentTemplateData {
    /**
     * The template name
     * @type {string}
     * @memberof PatchedDocumentTemplateData
     */
    'name'?: string;
    /**
     * The template slug
     * @type {string}
     * @memberof PatchedDocumentTemplateData
     */
    'slug'?: string;
    /**
     * The template content
     * @type {string}
     * @memberof PatchedDocumentTemplateData
     */
    'template'?: string;
    /**
     * disable template flag.
     * @type {boolean}
     * @memberof PatchedDocumentTemplateData
     */
    'active'?: boolean;
    /**
     * The template description
     * @type {string}
     * @memberof PatchedDocumentTemplateData
     */
    'description'?: string;
    /**
     * The template metadata
     * @type {{ [key: string]: any; }}
     * @memberof PatchedDocumentTemplateData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The template related object
     * @type {string}
     * @memberof PatchedDocumentTemplateData
     */
    'related_object'?: PatchedDocumentTemplateDataRelatedObjectEnum;
}

export const PatchedDocumentTemplateDataRelatedObjectEnum = {
    Shipment: 'shipment',
    Order: 'order',
    Other: 'other'
} as const;

export type PatchedDocumentTemplateDataRelatedObjectEnum = typeof PatchedDocumentTemplateDataRelatedObjectEnum[keyof typeof PatchedDocumentTemplateDataRelatedObjectEnum];

/**
 * 
 * @export
 * @interface PatchedParcelData
 */
export interface PatchedParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof PatchedParcelData
     */
    'weight'?: number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof PatchedParcelData
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof PatchedParcelData
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof PatchedParcelData
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof PatchedParcelData
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof PatchedParcelData
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof PatchedParcelData
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof PatchedParcelData
     */
    'weight_unit'?: PatchedParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof PatchedParcelData
     */
    'dimension_unit'?: PatchedParcelDataDimensionUnitEnum | null;
    /**
     * The parcel items.
     * @type {Array<CommodityData>}
     * @memberof PatchedParcelData
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof PatchedParcelData
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof PatchedParcelData
     */
    'options'?: { [key: string]: any; };
}

export const PatchedParcelDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB',
    Oz: 'OZ',
    G: 'G'
} as const;

export type PatchedParcelDataWeightUnitEnum = typeof PatchedParcelDataWeightUnitEnum[keyof typeof PatchedParcelDataWeightUnitEnum];
export const PatchedParcelDataDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN',
    Null: 'null'
} as const;

export type PatchedParcelDataDimensionUnitEnum = typeof PatchedParcelDataDimensionUnitEnum[keyof typeof PatchedParcelDataDimensionUnitEnum];

/**
 * 
 * @export
 * @interface PatchedWebhookData
 */
export interface PatchedWebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof PatchedWebhookData
     */
    'url'?: string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof PatchedWebhookData
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof PatchedWebhookData
     */
    'enabled_events'?: Array<PatchedWebhookDataEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof PatchedWebhookData
     */
    'disabled'?: boolean | null;
}

export const PatchedWebhookDataEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type PatchedWebhookDataEnabledEventsEnum = typeof PatchedWebhookDataEnabledEventsEnum[keyof typeof PatchedWebhookDataEnabledEventsEnum];

/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The payor type
     * @type {string}
     * @memberof Payment
     */
    'paid_by'?: PaymentPaidByEnum;
    /**
     * The payment amount currency
     * @type {string}
     * @memberof Payment
     */
    'currency'?: PaymentCurrencyEnum | null;
    /**
     * The payor account number
     * @type {string}
     * @memberof Payment
     */
    'account_number'?: string | null;
}

export const PaymentPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party'
} as const;

export type PaymentPaidByEnum = typeof PaymentPaidByEnum[keyof typeof PaymentPaidByEnum];
export const PaymentCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR',
    Empty: '',
    Null: 'null'
} as const;

export type PaymentCurrencyEnum = typeof PaymentCurrencyEnum[keyof typeof PaymentCurrencyEnum];

/**
 * 
 * @export
 * @interface Pickup
 */
export interface Pickup {
    /**
     * A unique pickup identifier
     * @type {string}
     * @memberof Pickup
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Pickup
     */
    'object_type'?: string;
    /**
     * The pickup carrier
     * @type {string}
     * @memberof Pickup
     */
    'carrier_name': string;
    /**
     * The pickup carrier configured name
     * @type {string}
     * @memberof Pickup
     */
    'carrier_id': string;
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof Pickup
     */
    'confirmation_number': string;
    /**
     * The pickup date
     * @type {string}
     * @memberof Pickup
     */
    'pickup_date'?: string | null;
    /**
     * The pickup cost details
     * @type {Charge}
     * @memberof Pickup
     */
    'pickup_charge'?: Charge | null;
    /**
     * The pickup expected ready time
     * @type {string}
     * @memberof Pickup
     */
    'ready_time'?: string | null;
    /**
     * The pickup expected closing or late time
     * @type {string}
     * @memberof Pickup
     */
    'closing_time'?: string | null;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof Pickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Pickup
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The pickup address
     * @type {Address}
     * @memberof Pickup
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof Pickup
     */
    'parcels': Array<Parcel>;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof Pickup
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof Pickup
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof Pickup
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Pickup
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface PickupCancelData
 */
export interface PickupCancelData {
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelData
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface PickupCancelRequest
 */
export interface PickupCancelRequest {
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'confirmation_number': string;
    /**
     * The pickup address
     * @type {AddressData}
     * @memberof PickupCancelRequest
     */
    'address'?: AddressData;
    /**
     * The pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'pickup_date'?: string | null;
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface PickupData
 */
export interface PickupData {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupData
     */
    'pickup_date': string;
    /**
     * The pickup address
     * @type {AddressData}
     * @memberof PickupData
     */
    'address'?: AddressData;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupData
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupData
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupData
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupData
     */
    'tracking_numbers': Array<string>;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof PickupData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PickupList
 */
export interface PickupList {
    /**
     * 
     * @type {number}
     * @memberof PickupList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pickup>}
     * @memberof PickupList
     */
    'results': Array<Pickup>;
}
/**
 * 
 * @export
 * @interface PickupRequest
 */
export interface PickupRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupRequest
     */
    'pickup_date': string;
    /**
     * The pickup address
     * @type {AddressData}
     * @memberof PickupRequest
     */
    'address': AddressData;
    /**
     * The shipment parcels to pickup.
     * @type {Array<ParcelData>}
     * @memberof PickupRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupRequest
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupRequest
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupRequest
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupRequest
     */
    'options'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface PickupResponse
 */
export interface PickupResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof PickupResponse
     */
    'messages'?: Array<Message>;
    /**
     * The scheduled pickup\'s summary
     * @type {Pickup}
     * @memberof PickupResponse
     */
    'pickup'?: Pickup;
}
/**
 * 
 * @export
 * @interface PickupUpdateData
 */
export interface PickupUpdateData {
    /**
     * The expected pickup date.<br/>         Date Format: YYYY-MM-DD         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'pickup_date'?: string;
    /**
     * The pickup address
     * @type {AddressData}
     * @memberof PickupUpdateData
     */
    'address'?: AddressData;
    /**
     * The ready time for pickup.
     * @type {string}
     * @memberof PickupUpdateData
     */
    'ready_time'?: string | null;
    /**
     * The closing or late time of the pickup
     * @type {string}
     * @memberof PickupUpdateData
     */
    'closing_time'?: string | null;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupUpdateData
     */
    'tracking_numbers'?: Array<string>;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateData
     */
    'confirmation_number': string;
}
/**
 * 
 * @export
 * @interface PickupUpdateRequest
 */
export interface PickupUpdateRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'pickup_date': string;
    /**
     * The pickup address
     * @type {Address}
     * @memberof PickupUpdateRequest
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof PickupUpdateRequest
     */
    'parcels': Array<Parcel>;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'confirmation_number': string;
    /**
     * The ready time for pickup.         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateRequest
     */
    'options'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface Purolator
 */
export interface Purolator {
    /**
     * 
     * @type {string}
     * @memberof Purolator
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Purolator
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Purolator
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof Purolator
     */
    'user_token'?: string;
    /**
     * Indicates a language string
     * @type {string}
     * @memberof Purolator
     */
    'language'?: PurolatorLanguageEnum;
}

export const PurolatorLanguageEnum = {
    En: 'en',
    Fr: 'fr'
} as const;

export type PurolatorLanguageEnum = typeof PurolatorLanguageEnum[keyof typeof PurolatorLanguageEnum];

/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Rate
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Rate
     */
    'object_type'?: string;
    /**
     * The rate\'s carrier
     * @type {string}
     * @memberof Rate
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof Rate
     */
    'carrier_id': string;
    /**
     * The rate monetary values currency code
     * @type {string}
     * @memberof Rate
     */
    'currency'?: string;
    /**
     * The carrier\'s rate (quote) service
     * @type {string}
     * @memberof Rate
     */
    'service'?: string | null;
    /**
     * The rate\'s monetary amount of the total charge.<br/>         This is the gross amount of the rate after adding the additional charges         
     * @type {number}
     * @memberof Rate
     */
    'total_charge'?: number;
    /**
     * The estimated delivery transit days
     * @type {number}
     * @memberof Rate
     */
    'transit_days'?: number | null;
    /**
     * list of the rate\'s additional charges
     * @type {Array<Charge>}
     * @memberof Rate
     */
    'extra_charges'?: Array<Charge>;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof Rate
     */
    'estimated_delivery'?: string | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Rate
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Rate
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface RateRequest
 */
export interface RateRequest {
    /**
     * The address of the party<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof RateRequest
     */
    'shipper': AddressData;
    /**
     * The address of the party<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof RateRequest
     */
    'recipient': AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof RateRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.         
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof RateRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     * @type {string}
     * @memberof RateRequest
     */
    'reference'?: string | null;
    /**
     * The list of configured carriers you wish to get rates from.
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'carrier_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RateResponse
 */
export interface RateResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof RateResponse
     */
    'messages'?: Array<Message>;
    /**
     * The list of returned rates
     * @type {Array<Rate>}
     * @memberof RateResponse
     */
    'rates': Array<Rate>;
}
/**
 * 
 * @export
 * @interface Roadie
 */
export interface Roadie {
    /**
     * 
     * @type {string}
     * @memberof Roadie
     */
    'api_key': string;
}
/**
 * 
 * @export
 * @interface Royalmail
 */
export interface Royalmail {
    /**
     * 
     * @type {string}
     * @memberof Royalmail
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof Royalmail
     */
    'client_secret': string;
}
/**
 * 
 * @export
 * @interface Sapient
 */
export interface Sapient {
    /**
     * 
     * @type {string}
     * @memberof Sapient
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof Sapient
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof Sapient
     */
    'shipping_account_id': string;
    /**
     * Indicates a carrier_code string
     * @type {string}
     * @memberof Sapient
     */
    'carrier_code'?: SapientCarrierCodeEnum;
}

export const SapientCarrierCodeEnum = {
    Dx: 'DX',
    Evri: 'EVRI',
    Rm: 'RM',
    Ups: 'UPS',
    Yodel: 'YODEL'
} as const;

export type SapientCarrierCodeEnum = typeof SapientCarrierCodeEnum[keyof typeof SapientCarrierCodeEnum];

/**
 * 
 * @export
 * @interface Seko
 */
export interface Seko {
    /**
     * 
     * @type {string}
     * @memberof Seko
     */
    'access_key': string;
}
/**
 * 
 * @export
 * @interface Sendle
 */
export interface Sendle {
    /**
     * 
     * @type {string}
     * @memberof Sendle
     */
    'sendle_id': string;
    /**
     * 
     * @type {string}
     * @memberof Sendle
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof Sendle
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface Shipment
 */
export interface Shipment {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Shipment
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Shipment
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof Shipment
     */
    'tracking_url'?: string | null;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {Address}
     * @memberof Shipment
     */
    'shipper': Address;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {Address}
     * @memberof Shipment
     */
    'recipient': Address;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     * @type {AddressData}
     * @memberof Shipment
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     * @type {AddressData}
     * @memberof Shipment
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof Shipment
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof Shipment
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     * @type {Payment}
     * @memberof Shipment
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     * @type {Customs}
     * @memberof Shipment
     */
    'customs'?: Customs | null;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof Shipment
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof Shipment
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof Shipment
     */
    'label_type'?: ShipmentLabelTypeEnum | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof Shipment
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof Shipment
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof Shipment
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof Shipment
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {string}
     * @memberof Shipment
     */
    'status'?: ShipmentStatusEnum;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof Shipment
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof Shipment
     */
    'shipment_identifier'?: string | null;
    /**
     * The shipment selected rate
     * @type {Rate}
     * @memberof Shipment
     */
    'selected_rate'?: Rate | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     * @type {string}
     * @memberof Shipment
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof Shipment
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Shipment
     */
    'test_mode': boolean;
    /**
     * The shipment label URL
     * @type {string}
     * @memberof Shipment
     */
    'label_url'?: string | null;
    /**
     * The shipment invoice URL
     * @type {string}
     * @memberof Shipment
     */
    'invoice_url'?: string | null;
}

export const ShipmentLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG',
    Empty: '',
    Null: 'null'
} as const;

export type ShipmentLabelTypeEnum = typeof ShipmentLabelTypeEnum[keyof typeof ShipmentLabelTypeEnum];
export const ShipmentStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered',
    NeedsAttention: 'needs_attention',
    OutForDelivery: 'out_for_delivery',
    DeliveryFailed: 'delivery_failed'
} as const;

export type ShipmentStatusEnum = typeof ShipmentStatusEnum[keyof typeof ShipmentStatusEnum];

/**
 * 
 * @export
 * @interface ShipmentCancelRequest
 */
export interface ShipmentCancelRequest {
    /**
     * The shipment identifier returned during creation.
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'shipment_identifier': string;
    /**
     * The selected shipment service
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'service'?: string | null;
    /**
     * The shipment carrier_id for specific connection selection.
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'carrier_id'?: string;
    /**
     * Advanced carrier specific cancellation options.
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentCancelRequest
     */
    'options'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ShipmentData
 */
export interface ShipmentData {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShipmentData
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentData
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShipmentData
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     * @type {CustomsData}
     * @memberof ShipmentData
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentData
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentData
     */
    'label_type'?: ShipmentDataLabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     * @type {string}
     * @memberof ShipmentData
     */
    'service'?: string;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request         you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentData
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentDataLabelTypeEnum = typeof ShipmentDataLabelTypeEnum[keyof typeof ShipmentDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShipmentDataReference
 */
export interface ShipmentDataReference {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShipmentDataReference
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShipmentDataReference
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     * @type {AddressData}
     * @memberof ShipmentDataReference
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     * @type {AddressData}
     * @memberof ShipmentDataReference
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShipmentDataReference
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentDataReference
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShipmentDataReference
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     * @type {CustomsData}
     * @memberof ShipmentDataReference
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentDataReference
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentDataReference
     */
    'label_type'?: ShipmentDataReferenceLabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     * @type {string}
     * @memberof ShipmentDataReference
     */
    'service'?: string;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request         you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShipmentDataReference
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShipmentDataReference
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentDataReference
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The shipment id.
     * @type {string}
     * @memberof ShipmentDataReference
     */
    'id'?: string;
}

export const ShipmentDataReferenceLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentDataReferenceLabelTypeEnum = typeof ShipmentDataReferenceLabelTypeEnum[keyof typeof ShipmentDataReferenceLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShipmentPurchaseData
 */
export interface ShipmentPurchaseData {
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'selected_rate_id': string;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'label_type'?: ShipmentPurchaseDataLabelTypeEnum;
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShipmentPurchaseData
     */
    'payment'?: Payment;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentPurchaseData
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentPurchaseDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentPurchaseDataLabelTypeEnum = typeof ShipmentPurchaseDataLabelTypeEnum[keyof typeof ShipmentPurchaseDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShipmentRateData
 */
export interface ShipmentRateData {
    /**
     * The requested carrier service for the shipment.<br/>         Please consult [the reference](#operation/references) for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could         specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentRateData
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentRateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentRateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ShipmentUpdateData
 */
export interface ShipmentUpdateData {
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentUpdateData
     */
    'label_type'?: ShipmentUpdateDataLabelTypeEnum;
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShipmentUpdateData
     */
    'payment'?: Payment;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentUpdateData
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentUpdateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentUpdateData
     */
    'metadata'?: { [key: string]: any; };
}

export const ShipmentUpdateDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentUpdateDataLabelTypeEnum = typeof ShipmentUpdateDataLabelTypeEnum[keyof typeof ShipmentUpdateDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShippingRequest
 */
export interface ShippingRequest {
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'recipient': AddressData;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'shipper': AddressData;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShippingRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShippingRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShippingRequest
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     * @type {CustomsData}
     * @memberof ShippingRequest
     */
    'customs'?: CustomsData | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingRequest
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShippingRequest
     */
    'label_type'?: ShippingRequestLabelTypeEnum;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingRequest
     */
    'selected_rate_id': string;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingRequest
     */
    'rates': Array<Rate>;
}

export const ShippingRequestLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShippingRequestLabelTypeEnum = typeof ShippingRequestLabelTypeEnum[keyof typeof ShippingRequestLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShippingResponse
 */
export interface ShippingResponse {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShippingResponse
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_url'?: string | null;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {Address}
     * @memberof ShippingResponse
     */
    'shipper': Address;
    /**
     * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
     * @type {Address}
     * @memberof ShippingResponse
     */
    'recipient': Address;
    /**
     * The return address for this shipment. Defaults to the shipper address.
     * @type {AddressData}
     * @memberof ShippingResponse
     */
    'return_address'?: AddressData | null;
    /**
     * The payor address.
     * @type {AddressData}
     * @memberof ShippingResponse
     */
    'billing_address'?: AddressData | null;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof ShippingResponse
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"sms_notification\": true,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"hold_at_location\": true,             \"paperless_trade\": true,             \"preferred_service\": \"fedex_express_saver\",             \"shipment_date\": \"2020-01-01\",  # TODO: deprecate             \"shipping_date\": \"2020-01-01T00:00\",             \"shipment_note\": \"This is a shipment note\",             \"signature_confirmation\": true,             \"saturday_delivery\": true,             \"is_return\": true,             \"doc_files\": [                 {                     \"doc_type\": \"commercial_invoice\",                     \"doc_file\": \"base64 encoded file\",                     \"doc_name\": \"commercial_invoice.pdf\",                     \"doc_format\": \"pdf\",                 }             ],             \"doc_references\": [                 {                     \"doc_id\": \"123456789\",                     \"doc_type\": \"commercial_invoice\",                 }             ],         }         </details>         
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'options'?: { [key: string]: any; };
    /**
     * The payment details
     * @type {Payment}
     * @memberof ShippingResponse
     */
    'payment'?: Payment;
    /**
     * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
     * @type {Customs}
     * @memberof ShippingResponse
     */
    'customs'?: Customs | null;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingResponse
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingResponse
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShippingResponse
     */
    'label_type'?: ShippingResponseLabelTypeEnum | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof ShippingResponse
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof ShippingResponse
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {string}
     * @memberof ShippingResponse
     */
    'status'?: ShippingResponseStatusEnum;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'shipment_identifier'?: string | null;
    /**
     * The shipment selected rate
     * @type {Rate}
     * @memberof ShippingResponse
     */
    'selected_rate'?: Rate | null;
    /**
     * The shipment documents
     * @type {Documents}
     * @memberof ShippingResponse
     */
    'docs'?: Documents | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     * @type {string}
     * @memberof ShippingResponse
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingResponse
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof ShippingResponse
     */
    'test_mode': boolean;
}

export const ShippingResponseLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG',
    Empty: '',
    Null: 'null'
} as const;

export type ShippingResponseLabelTypeEnum = typeof ShippingResponseLabelTypeEnum[keyof typeof ShippingResponseLabelTypeEnum];
export const ShippingResponseStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered',
    NeedsAttention: 'needs_attention',
    OutForDelivery: 'out_for_delivery',
    DeliveryFailed: 'delivery_failed'
} as const;

export type ShippingResponseStatusEnum = typeof ShippingResponseStatusEnum[keyof typeof ShippingResponseStatusEnum];

/**
 * 
 * @export
 * @interface Tge
 */
export interface Tge {
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'api_key': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'toll_username': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'toll_password': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'my_toll_token': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'my_toll_identity': string;
    /**
     * 
     * @type {string}
     * @memberof Tge
     */
    'account_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof Tge
     */
    'sscc_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Tge
     */
    'shipment_count'?: number;
}
/**
 * 
 * @export
 * @interface Tnt
 */
export interface Tnt {
    /**
     * 
     * @type {string}
     * @memberof Tnt
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Tnt
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof Tnt
     */
    'account_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tnt
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TrackerDetails
 */
export interface TrackerDetails {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackerDetails
     */
    'id'?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackerDetails
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackerDetails
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackerDetails
     */
    'tracking_number': string;
    /**
     * The package and shipment tracking details
     * @type {TrackingInfo}
     * @memberof TrackerDetails
     */
    'info'?: TrackingInfo | null;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackerDetails
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackerDetails
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackerDetails
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     * @type {string}
     * @memberof TrackerDetails
     */
    'status'?: TrackerDetailsStatusEnum;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof TrackerDetails
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof TrackerDetails
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The tracker documents
     * @type {Images}
     * @memberof TrackerDetails
     */
    'images'?: Images | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof TrackerDetails
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     * @type {{ [key: string]: any; }}
     * @memberof TrackerDetails
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackerDetails
     */
    'messages'?: Array<Message>;
}

export const TrackerDetailsStatusEnum = {
    Pending: 'pending',
    Unknown: 'unknown',
    OnHold: 'on_hold',
    Delivered: 'delivered',
    InTransit: 'in_transit',
    DeliveryDelayed: 'delivery_delayed',
    OutForDelivery: 'out_for_delivery',
    ReadyForPickup: 'ready_for_pickup',
    DeliveryFailed: 'delivery_failed'
} as const;

export type TrackerDetailsStatusEnum = typeof TrackerDetailsStatusEnum[keyof typeof TrackerDetailsStatusEnum];

/**
 * 
 * @export
 * @interface TrackerList
 */
export interface TrackerList {
    /**
     * 
     * @type {number}
     * @memberof TrackerList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TrackingStatus>}
     * @memberof TrackerList
     */
    'results': Array<TrackingStatus>;
}
/**
 * 
 * @export
 * @interface TrackerUpdateData
 */
export interface TrackerUpdateData {
    /**
     * The package and shipment tracking details
     * @type {TrackingInfo}
     * @memberof TrackerUpdateData
     */
    'info'?: TrackingInfo | null;
    /**
     * User metadata for the tracker
     * @type {{ [key: string]: any; }}
     * @memberof TrackerUpdateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TrackingData
 */
export interface TrackingData {
    /**
     * The package tracking number
     * @type {string}
     * @memberof TrackingData
     */
    'tracking_number': string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingData
     */
    'carrier_name': TrackingDataCarrierNameEnum;
    /**
     * The shipper account number
     * @type {string}
     * @memberof TrackingData
     */
    'account_number'?: string | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof TrackingData
     */
    'reference'?: string | null;
    /**
     * The package and shipment tracking details
     * @type {TrackingInfo}
     * @memberof TrackingData
     */
    'info'?: TrackingInfo | null;
    /**
     * The carrier user metadata.
     * @type {{ [key: string]: any; }}
     * @memberof TrackingData
     */
    'metadata'?: { [key: string]: any; };
}

export const TrackingDataCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;

export type TrackingDataCarrierNameEnum = typeof TrackingDataCarrierNameEnum[keyof typeof TrackingDataCarrierNameEnum];

/**
 * 
 * @export
 * @interface TrackingEvent
 */
export interface TrackingEvent {
    /**
     * The tracking event\'s date. Format: `YYYY-MM-DD`
     * @type {string}
     * @memberof TrackingEvent
     */
    'date'?: string;
    /**
     * The tracking event\'s description
     * @type {string}
     * @memberof TrackingEvent
     */
    'description'?: string;
    /**
     * The tracking event\'s location
     * @type {string}
     * @memberof TrackingEvent
     */
    'location'?: string;
    /**
     * The tracking event\'s code
     * @type {string}
     * @memberof TrackingEvent
     */
    'code'?: string | null;
    /**
     * The tracking event\'s time. Format: `HH:MM AM/PM`
     * @type {string}
     * @memberof TrackingEvent
     */
    'time'?: string | null;
    /**
     * The tracking event\'s latitude.
     * @type {number}
     * @memberof TrackingEvent
     */
    'latitude'?: number | null;
    /**
     * The tracking event\'s longitude.
     * @type {number}
     * @memberof TrackingEvent
     */
    'longitude'?: number | null;
}
/**
 * 
 * @export
 * @interface TrackingInfo
 */
export interface TrackingInfo {
    /**
     * The carrier tracking link
     * @type {string}
     * @memberof TrackingInfo
     */
    'carrier_tracking_link'?: string | null;
    /**
     * The customer name
     * @type {string}
     * @memberof TrackingInfo
     */
    'customer_name'?: string | null;
    /**
     * The expected delivery date
     * @type {string}
     * @memberof TrackingInfo
     */
    'expected_delivery'?: string | null;
    /**
     * A tracking note
     * @type {string}
     * @memberof TrackingInfo
     */
    'note'?: string | null;
    /**
     * The package order date
     * @type {string}
     * @memberof TrackingInfo
     */
    'order_date'?: string | null;
    /**
     * The package order id or number
     * @type {string}
     * @memberof TrackingInfo
     */
    'order_id'?: string | null;
    /**
     * The package weight
     * @type {string}
     * @memberof TrackingInfo
     */
    'package_weight'?: string | null;
    /**
     * The package weight unit
     * @type {string}
     * @memberof TrackingInfo
     */
    'package_weight_unit'?: string | null;
    /**
     * The package count
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_package_count'?: string | null;
    /**
     * The shipment pickup date
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_pickup_date'?: string | null;
    /**
     * The shipment delivery date
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_delivery_date'?: string | null;
    /**
     * The shipment service
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_service'?: string | null;
    /**
     * The shipment origin country
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_origin_country'?: string | null;
    /**
     * The shipment origin postal code
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_origin_postal_code'?: string | null;
    /**
     * The shipment destination country
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_destination_country'?: string | null;
    /**
     * The shipment destination postal code
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipment_destination_postal_code'?: string | null;
    /**
     * The shipping date
     * @type {string}
     * @memberof TrackingInfo
     */
    'shipping_date'?: string | null;
    /**
     * The person who signed for the package
     * @type {string}
     * @memberof TrackingInfo
     */
    'signed_by'?: string | null;
    /**
     * The tracker source
     * @type {string}
     * @memberof TrackingInfo
     */
    'source'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingResponse
 */
export interface TrackingResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingResponse
     */
    'messages'?: Array<Message>;
    /**
     * The tracking details retrieved
     * @type {TrackerDetails}
     * @memberof TrackingResponse
     */
    'tracking'?: TrackerDetails;
}
/**
 * 
 * @export
 * @interface TrackingStatus
 */
export interface TrackingStatus {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'id'?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackingStatus
     */
    'tracking_number': string;
    /**
     * The package and shipment tracking details
     * @type {TrackingInfo}
     * @memberof TrackingStatus
     */
    'info'?: TrackingInfo | null;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackingStatus
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     * @type {string}
     * @memberof TrackingStatus
     */
    'status'?: TrackingStatusStatusEnum;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof TrackingStatus
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof TrackingStatus
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof TrackingStatus
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     * @type {{ [key: string]: any; }}
     * @memberof TrackingStatus
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingStatus
     */
    'messages'?: Array<Message>;
    /**
     * The shipment invoice URL
     * @type {string}
     * @memberof TrackingStatus
     */
    'delivery_image_url'?: string | null;
    /**
     * The shipment invoice URL
     * @type {string}
     * @memberof TrackingStatus
     */
    'signature_image_url'?: string | null;
}

export const TrackingStatusStatusEnum = {
    Pending: 'pending',
    Unknown: 'unknown',
    OnHold: 'on_hold',
    Delivered: 'delivered',
    InTransit: 'in_transit',
    DeliveryDelayed: 'delivery_delayed',
    OutForDelivery: 'out_for_delivery',
    ReadyForPickup: 'ready_for_pickup',
    DeliveryFailed: 'delivery_failed'
} as const;

export type TrackingStatusStatusEnum = typeof TrackingStatusStatusEnum[keyof typeof TrackingStatusStatusEnum];

/**
 * 
 * @export
 * @interface Ups
 */
export interface Ups {
    /**
     * 
     * @type {string}
     * @memberof Ups
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof Ups
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof Ups
     */
    'account_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ups
     */
    'account_country_code'?: string;
}
/**
 * 
 * @export
 * @interface Usps
 */
export interface Usps {
    /**
     * 
     * @type {string}
     * @memberof Usps
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof Usps
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof Usps
     */
    'account_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Usps
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface UspsInternational
 */
export interface UspsInternational {
    /**
     * 
     * @type {string}
     * @memberof UspsInternational
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof UspsInternational
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof UspsInternational
     */
    'account_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UspsInternational
     */
    'account_number'?: string;
}
/**
 * 
 * @export
 * @interface UspsWt
 */
export interface UspsWt {
    /**
     * 
     * @type {string}
     * @memberof UspsWt
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UspsWt
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UspsWt
     */
    'mailer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UspsWt
     */
    'customer_registration_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UspsWt
     */
    'logistics_manager_mailer_id'?: string;
}
/**
 * 
 * @export
 * @interface UspsWtInternational
 */
export interface UspsWtInternational {
    /**
     * 
     * @type {string}
     * @memberof UspsWtInternational
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UspsWtInternational
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UspsWtInternational
     */
    'mailer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UspsWtInternational
     */
    'customer_registration_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UspsWtInternational
     */
    'logistics_manager_mailer_id'?: string;
}
/**
 * 
 * @export
 * @interface VerifiedTokenObtainPair
 */
export interface VerifiedTokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'access': string;
    /**
     * The OTP (One Time Password) token received by the user from the         configured Two Factor Authentication method.         
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'otp_token': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof Webhook
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof Webhook
     */
    'enabled_events': Array<WebhookEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof Webhook
     */
    'disabled'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Webhook
     */
    'object_type'?: string;
    /**
     * The datetime of the last event sent.
     * @type {string}
     * @memberof Webhook
     */
    'last_event_at'?: string | null;
    /**
     * Header signature secret
     * @type {string}
     * @memberof Webhook
     */
    'secret': string;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Webhook
     */
    'test_mode': boolean;
}

export const WebhookEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookEnabledEventsEnum = typeof WebhookEnabledEventsEnum[keyof typeof WebhookEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookData
 */
export interface WebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookData
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookData
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof WebhookData
     */
    'enabled_events': Array<WebhookDataEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof WebhookData
     */
    'disabled'?: boolean | null;
}

export const WebhookDataEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    ShipmentOutForDelivery: 'shipment_out_for_delivery',
    ShipmentNeedsAttention: 'shipment_needs_attention',
    ShipmentDeliveryFailed: 'shipment_delivery_failed',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookDataEnabledEventsEnum = typeof WebhookDataEnabledEventsEnum[keyof typeof WebhookDataEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     * 
     * @type {number}
     * @memberof WebhookList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'results': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookTestRequest
     */
    'payload': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Zoom2u
 */
export interface Zoom2u {
    /**
     * 
     * @type {string}
     * @memberof Zoom2u
     */
    'api_key': string;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async data(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.data(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.data']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.data(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * 
     * @summary Data References
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public data(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).data(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instance Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public ping(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (addressData: AddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressData' is not null or undefined
            assertParamExists('create', 'addressData', addressData)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedAddressData?: PatchedAddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAddressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(addressData: AddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(addressData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedAddressData?: PatchedAddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedAddressData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressesApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.create(requestParameters.addressData, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<AddressList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedAddressData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in AddressesApi.
 * @export
 * @interface AddressesApiCreateRequest
 */
export interface AddressesApiCreateRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof AddressesApiCreate
     */
    readonly addressData: AddressData
}

/**
 * Request parameters for discard operation in AddressesApi.
 * @export
 * @interface AddressesApiDiscardRequest
 */
export interface AddressesApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in AddressesApi.
 * @export
 * @interface AddressesApiRetrieveRequest
 */
export interface AddressesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in AddressesApi.
 * @export
 * @interface AddressesApiUpdateRequest
 */
export interface AddressesApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedAddressData}
     * @memberof AddressesApiUpdate
     */
    readonly patchedAddressData?: PatchedAddressData
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Create a new address.
     * @summary Create an address
     * @param {AddressesApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).create(requestParameters.addressData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard an address.
     * @summary Discard an address
     * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all addresses.
     * @summary List all addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public list(options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Retrieve an address
     * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an address.
     * @summary Update an address
     * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedAddressData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (tokenObtainPair: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('authenticate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken: async (verifiedTokenObtainPair: VerifiedTokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifiedTokenObtainPair' is not null or undefined
            assertParamExists('getVerifiedToken', 'verifiedTokenObtainPair', verifiedTokenObtainPair)
            const localVarPath = `/api/token/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifiedTokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (tokenRefresh: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('refreshToken', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken: async (tokenVerify: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('verifyToken', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(tokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedToken(verifiedTokenObtainPair: VerifiedTokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerifiedToken(verifiedTokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getVerifiedToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyToken(tokenVerify: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(tokenVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {AuthApiAuthenticateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(requestParameters: AuthApiAuthenticateRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.authenticate(requestParameters.tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {AuthApiGetVerifiedTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken(requestParameters: AuthApiGetVerifiedTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.getVerifiedToken(requestParameters.verifiedTokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.refreshToken(requestParameters.tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {AuthApiVerifyTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken(requestParameters: AuthApiVerifyTokenRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.verifyToken(requestParameters.tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticate operation in AuthApi.
 * @export
 * @interface AuthApiAuthenticateRequest
 */
export interface AuthApiAuthenticateRequest {
    /**
     * 
     * @type {TokenObtainPair}
     * @memberof AuthApiAuthenticate
     */
    readonly tokenObtainPair: TokenObtainPair
}

/**
 * Request parameters for getVerifiedToken operation in AuthApi.
 * @export
 * @interface AuthApiGetVerifiedTokenRequest
 */
export interface AuthApiGetVerifiedTokenRequest {
    /**
     * 
     * @type {VerifiedTokenObtainPair}
     * @memberof AuthApiGetVerifiedToken
     */
    readonly verifiedTokenObtainPair: VerifiedTokenObtainPair
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenRequest
 */
export interface AuthApiRefreshTokenRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof AuthApiRefreshToken
     */
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for verifyToken operation in AuthApi.
 * @export
 * @interface AuthApiVerifyTokenRequest
 */
export interface AuthApiVerifyTokenRequest {
    /**
     * 
     * @type {TokenVerify}
     * @memberof AuthApiVerifyToken
     */
    readonly tokenVerify: TokenVerify
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate the user and return a token pair
     * @summary Obtain auth token pair
     * @param {AuthApiAuthenticateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticate(requestParameters: AuthApiAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticate(requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a verified JWT token pair by submitting a Two-Factor authentication code.
     * @summary Get verified JWT token
     * @param {AuthApiGetVerifiedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getVerifiedToken(requestParameters: AuthApiGetVerifiedTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getVerifiedToken(requestParameters.verifiedTokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate the user and return a token pair
     * @summary Refresh auth token
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify an existent authentication token
     * @summary Verify token
     * @param {AuthApiVerifyTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyToken(requestParameters: AuthApiVerifyTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyToken(requestParameters.tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders: async (batchOrderData: BatchOrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrderData' is not null or undefined
            assertParamExists('createOrders', 'batchOrderData', batchOrderData)
            const localVarPath = `/v1/batches/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchOrderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments: async (batchShipmentData: BatchShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchShipmentData' is not null or undefined
            assertParamExists('createShipments', 'batchShipmentData', batchShipmentData)
            const localVarPath = `/v1/batches/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchShipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers: async (batchTrackerData: BatchTrackerData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchTrackerData' is not null or undefined
            assertParamExists('createTrackers', 'batchTrackerData', batchTrackerData)
            const localVarPath = `/v1/batches/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTrackerData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {ImportFileResourceTypeEnum} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (dataFile?: File, dataTemplate?: string, resourceType?: ImportFileResourceTypeEnum, resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/data/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataFile !== undefined) {
                localVarQueryParameter['data_file'] = dataFile;
            }

            if (dataTemplate !== undefined) {
                localVarQueryParameter['data_template'] = dataTemplate;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }


            if (resourceType2 !== undefined) { 
                localVarFormParams.append('resource_type', resourceType2 as any);
            }
    
            if (dataTemplate2 !== undefined) { 
                localVarFormParams.append('data_template', dataTemplate2 as any);
            }
    
            if (dataFile2 !== undefined) { 
                localVarFormParams.append('data_file', dataFile2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/batches/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrders(batchOrderData: BatchOrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrders(batchOrderData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipments(batchShipmentData: BatchShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipments(batchShipmentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createShipments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackers(batchTrackerData: BatchTrackerData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackers(batchTrackerData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.createTrackers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {ImportFileResourceTypeEnum} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(dataFile?: File, dataTemplate?: string, resourceType?: ImportFileResourceTypeEnum, resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(dataFile, dataTemplate, resourceType, resourceType2, dataTemplate2, dataFile2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.importFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Create order batch. `Beta`
         * @summary Create order batch
         * @param {BatchesApiCreateOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders(requestParameters: BatchesApiCreateOrdersRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createOrders(requestParameters.batchOrderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create shipment batch. `Beta`
         * @summary Create shipment batch
         * @param {BatchesApiCreateShipmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(requestParameters: BatchesApiCreateShipmentsRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createShipments(requestParameters.batchShipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create tracker batch. `Beta`
         * @summary Create tracker batch
         * @param {BatchesApiCreateTrackersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers(requestParameters: BatchesApiCreateTrackersRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.createTrackers(requestParameters.batchTrackerData, options).then((request) => request(axios, basePath));
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {BatchesApiImportFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(requestParameters: BatchesApiImportFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.importFile(requestParameters.dataFile, requestParameters.dataTemplate, requestParameters.resourceType, requestParameters.resourceType2, requestParameters.dataTemplate2, requestParameters.dataFile2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<BatchOperations> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<BatchOperation> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOrders operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateOrdersRequest
 */
export interface BatchesApiCreateOrdersRequest {
    /**
     * 
     * @type {BatchOrderData}
     * @memberof BatchesApiCreateOrders
     */
    readonly batchOrderData: BatchOrderData
}

/**
 * Request parameters for createShipments operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateShipmentsRequest
 */
export interface BatchesApiCreateShipmentsRequest {
    /**
     * 
     * @type {BatchShipmentData}
     * @memberof BatchesApiCreateShipments
     */
    readonly batchShipmentData: BatchShipmentData
}

/**
 * Request parameters for createTrackers operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateTrackersRequest
 */
export interface BatchesApiCreateTrackersRequest {
    /**
     * 
     * @type {BatchTrackerData}
     * @memberof BatchesApiCreateTrackers
     */
    readonly batchTrackerData: BatchTrackerData
}

/**
 * Request parameters for importFile operation in BatchesApi.
 * @export
 * @interface BatchesApiImportFileRequest
 */
export interface BatchesApiImportFileRequest {
    /**
     * 
     * @type {File}
     * @memberof BatchesApiImportFile
     */
    readonly dataFile?: File

    /**
     * A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly dataTemplate?: string

    /**
     * The type of the resource to import
     * @type {'billing' | 'order' | 'shipment' | 'trackers'}
     * @memberof BatchesApiImportFile
     */
    readonly resourceType?: ImportFileResourceTypeEnum

    /**
     * 
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly resourceType2?: string

    /**
     * 
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly dataTemplate2?: string

    /**
     * 
     * @type {File}
     * @memberof BatchesApiImportFile
     */
    readonly dataFile2?: File
}

/**
 * Request parameters for retrieve operation in BatchesApi.
 * @export
 * @interface BatchesApiRetrieveRequest
 */
export interface BatchesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof BatchesApiRetrieve
     */
    readonly id: string
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Create order batch. `Beta`
     * @summary Create order batch
     * @param {BatchesApiCreateOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createOrders(requestParameters: BatchesApiCreateOrdersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createOrders(requestParameters.batchOrderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create shipment batch. `Beta`
     * @summary Create shipment batch
     * @param {BatchesApiCreateShipmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createShipments(requestParameters: BatchesApiCreateShipmentsRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createShipments(requestParameters.batchShipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create tracker batch. `Beta`
     * @summary Create tracker batch
     * @param {BatchesApiCreateTrackersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createTrackers(requestParameters: BatchesApiCreateTrackersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createTrackers(requestParameters.batchTrackerData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
     * @summary Import data files
     * @param {BatchesApiImportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public importFile(requestParameters: BatchesApiImportFileRequest = {}, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).importFile(requestParameters.dataFile, requestParameters.dataTemplate, requestParameters.resourceType, requestParameters.resourceType2, requestParameters.dataTemplate2, requestParameters.dataFile2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all batch operations. `Beta`
     * @summary List all batch operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public list(options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a batch operation. `Beta`
     * @summary Retrieve a batch operation
     * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ImportFileResourceTypeEnum = {
    Billing: 'billing',
    Order: 'order',
    Shipment: 'shipment',
    Trackers: 'trackers'
} as const;
export type ImportFileResourceTypeEnum = typeof ImportFileResourceTypeEnum[keyof typeof ImportFileResourceTypeEnum];


/**
 * CarriersApi - axios parameter creator
 * @export
 */
export const CarriersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (carrierName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getServices', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}/services`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarriersApi - functional programming interface
 * @export
 */
export const CarriersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {string} carrierName The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(carrierName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(carrierName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.getServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarrierDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarriersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CarriersApi - factory interface
 * @export
 */
export const CarriersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarriersApiFp(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getServices(requestParameters.carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<Array<CarrierDetails>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServices operation in CarriersApi.
 * @export
 * @interface CarriersApiGetServicesRequest
 */
export interface CarriersApiGetServicesRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
     * @type {string}
     * @memberof CarriersApiGetServices
     */
    readonly carrierName: string
}

/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
export class CarriersApi extends BaseAPI {
    /**
     * Retrieve a carrier\'s services
     * @summary Get carrier services
     * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getServices(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of configured carriers
     * @summary List all carriers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public list(options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {CarrierConnectionData} carrierConnectionData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (carrierConnectionData: CarrierConnectionData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierConnectionData' is not null or undefined
            assertParamExists('add', 'carrierConnectionData', carrierConnectionData)
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(carrierConnectionData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {boolean} [active] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (active?: boolean, carrierName?: string, metadataKey?: string, metadataValue?: string, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['system_only'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {string} id 
         * @param {PatchedCarrierConnectionData} [patchedCarrierConnectionData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedCarrierConnectionData?: PatchedCarrierConnectionData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCarrierConnectionData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {CarrierConnectionData} carrierConnectionData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(carrierConnectionData: CarrierConnectionData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(carrierConnectionData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.add']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {boolean} [active] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(active?: boolean, carrierName?: string, metadataKey?: string, metadataValue?: string, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(active, carrierName, metadataKey, metadataValue, systemOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {string} id 
         * @param {PatchedCarrierConnectionData} [patchedCarrierConnectionData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedCarrierConnectionData?: PatchedCarrierConnectionData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedCarrierConnectionData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * Add a new carrier connection.
         * @summary Add a carrier connection
         * @param {ConnectionsApiAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(requestParameters: ConnectionsApiAddRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.add(requestParameters.carrierConnectionData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all carrier connections
         * @summary List carrier connections
         * @param {ConnectionsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ConnectionsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CarrierConnectionList> {
            return localVarFp.list(requestParameters.active, requestParameters.carrierName, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.systemOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a carrier connection.
         * @summary Remove a carrier connection
         * @param {ConnectionsApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: ConnectionsApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.remove(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve carrier connection.
         * @summary Retrieve a connection
         * @param {ConnectionsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ConnectionsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a carrier connection.
         * @summary Update a connection
         * @param {ConnectionsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ConnectionsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<CarrierConnection> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedCarrierConnectionData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for add operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiAddRequest
 */
export interface ConnectionsApiAddRequest {
    /**
     * 
     * @type {CarrierConnectionData}
     * @memberof ConnectionsApiAdd
     */
    readonly carrierConnectionData: CarrierConnectionData
}

/**
 * Request parameters for list operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiListRequest
 */
export interface ConnectionsApiListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionsApiList
     */
    readonly active?: boolean

    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
     * @type {string}
     * @memberof ConnectionsApiList
     */
    readonly carrierName?: string

    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiList
     */
    readonly metadataKey?: string

    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiList
     */
    readonly metadataValue?: string

    /**
     * 
     * @type {boolean}
     * @memberof ConnectionsApiList
     */
    readonly systemOnly?: boolean
}

/**
 * Request parameters for remove operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiRemoveRequest
 */
export interface ConnectionsApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiRemove
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiRetrieveRequest
 */
export interface ConnectionsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiUpdateRequest
 */
export interface ConnectionsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedCarrierConnectionData}
     * @memberof ConnectionsApiUpdate
     */
    readonly patchedCarrierConnectionData?: PatchedCarrierConnectionData
}

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * Add a new carrier connection.
     * @summary Add a carrier connection
     * @param {ConnectionsApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public add(requestParameters: ConnectionsApiAddRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).add(requestParameters.carrierConnectionData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all carrier connections
     * @summary List carrier connections
     * @param {ConnectionsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public list(requestParameters: ConnectionsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).list(requestParameters.active, requestParameters.carrierName, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.systemOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a carrier connection.
     * @summary Remove a carrier connection
     * @param {ConnectionsApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public remove(requestParameters: ConnectionsApiRemoveRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve carrier connection.
     * @summary Retrieve a connection
     * @param {ConnectionsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public retrieve(requestParameters: ConnectionsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a carrier connection.
     * @summary Update a connection
     * @param {ConnectionsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public update(requestParameters: ConnectionsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedCarrierConnectionData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentTemplateData} documentTemplateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (documentTemplateData: DocumentTemplateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentTemplateData' is not null or undefined
            assertParamExists('create', 'documentTemplateData', documentTemplateData)
            const localVarPath = `/v1/documents/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentTemplateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentData} [documentData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDocument: async (documentData?: DocumentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpload: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUpload', 'id', id)
            const localVarPath = `/v1/documents/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {string} id 
         * @param {PatchedDocumentTemplateData} [patchedDocumentTemplateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedDocumentTemplateData?: PatchedDocumentTemplateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/documents/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDocumentTemplateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (documentUploadData: DocumentUploadData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentUploadData' is not null or undefined
            assertParamExists('upload', 'documentUploadData', documentUploadData)
            const localVarPath = `/v1/documents/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUploadData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [shipmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploads: async (createdAfter?: string, createdBefore?: string, shipmentId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipment_id'] = shipmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentTemplateData} documentTemplateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(documentTemplateData: DocumentTemplateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(documentTemplateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentData} [documentData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateDocument(documentData?: DocumentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneratedDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateDocument(documentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.generateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpload(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpload(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.retrieveUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {string} id 
         * @param {PatchedDocumentTemplateData} [patchedDocumentTemplateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedDocumentTemplateData?: PatchedDocumentTemplateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedDocumentTemplateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(documentUploadData: DocumentUploadData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(documentUploadData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.upload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [shipmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploads(createdAfter?: string, createdBefore?: string, shipmentId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecords>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploads(createdAfter, createdBefore, shipmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Create a new template.
         * @summary Create a template
         * @param {DocumentsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: DocumentsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.create(requestParameters.documentTemplateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a template.
         * @summary Delete a template
         * @param {DocumentsApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: DocumentsApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
         * @summary Generate a document
         * @param {DocumentsApiGenerateDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDocument(requestParameters: DocumentsApiGenerateDocumentRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GeneratedDocument> {
            return localVarFp.generateDocument(requestParameters.documentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all templates.
         * @summary List all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<DocumentTemplateList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a template.
         * @summary Retrieve a template
         * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve upload record
         * @param {DocumentsApiRetrieveUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpload(requestParameters: DocumentsApiRetrieveUploadRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.retrieveUpload(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a template.
         * @summary Update a template
         * @param {DocumentsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: DocumentsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentTemplate> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedDocumentTemplateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.upload(requestParameters.documentUploadData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {DocumentsApiUploadsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploads(requestParameters: DocumentsApiUploadsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DocumentUploadRecords> {
            return localVarFp.uploads(requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.shipmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in DocumentsApi.
 * @export
 * @interface DocumentsApiCreateRequest
 */
export interface DocumentsApiCreateRequest {
    /**
     * 
     * @type {DocumentTemplateData}
     * @memberof DocumentsApiCreate
     */
    readonly documentTemplateData: DocumentTemplateData
}

/**
 * Request parameters for discard operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDiscardRequest
 */
export interface DocumentsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for generateDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiGenerateDocumentRequest
 */
export interface DocumentsApiGenerateDocumentRequest {
    /**
     * 
     * @type {DocumentData}
     * @memberof DocumentsApiGenerateDocument
     */
    readonly documentData?: DocumentData
}

/**
 * Request parameters for retrieve operation in DocumentsApi.
 * @export
 * @interface DocumentsApiRetrieveRequest
 */
export interface DocumentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for retrieveUpload operation in DocumentsApi.
 * @export
 * @interface DocumentsApiRetrieveUploadRequest
 */
export interface DocumentsApiRetrieveUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiRetrieveUpload
     */
    readonly id: string
}

/**
 * Request parameters for update operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateRequest
 */
export interface DocumentsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedDocumentTemplateData}
     * @memberof DocumentsApiUpdate
     */
    readonly patchedDocumentTemplateData?: PatchedDocumentTemplateData
}

/**
 * Request parameters for upload operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadRequest
 */
export interface DocumentsApiUploadRequest {
    /**
     * 
     * @type {DocumentUploadData}
     * @memberof DocumentsApiUpload
     */
    readonly documentUploadData: DocumentUploadData
}

/**
 * Request parameters for uploads operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadsRequest
 */
export interface DocumentsApiUploadsRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploads
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploads
     */
    readonly createdBefore?: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploads
     */
    readonly shipmentId?: string
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Create a new template.
     * @summary Create a template
     * @param {DocumentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public create(requestParameters: DocumentsApiCreateRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).create(requestParameters.documentTemplateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a template.
     * @summary Delete a template
     * @param {DocumentsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public discard(requestParameters: DocumentsApiDiscardRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate any document. This API is designed to be used to generate GS1 labels, invoices and any document that requires external data.
     * @summary Generate a document
     * @param {DocumentsApiGenerateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public generateDocument(requestParameters: DocumentsApiGenerateDocumentRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).generateDocument(requestParameters.documentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all templates.
     * @summary List all templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public list(options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a template.
     * @summary Retrieve a template
     * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping document upload record.
     * @summary Retrieve upload record
     * @param {DocumentsApiRetrieveUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public retrieveUpload(requestParameters: DocumentsApiRetrieveUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieveUpload(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a template.
     * @summary Update a template
     * @param {DocumentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public update(requestParameters: DocumentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedDocumentTemplateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a shipping document.
     * @summary Upload documents
     * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).upload(requestParameters.documentUploadData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipping document upload records.
     * @summary List all upload records
     * @param {DocumentsApiUploadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploads(requestParameters: DocumentsApiUploadsRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploads(requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManifestsApi - axios parameter creator
 * @export
 */
export const ManifestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestData} manifestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (manifestData: ManifestData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manifestData' is not null or undefined
            assertParamExists('create', 'manifestData', manifestData)
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName?: string, createdAfter?: string, createdBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/manifests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestsApi - functional programming interface
 * @export
 */
export const ManifestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManifestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestData} manifestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(manifestData: ManifestData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(manifestData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName?: string, createdAfter?: string, createdBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, createdAfter, createdBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManifestsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManifestsApi - factory interface
 * @export
 */
export const ManifestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManifestsApiFp(configuration)
    return {
        /**
         * Create a manifest for one or many shipments with labels already purchased.
         * @summary Create a manifest
         * @param {ManifestsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ManifestsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.create(requestParameters.manifestData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all manifests.
         * @summary List manifests
         * @param {ManifestsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ManifestsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ManifestList> {
            return localVarFp.list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping manifest.
         * @summary Retrieve a manifest
         * @param {ManifestsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ManifestsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ManifestsApi.
 * @export
 * @interface ManifestsApiCreateRequest
 */
export interface ManifestsApiCreateRequest {
    /**
     * 
     * @type {ManifestData}
     * @memberof ManifestsApiCreate
     */
    readonly manifestData: ManifestData
}

/**
 * Request parameters for list operation in ManifestsApi.
 * @export
 * @interface ManifestsApiListRequest
 */
export interface ManifestsApiListRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
     * @type {string}
     * @memberof ManifestsApiList
     */
    readonly carrierName?: string

    /**
     * 
     * @type {string}
     * @memberof ManifestsApiList
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof ManifestsApiList
     */
    readonly createdBefore?: string
}

/**
 * Request parameters for retrieve operation in ManifestsApi.
 * @export
 * @interface ManifestsApiRetrieveRequest
 */
export interface ManifestsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ManifestsApiRetrieve
     */
    readonly id: string
}

/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
export class ManifestsApi extends BaseAPI {
    /**
     * Create a manifest for one or many shipments with labels already purchased.
     * @summary Create a manifest
     * @param {ManifestsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public create(requestParameters: ManifestsApiCreateRequest, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).create(requestParameters.manifestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all manifests.
     * @summary List manifests
     * @param {ManifestsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public list(requestParameters: ManifestsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping manifest.
     * @summary Retrieve a manifest
     * @param {ManifestsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public retrieve(requestParameters: ManifestsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ManifestsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (orderData: OrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderData' is not null or undefined
            assertParamExists('create', 'orderData', orderData)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        dismiss: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dismiss', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, orderUpdateData?: OrderUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(orderData: OrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(orderData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async dismiss(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dismiss(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.dismiss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, orderUpdateData?: OrderUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, orderUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {OrdersApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.cancel(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrdersApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.create(requestParameters.orderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss an order from fulfillment.
         * @summary Dismiss an order
         * @param {OrdersApiDismissRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        dismiss(requestParameters: OrdersApiDismissRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.dismiss(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<OrderList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.update(requestParameters.id, requestParameters.orderUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in OrdersApi.
 * @export
 * @interface OrdersApiCancelRequest
 */
export interface OrdersApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateRequest
 */
export interface OrdersApiCreateRequest {
    /**
     * 
     * @type {OrderData}
     * @memberof OrdersApiCreate
     */
    readonly orderData: OrderData
}

/**
 * Request parameters for dismiss operation in OrdersApi.
 * @export
 * @interface OrdersApiDismissRequest
 */
export interface OrdersApiDismissRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiDismiss
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in OrdersApi.
 * @export
 * @interface OrdersApiRetrieveRequest
 */
export interface OrdersApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in OrdersApi.
 * @export
 * @interface OrdersApiUpdateRequest
 */
export interface OrdersApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {OrderUpdateData}
     * @memberof OrdersApiUpdate
     */
    readonly orderUpdateData?: OrderUpdateData
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Cancel an order.
     * @summary Cancel an order
     * @param {OrdersApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order object.
     * @summary Create an order
     * @param {OrdersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).create(requestParameters.orderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss an order from fulfillment.
     * @summary Dismiss an order
     * @param {OrdersApiDismissRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public dismiss(requestParameters: OrdersApiDismissRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).dismiss(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders.
     * @summary List all orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public list(options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an order.
     * @summary Retrieve an order
     * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
     * @summary Update an order
     * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).update(requestParameters.id, requestParameters.orderUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParcelsApi - axios parameter creator
 * @export
 */
export const ParcelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (parcelData: ParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parcelData' is not null or undefined
            assertParamExists('create', 'parcelData', parcelData)
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedParcelData?: PatchedParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedParcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParcelsApi - functional programming interface
 * @export
 */
export const ParcelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParcelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(parcelData: ParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(parcelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.discard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedParcelData?: PatchedParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedParcelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParcelsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParcelsApi - factory interface
 * @export
 */
export const ParcelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParcelsApiFp(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.create(requestParameters.parcelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.discard(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<ParcelList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Parcel> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedParcelData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ParcelsApi.
 * @export
 * @interface ParcelsApiCreateRequest
 */
export interface ParcelsApiCreateRequest {
    /**
     * 
     * @type {ParcelData}
     * @memberof ParcelsApiCreate
     */
    readonly parcelData: ParcelData
}

/**
 * Request parameters for discard operation in ParcelsApi.
 * @export
 * @interface ParcelsApiDiscardRequest
 */
export interface ParcelsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in ParcelsApi.
 * @export
 * @interface ParcelsApiRetrieveRequest
 */
export interface ParcelsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ParcelsApi.
 * @export
 * @interface ParcelsApiUpdateRequest
 */
export interface ParcelsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedParcelData}
     * @memberof ParcelsApiUpdate
     */
    readonly patchedParcelData?: PatchedParcelData
}

/**
 * ParcelsApi - object-oriented interface
 * @export
 * @class ParcelsApi
 * @extends {BaseAPI}
 */
export class ParcelsApi extends BaseAPI {
    /**
     * Create a new parcel.
     * @summary Create a parcel
     * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).create(requestParameters.parcelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a parcel.
     * @summary Remove a parcel
     * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored parcels.
     * @summary List all parcels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public list(options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a parcel.
     * @summary Retrieve a parcel
     * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing parcel\'s details.
     * @summary Update a parcel
     * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedParcelData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PickupsApi - axios parameter creator
 * @export
 */
export const PickupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, pickupCancelData?: PickupCancelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/pickups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule: async (carrierName: string, pickupData: PickupData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedule', 'carrierName', carrierName)
            // verify required parameter 'pickupData' is not null or undefined
            assertParamExists('schedule', 'pickupData', pickupData)
            const localVarPath = `/v1/pickups/{carrier_name}/schedule`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, pickupUpdateData: PickupUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'pickupUpdateData' is not null or undefined
            assertParamExists('update', 'pickupUpdateData', pickupUpdateData)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PickupsApi - functional programming interface
 * @export
 */
export const PickupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PickupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, pickupCancelData?: PickupCancelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, pickupCancelData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedule(carrierName: string, pickupData: PickupData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedule(carrierName, pickupData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.schedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, pickupUpdateData: PickupUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, pickupUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PickupsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PickupsApi - factory interface
 * @export
 */
export const PickupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PickupsApiFp(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {PickupsApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.cancel(requestParameters.id, requestParameters.pickupCancelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<PickupList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.schedule(requestParameters.carrierName, requestParameters.pickupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Pickup> {
            return localVarFp.update(requestParameters.id, requestParameters.pickupUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in PickupsApi.
 * @export
 * @interface PickupsApiCancelRequest
 */
export interface PickupsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiCancel
     */
    readonly id: string

    /**
     * 
     * @type {PickupCancelData}
     * @memberof PickupsApiCancel
     */
    readonly pickupCancelData?: PickupCancelData
}

/**
 * Request parameters for retrieve operation in PickupsApi.
 * @export
 * @interface PickupsApiRetrieveRequest
 */
export interface PickupsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for schedule operation in PickupsApi.
 * @export
 * @interface PickupsApiScheduleRequest
 */
export interface PickupsApiScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiSchedule
     */
    readonly carrierName: string

    /**
     * 
     * @type {PickupData}
     * @memberof PickupsApiSchedule
     */
    readonly pickupData: PickupData
}

/**
 * Request parameters for update operation in PickupsApi.
 * @export
 * @interface PickupsApiUpdateRequest
 */
export interface PickupsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PickupUpdateData}
     * @memberof PickupsApiUpdate
     */
    readonly pickupUpdateData: PickupUpdateData
}

/**
 * PickupsApi - object-oriented interface
 * @export
 * @class PickupsApi
 * @extends {BaseAPI}
 */
export class PickupsApi extends BaseAPI {
    /**
     * Cancel a pickup of one or more shipments.
     * @summary Cancel a pickup
     * @param {PickupsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).cancel(requestParameters.id, requestParameters.pickupCancelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scheduled pickups.
     * @summary List shipment pickups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public list(options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a scheduled pickup.
     * @summary Retrieve a pickup
     * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a pickup for one or many shipments with labels already purchased.
     * @summary Schedule a pickup
     * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).schedule(requestParameters.carrierName, requestParameters.pickupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a pickup for one or many shipments with labels already purchased.
     * @summary Update a pickup
     * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).update(requestParameters.id, requestParameters.pickupUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel: async (shippingRequest: ShippingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingRequest' is not null or undefined
            assertParamExists('buyLabel', 'shippingRequest', shippingRequest)
            const localVarPath = `/v1/proxy/shipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {CancelPickupCarrierNameEnum} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup: async (carrierName: CancelPickupCarrierNameEnum, pickupCancelRequest: PickupCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('cancelPickup', 'carrierName', carrierName)
            // verify required parameter 'pickupCancelRequest' is not null or undefined
            assertParamExists('cancelPickup', 'pickupCancelRequest', pickupCancelRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates: async (rateRequest: RateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateRequest' is not null or undefined
            assertParamExists('fetchRates', 'rateRequest', rateRequest)
            const localVarPath = `/v1/proxy/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ManifestRequest} manifestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateManifest: async (manifestRequest: ManifestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manifestRequest' is not null or undefined
            assertParamExists('generateManifest', 'manifestRequest', manifestRequest)
            const localVarPath = `/v1/proxy/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking: async (trackingData: TrackingData, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('getTracking', 'trackingData', trackingData)
            const localVarPath = `/v1/proxy/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {SchedulePickupCarrierNameEnum} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (carrierName: SchedulePickupCarrierNameEnum, pickupRequest: PickupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedulePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupRequest' is not null or undefined
            assertParamExists('schedulePickup', 'pickupRequest', pickupRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {TrackShipmentCarrierNameEnum} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment: async (carrierName: TrackShipmentCarrierNameEnum, trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('trackShipment', 'carrierName', carrierName)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('trackShipment', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/proxy/tracking/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {UpdatePickupCarrierNameEnum} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup: async (carrierName: UpdatePickupCarrierNameEnum, pickupUpdateRequest: PickupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updatePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupUpdateRequest' is not null or undefined
            assertParamExists('updatePickup', 'pickupUpdateRequest', pickupUpdateRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/update`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {VoidLabelCarrierNameEnum} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (carrierName: VoidLabelCarrierNameEnum, shipmentCancelRequest: ShipmentCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('voidLabel', 'carrierName', carrierName)
            // verify required parameter 'shipmentCancelRequest' is not null or undefined
            assertParamExists('voidLabel', 'shipmentCancelRequest', shipmentCancelRequest)
            const localVarPath = `/v1/proxy/shipping/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buyLabel(shippingRequest: ShippingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buyLabel(shippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.buyLabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {CancelPickupCarrierNameEnum} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPickup(carrierName: CancelPickupCarrierNameEnum, pickupCancelRequest: PickupCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPickup(carrierName, pickupCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.cancelPickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRates(rateRequest: RateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRates(rateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.fetchRates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ManifestRequest} manifestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateManifest(manifestRequest: ManifestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateManifest(manifestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.generateManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTracking(trackingData: TrackingData, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTracking(trackingData, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.getTracking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {SchedulePickupCarrierNameEnum} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(carrierName: SchedulePickupCarrierNameEnum, pickupRequest: PickupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(carrierName, pickupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.schedulePickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {TrackShipmentCarrierNameEnum} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async trackShipment(carrierName: TrackShipmentCarrierNameEnum, trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackShipment(carrierName, trackingNumber, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.trackShipment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {UpdatePickupCarrierNameEnum} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePickup(carrierName: UpdatePickupCarrierNameEnum, pickupUpdateRequest: PickupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePickup(carrierName, pickupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.updatePickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {VoidLabelCarrierNameEnum} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(carrierName: VoidLabelCarrierNameEnum, shipmentCancelRequest: ShipmentCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(carrierName, shipmentCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.voidLabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig): AxiosPromise<ShippingResponse> {
            return localVarFp.buyLabel(requestParameters.shippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.cancelPickup(requestParameters.carrierName, requestParameters.pickupCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig): AxiosPromise<RateResponse> {
            return localVarFp.fetchRates(requestParameters.rateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
         * @summary Create a manifest
         * @param {ProxyApiGenerateManifestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateManifest(requestParameters: ProxyApiGenerateManifestRequest, options?: AxiosRequestConfig): AxiosPromise<ManifestResponse> {
            return localVarFp.generateManifest(requestParameters.manifestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {ProxyApiGetTrackingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking(requestParameters: ProxyApiGetTrackingRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingResponse> {
            return localVarFp.getTracking(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig): AxiosPromise<PickupResponse> {
            return localVarFp.schedulePickup(requestParameters.carrierName, requestParameters.pickupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingResponse> {
            return localVarFp.trackShipment(requestParameters.carrierName, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig): AxiosPromise<PickupResponse> {
            return localVarFp.updatePickup(requestParameters.carrierName, requestParameters.pickupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.voidLabel(requestParameters.carrierName, requestParameters.shipmentCancelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for buyLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiBuyLabelRequest
 */
export interface ProxyApiBuyLabelRequest {
    /**
     * 
     * @type {ShippingRequest}
     * @memberof ProxyApiBuyLabel
     */
    readonly shippingRequest: ShippingRequest
}

/**
 * Request parameters for cancelPickup operation in ProxyApi.
 * @export
 * @interface ProxyApiCancelPickupRequest
 */
export interface ProxyApiCancelPickupRequest {
    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'easypost' | 'easyship' | 'eshipper' | 'fedex' | 'fedex_ws' | 'freightcom' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'sapient' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof ProxyApiCancelPickup
     */
    readonly carrierName: CancelPickupCarrierNameEnum

    /**
     * 
     * @type {PickupCancelRequest}
     * @memberof ProxyApiCancelPickup
     */
    readonly pickupCancelRequest: PickupCancelRequest
}

/**
 * Request parameters for fetchRates operation in ProxyApi.
 * @export
 * @interface ProxyApiFetchRatesRequest
 */
export interface ProxyApiFetchRatesRequest {
    /**
     * 
     * @type {RateRequest}
     * @memberof ProxyApiFetchRates
     */
    readonly rateRequest: RateRequest
}

/**
 * Request parameters for generateManifest operation in ProxyApi.
 * @export
 * @interface ProxyApiGenerateManifestRequest
 */
export interface ProxyApiGenerateManifestRequest {
    /**
     * 
     * @type {ManifestRequest}
     * @memberof ProxyApiGenerateManifest
     */
    readonly manifestRequest: ManifestRequest
}

/**
 * Request parameters for getTracking operation in ProxyApi.
 * @export
 * @interface ProxyApiGetTrackingRequest
 */
export interface ProxyApiGetTrackingRequest {
    /**
     * 
     * @type {TrackingData}
     * @memberof ProxyApiGetTracking
     */
    readonly trackingData: TrackingData

    /**
     * 
     * @type {string}
     * @memberof ProxyApiGetTracking
     */
    readonly hub?: string
}

/**
 * Request parameters for schedulePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiSchedulePickupRequest
 */
export interface ProxyApiSchedulePickupRequest {
    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'easypost' | 'easyship' | 'eshipper' | 'fedex' | 'fedex_ws' | 'freightcom' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'sapient' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof ProxyApiSchedulePickup
     */
    readonly carrierName: SchedulePickupCarrierNameEnum

    /**
     * 
     * @type {PickupRequest}
     * @memberof ProxyApiSchedulePickup
     */
    readonly pickupRequest: PickupRequest
}

/**
 * Request parameters for trackShipment operation in ProxyApi.
 * @export
 * @interface ProxyApiTrackShipmentRequest
 */
export interface ProxyApiTrackShipmentRequest {
    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'fedex' | 'fedex_ws' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof ProxyApiTrackShipment
     */
    readonly carrierName: TrackShipmentCarrierNameEnum

    /**
     * 
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly hub?: string
}

/**
 * Request parameters for updatePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiUpdatePickupRequest
 */
export interface ProxyApiUpdatePickupRequest {
    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'easypost' | 'easyship' | 'eshipper' | 'fedex' | 'fedex_ws' | 'freightcom' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'sapient' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof ProxyApiUpdatePickup
     */
    readonly carrierName: UpdatePickupCarrierNameEnum

    /**
     * 
     * @type {PickupUpdateRequest}
     * @memberof ProxyApiUpdatePickup
     */
    readonly pickupUpdateRequest: PickupUpdateRequest
}

/**
 * Request parameters for voidLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiVoidLabelRequest
 */
export interface ProxyApiVoidLabelRequest {
    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'easypost' | 'easyship' | 'eshipper' | 'fedex' | 'fedex_ws' | 'freightcom' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'sapient' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof ProxyApiVoidLabel
     */
    readonly carrierName: VoidLabelCarrierNameEnum

    /**
     * 
     * @type {ShipmentCancelRequest}
     * @memberof ProxyApiVoidLabel
     */
    readonly shipmentCancelRequest: ShipmentCancelRequest
}

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * @summary Buy a shipment label
     * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).buyLabel(requestParameters.shippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a pickup previously scheduled
     * @summary Cancel a pickup
     * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).cancelPickup(requestParameters.carrierName, requestParameters.pickupCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * @summary Fetch shipment rates
     * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).fetchRates(requestParameters.rateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Some carriers require shipment manifests to be created for pickups and dropoff. Creating a manifest for a shipment also kicks off billing as a commitment or confirmation of the shipment. 
     * @summary Create a manifest
     * @param {ProxyApiGenerateManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public generateManifest(requestParameters: ProxyApiGenerateManifestRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).generateManifest(requestParameters.manifestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Get tracking details
     * @param {ProxyApiGetTrackingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public getTracking(requestParameters: ProxyApiGetTrackingRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).getTracking(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule one or many parcels pickup
     * @summary Schedule a pickup
     * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).schedulePickup(requestParameters.carrierName, requestParameters.pickupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Track a shipment
     * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).trackShipment(requestParameters.carrierName, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a scheduled pickup
     * @summary Update a pickup
     * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).updatePickup(requestParameters.carrierName, requestParameters.pickupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a shipment and the label previously created
     * @summary Void a shipment label
     * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).voidLabel(requestParameters.carrierName, requestParameters.shipmentCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CancelPickupCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type CancelPickupCarrierNameEnum = typeof CancelPickupCarrierNameEnum[keyof typeof CancelPickupCarrierNameEnum];
/**
 * @export
 */
export const SchedulePickupCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type SchedulePickupCarrierNameEnum = typeof SchedulePickupCarrierNameEnum[keyof typeof SchedulePickupCarrierNameEnum];
/**
 * @export
 */
export const TrackShipmentCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type TrackShipmentCarrierNameEnum = typeof TrackShipmentCarrierNameEnum[keyof typeof TrackShipmentCarrierNameEnum];
/**
 * @export
 */
export const UpdatePickupCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type UpdatePickupCarrierNameEnum = typeof UpdatePickupCarrierNameEnum[keyof typeof UpdatePickupCarrierNameEnum];
/**
 * @export
 */
export const VoidLabelCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Easyship: 'easyship',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Sapient: 'sapient',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type VoidLabelCarrierNameEnum = typeof VoidLabelCarrierNameEnum[keyof typeof VoidLabelCarrierNameEnum];


/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/shipments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (shipmentData: ShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentData' is not null or undefined
            assertParamExists('create', 'shipmentData', shipmentData)
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {boolean} [hasManifest] 
         * @param {boolean} [hasTracker] 
         * @param {string} [id] 
         * @param {string} [keyword] 
         * @param {string} [metaKey] 
         * @param {string} [metaValue] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {string} [status] Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (address?: string, carrierName?: string, createdAfter?: string, createdBefore?: string, hasManifest?: boolean, hasTracker?: boolean, id?: string, keyword?: string, metaKey?: string, metaValue?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: string, trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (hasManifest !== undefined) {
                localVarQueryParameter['has_manifest'] = hasManifest;
            }

            if (hasTracker !== undefined) {
                localVarQueryParameter['has_tracker'] = hasTracker;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (metaKey !== undefined) {
                localVarQueryParameter['meta_key'] = metaKey;
            }

            if (metaValue !== undefined) {
                localVarQueryParameter['meta_value'] = metaValue;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (optionKey !== undefined) {
                localVarQueryParameter['option_key'] = optionKey;
            }

            if (optionValue !== undefined) {
                localVarQueryParameter['option_value'] = optionValue;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (id: string, shipmentPurchaseData: ShipmentPurchaseData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchase', 'id', id)
            // verify required parameter 'shipmentPurchaseData' is not null or undefined
            assertParamExists('purchase', 'shipmentPurchaseData', shipmentPurchaseData)
            const localVarPath = `/v1/shipments/{id}/purchase`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentPurchaseData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates: async (id: string, shipmentRateData?: ShipmentRateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rates', 'id', id)
            const localVarPath = `/v1/shipments/{id}/rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentRateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, shipmentUpdateData?: ShipmentUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(shipmentData: ShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(shipmentData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {boolean} [hasManifest] 
         * @param {boolean} [hasTracker] 
         * @param {string} [id] 
         * @param {string} [keyword] 
         * @param {string} [metaKey] 
         * @param {string} [metaValue] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {string} [status] Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(address?: string, carrierName?: string, createdAfter?: string, createdBefore?: string, hasManifest?: boolean, hasTracker?: boolean, id?: string, keyword?: string, metaKey?: string, metaValue?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: string, trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(address, carrierName, createdAfter, createdBefore, hasManifest, hasTracker, id, keyword, metaKey, metaValue, metadataKey, metadataValue, optionKey, optionValue, reference, service, status, trackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(id: string, shipmentPurchaseData: ShipmentPurchaseData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(id, shipmentPurchaseData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.purchase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rates(id: string, shipmentRateData?: ShipmentRateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rates(id, shipmentRateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.rates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, shipmentUpdateData?: ShipmentUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, shipmentUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShipmentsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipmentsApiFp(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.cancel(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.create(requestParameters.shipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {ShipmentsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.list(requestParameters.address, requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.hasManifest, requestParameters.hasTracker, requestParameters.id, requestParameters.keyword, requestParameters.metaKey, requestParameters.metaValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.optionKey, requestParameters.optionValue, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.purchase(requestParameters.id, requestParameters.shipmentPurchaseData, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.rates(requestParameters.id, requestParameters.shipmentRateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Shipment> {
            return localVarFp.update(requestParameters.id, requestParameters.shipmentUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCancelRequest
 */
export interface ShipmentsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCreateRequest
 */
export interface ShipmentsApiCreateRequest {
    /**
     * 
     * @type {ShipmentData}
     * @memberof ShipmentsApiCreate
     */
    readonly shipmentData: ShipmentData
}

/**
 * Request parameters for list operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiListRequest
 */
export interface ShipmentsApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly address?: string

    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly carrierName?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdBefore?: string

    /**
     * 
     * @type {boolean}
     * @memberof ShipmentsApiList
     */
    readonly hasManifest?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ShipmentsApiList
     */
    readonly hasTracker?: boolean

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly keyword?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metaKey?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metaValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataKey?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionKey?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly reference?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly service?: string

    /**
     * Valid shipment status. &lt;br/&gt;Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60;, &#x60;needs_attention&#x60;, &#x60;out_for_delivery&#x60;, &#x60;delivery_failed&#x60;
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly trackingNumber?: string
}

/**
 * Request parameters for purchase operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiPurchaseRequest
 */
export interface ShipmentsApiPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiPurchase
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentPurchaseData}
     * @memberof ShipmentsApiPurchase
     */
    readonly shipmentPurchaseData: ShipmentPurchaseData
}

/**
 * Request parameters for rates operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRatesRequest
 */
export interface ShipmentsApiRatesRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRates
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentRateData}
     * @memberof ShipmentsApiRates
     */
    readonly shipmentRateData?: ShipmentRateData
}

/**
 * Request parameters for retrieve operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRetrieveRequest
 */
export interface ShipmentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiUpdateRequest
 */
export interface ShipmentsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentUpdateData}
     * @memberof ShipmentsApiUpdate
     */
    readonly shipmentUpdateData?: ShipmentUpdateData
}

/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Void a shipment with the associated label.
     * @summary Cancel a shipment
     * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipment instance.
     * @summary Create a shipment
     * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).create(requestParameters.shipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipments.
     * @summary List all shipments
     * @param {ShipmentsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).list(requestParameters.address, requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.hasManifest, requestParameters.hasTracker, requestParameters.id, requestParameters.keyword, requestParameters.metaKey, requestParameters.metaValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.optionKey, requestParameters.optionValue, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select your preferred rates to buy a shipment label.
     * @summary Buy a shipment label
     * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).purchase(requestParameters.id, requestParameters.shipmentPurchaseData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the list of the shipment rates
     * @summary Fetch new shipment rates
     * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).rates(requestParameters.id, requestParameters.shipmentRateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment.
     * @summary Retrieve a shipment
     * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
     * @summary Update a shipment
     * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).update(requestParameters.id, requestParameters.shipmentUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {boolean} [pendingPickup] Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (trackingData: TrackingData, hub?: string, pendingPickup?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('add', 'trackingData', trackingData)
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }

            if (pendingPickup !== undefined) {
                localVarQueryParameter['pending_pickup'] = pendingPickup;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {CreateCarrierNameEnum} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create: async (carrierName: string, carrierName2: CreateCarrierNameEnum, trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('create', 'carrierName', carrierName)
            // verify required parameter 'carrierName2' is not null or undefined
            assertParamExists('create', 'carrierName2', carrierName2)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('create', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/trackers/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName2 !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName2;
            }

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [status] Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName?: string, createdAfter?: string, createdBefore?: string, status?: string, trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('remove', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('retrieve', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {string} idOrTrackingNumber 
         * @param {TrackerUpdateData} [trackerUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (idOrTrackingNumber: string, trackerUpdateData?: TrackerUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('update', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {boolean} [pendingPickup] Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(trackingData: TrackingData, hub?: string, pendingPickup?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(trackingData, hub, pendingPickup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.add']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {CreateCarrierNameEnum} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async create(carrierName: string, carrierName2: CreateCarrierNameEnum, trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(carrierName, carrierName2, trackingNumber, hub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {string} [carrierName] The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [status] Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName?: string, createdAfter?: string, createdBefore?: string, status?: string, trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, createdAfter, createdBefore, status, trackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(idOrTrackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(idOrTrackingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {string} idOrTrackingNumber 
         * @param {TrackerUpdateData} [trackerUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(idOrTrackingNumber: string, trackerUpdateData?: TrackerUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(idOrTrackingNumber, trackerUpdateData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackersApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackersApiAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(requestParameters: TrackersApiAddRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.add(requestParameters.trackingData, requestParameters.hub, requestParameters.pendingPickup, options).then((request) => request(axios, basePath));
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {TrackersApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.create(requestParameters.carrierName, requestParameters.carrierName2, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {TrackersApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TrackerList> {
            return localVarFp.list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.remove(requestParameters.idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {TrackersApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: TrackersApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.retrieve(requestParameters.idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to log requests
         * @summary Update tracker data
         * @param {TrackersApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: TrackersApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingStatus> {
            return localVarFp.update(requestParameters.idOrTrackingNumber, requestParameters.trackerUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for add operation in TrackersApi.
 * @export
 * @interface TrackersApiAddRequest
 */
export interface TrackersApiAddRequest {
    /**
     * 
     * @type {TrackingData}
     * @memberof TrackersApiAdd
     */
    readonly trackingData: TrackingData

    /**
     * 
     * @type {string}
     * @memberof TrackersApiAdd
     */
    readonly hub?: string

    /**
     * Add this flag to add the tracker whether the tracking info exist or not.When the package is eventually picked up, the tracker with capture real time updates.
     * @type {boolean}
     * @memberof TrackersApiAdd
     */
    readonly pendingPickup?: boolean
}

/**
 * Request parameters for create operation in TrackersApi.
 * @export
 * @interface TrackersApiCreateRequest
 */
export interface TrackersApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly carrierName: string

    /**
     * 
     * @type {'allied_express' | 'allied_express_local' | 'amazon_shipping' | 'aramex' | 'asendia_us' | 'australiapost' | 'boxknight' | 'bpost' | 'canadapost' | 'canpar' | 'chronopost' | 'colissimo' | 'dhl_express' | 'dhl_parcel_de' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpd' | 'dpdhl' | 'fedex' | 'fedex_ws' | 'generic' | 'geodis' | 'hay_post' | 'laposte' | 'locate2u' | 'nationex' | 'purolator' | 'roadie' | 'royalmail' | 'seko' | 'sendle' | 'tge' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'usps_wt' | 'usps_wt_international' | 'zoom2u'}
     * @memberof TrackersApiCreate
     */
    readonly carrierName2: CreateCarrierNameEnum

    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly hub?: string
}

/**
 * Request parameters for list operation in TrackersApi.
 * @export
 * @interface TrackersApiListRequest
 */
export interface TrackersApiListRequest {
    /**
     * The unique carrier slug. &lt;br/&gt;Values: &#x60;allied_express&#x60;, &#x60;allied_express_local&#x60;, &#x60;amazon_shipping&#x60;, &#x60;aramex&#x60;, &#x60;asendia_us&#x60;, &#x60;australiapost&#x60;, &#x60;boxknight&#x60;, &#x60;bpost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;colissimo&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_parcel_de&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpd&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;easyship&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;fedex_ws&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;geodis&#x60;, &#x60;hay_post&#x60;, &#x60;laposte&#x60;, &#x60;locate2u&#x60;, &#x60;nationex&#x60;, &#x60;purolator&#x60;, &#x60;roadie&#x60;, &#x60;royalmail&#x60;, &#x60;sapient&#x60;, &#x60;seko&#x60;, &#x60;sendle&#x60;, &#x60;tge&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;usps_wt&#x60;, &#x60;usps_wt_international&#x60;, &#x60;zoom2u&#x60;
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly carrierName?: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdBefore?: string

    /**
     * Valid tracker status. &lt;br/&gt;Values: &#x60;pending&#x60;, &#x60;unknown&#x60;, &#x60;on_hold&#x60;, &#x60;delivered&#x60;, &#x60;in_transit&#x60;, &#x60;delivery_delayed&#x60;, &#x60;out_for_delivery&#x60;, &#x60;ready_for_pickup&#x60;, &#x60;delivery_failed&#x60;
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly trackingNumber?: string
}

/**
 * Request parameters for remove operation in TrackersApi.
 * @export
 * @interface TrackersApiRemoveRequest
 */
export interface TrackersApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRemove
     */
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for retrieve operation in TrackersApi.
 * @export
 * @interface TrackersApiRetrieveRequest
 */
export interface TrackersApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRetrieve
     */
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for update operation in TrackersApi.
 * @export
 * @interface TrackersApiUpdateRequest
 */
export interface TrackersApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiUpdate
     */
    readonly idOrTrackingNumber: string

    /**
     * 
     * @type {TrackerUpdateData}
     * @memberof TrackersApiUpdate
     */
    readonly trackerUpdateData?: TrackerUpdateData
}

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Add a package tracker
     * @param {TrackersApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public add(requestParameters: TrackersApiAddRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).add(requestParameters.trackingData, requestParameters.hub, requestParameters.pendingPickup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Create a package tracker
     * @param {TrackersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).create(requestParameters.carrierName, requestParameters.carrierName2, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipment trackers.
     * @summary List all package trackers
     * @param {TrackersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a package tracker.
     * @summary Discard a package tracker
     * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).remove(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a package tracker
     * @summary Retrieves a package tracker
     * @param {TrackersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public retrieve(requestParameters: TrackersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).retrieve(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to log requests
     * @summary Update tracker data
     * @param {TrackersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public update(requestParameters: TrackersApiUpdateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).update(requestParameters.idOrTrackingNumber, requestParameters.trackerUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateCarrierNameEnum = {
    AlliedExpress: 'allied_express',
    AlliedExpressLocal: 'allied_express_local',
    AmazonShipping: 'amazon_shipping',
    Aramex: 'aramex',
    AsendiaUs: 'asendia_us',
    Australiapost: 'australiapost',
    Boxknight: 'boxknight',
    Bpost: 'bpost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    Colissimo: 'colissimo',
    DhlExpress: 'dhl_express',
    DhlParcelDe: 'dhl_parcel_de',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpd: 'dpd',
    Dpdhl: 'dpdhl',
    Fedex: 'fedex',
    FedexWs: 'fedex_ws',
    Generic: 'generic',
    Geodis: 'geodis',
    HayPost: 'hay_post',
    Laposte: 'laposte',
    Locate2u: 'locate2u',
    Nationex: 'nationex',
    Purolator: 'purolator',
    Roadie: 'roadie',
    Royalmail: 'royalmail',
    Seko: 'seko',
    Sendle: 'sendle',
    Tge: 'tge',
    Tnt: 'tnt',
    Ups: 'ups',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    UspsWt: 'usps_wt',
    UspsWtInternational: 'usps_wt_international',
    Zoom2u: 'zoom2u'
} as const;
export type CreateCarrierNameEnum = typeof CreateCarrierNameEnum[keyof typeof CreateCarrierNameEnum];


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (webhookData: WebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookData' is not null or undefined
            assertParamExists('create', 'webhookData', webhookData)
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, webhookTestRequest: WebhookTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'webhookTestRequest' is not null or undefined
            assertParamExists('test', 'webhookTestRequest', webhookTestRequest)
            const localVarPath = `/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedWebhookData?: PatchedWebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(webhookData: WebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(webhookData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.remove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, webhookTestRequest: WebhookTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, webhookTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedWebhookData?: PatchedWebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedWebhookData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.create(requestParameters.webhookData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: AxiosRequestConfig): AxiosPromise<WebhookList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig): AxiosPromise<Operation> {
            return localVarFp.remove(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {WebhooksApiTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig): AxiosPromise<Operation> {
            return localVarFp.test(requestParameters.id, requestParameters.webhookTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.update(requestParameters.id, requestParameters.patchedWebhookData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in WebhooksApi.
 * @export
 * @interface WebhooksApiCreateRequest
 */
export interface WebhooksApiCreateRequest {
    /**
     * 
     * @type {WebhookData}
     * @memberof WebhooksApiCreate
     */
    readonly webhookData: WebhookData
}

/**
 * Request parameters for remove operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRemoveRequest
 */
export interface WebhooksApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRemove
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRetrieveRequest
 */
export interface WebhooksApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for test operation in WebhooksApi.
 * @export
 * @interface WebhooksApiTestRequest
 */
export interface WebhooksApiTestRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiTest
     */
    readonly id: string

    /**
     * 
     * @type {WebhookTestRequest}
     * @memberof WebhooksApiTest
     */
    readonly webhookTestRequest: WebhookTestRequest
}

/**
 * Request parameters for update operation in WebhooksApi.
 * @export
 * @interface WebhooksApiUpdateRequest
 */
export interface WebhooksApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedWebhookData}
     * @memberof WebhooksApiUpdate
     */
    readonly patchedWebhookData?: PatchedWebhookData
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a webhook
     * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).create(requestParameters.webhookData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhooks.
     * @summary List all webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public list(options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a webhook.
     * @summary Remove a webhook
     * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a webhook.
     * @summary Retrieve a webhook
     * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * test a webhook.
     * @summary Test a webhook
     * @param {WebhooksApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).test(requestParameters.id, requestParameters.webhookTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a webhook.
     * @summary Update a webhook
     * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedWebhookData, options).then((request) => request(this.axios, this.basePath));
    }
}



