import{C as G}from"./codemirror.es-DHj8iR0M.js";import{d as D,i as de,a as w,n as pe,b as $,s as F,t as O,c as C,p as v,e as B,f as Ye,h as Xe,j as _,k as A,l as y,m as U,o as ie,q as Be,r as qe,u as me,v as R,w as ge,x as V,y as Ge,z as Je,G as Qe,A as Ke,B as He,C as We,D as ze,E as Ze,F as se,T as Ee,H as Te,I as Ne,J as xe,K as en,L as nn,M as tn}from"../devtools.js";import{R as ve,P as j}from"./Range.es-C2IfatGm.js";import{ab as c,ag as p,am as I,ae as E,al as N,an as J,ad as rn,bb as sn}from"./globals-D8PkUKNZ.js";import"./loader-circle-CPmrdKrG.js";import"./tabs-CD3r-GU2.js";import"./tooltip-8zu5sLAA.js";import"./embed-karrio-C-TLT-rj.js";import"./textarea-IMUxBBQu.js";function an(e){return e.kind===c.OPERATION_DEFINITION||e.kind===c.FRAGMENT_DEFINITION}function on(e){return e.kind===c.SCHEMA_DEFINITION||q(e)||e.kind===c.DIRECTIVE_DEFINITION}function q(e){return e.kind===c.SCALAR_TYPE_DEFINITION||e.kind===c.OBJECT_TYPE_DEFINITION||e.kind===c.INTERFACE_TYPE_DEFINITION||e.kind===c.UNION_TYPE_DEFINITION||e.kind===c.ENUM_TYPE_DEFINITION||e.kind===c.INPUT_OBJECT_TYPE_DEFINITION}function ln(e){return e.kind===c.SCHEMA_EXTENSION||ye(e)}function ye(e){return e.kind===c.SCALAR_TYPE_EXTENSION||e.kind===c.OBJECT_TYPE_EXTENSION||e.kind===c.INTERFACE_TYPE_EXTENSION||e.kind===c.UNION_TYPE_EXTENSION||e.kind===c.ENUM_TYPE_EXTENSION||e.kind===c.INPUT_OBJECT_TYPE_EXTENSION}function Ie(e){return{Document(t){for(const n of t.definitions)if(!an(n)){const r=n.kind===c.SCHEMA_DEFINITION||n.kind===c.SCHEMA_EXTENSION?"schema":'"'+n.name.value+'"';e.reportError(new p(`The ${r} definition is not executable.`,{nodes:n}))}return!1}}}function un(e){return{Field(t){const n=e.getParentType();if(n&&!e.getFieldDef()){const i=e.getSchema(),s=t.name.value;let o=D("to use an inline fragment on",cn(i,n,s));o===""&&(o=D(fn(n,s))),e.reportError(new p(`Cannot query field "${s}" on type "${n.name}".`+o,{nodes:t}))}}}}function cn(e,t,n){if(!de(t))return[];const r=new Set,i=Object.create(null);for(const o of e.getPossibleTypes(t))if(o.getFields()[n]){r.add(o),i[o.name]=1;for(const a of o.getInterfaces()){var s;a.getFields()[n]&&(r.add(a),i[a.name]=((s=i[a.name])!==null&&s!==void 0?s:0)+1)}}return[...r].sort((o,a)=>{const l=i[a.name]-i[o.name];return l!==0?l:w(o)&&e.isSubType(o,a)?-1:w(a)&&e.isSubType(a,o)?1:pe(o.name,a.name)}).map(o=>o.name)}function fn(e,t){if($(e)||w(e)){const n=Object.keys(e.getFields());return F(t,n)}return[]}function dn(e){return{InlineFragment(t){const n=t.typeCondition;if(n){const r=O(e.getSchema(),n);if(r&&!C(r)){const i=v(n);e.reportError(new p(`Fragment cannot condition on non composite type "${i}".`,{nodes:n}))}}},FragmentDefinition(t){const n=O(e.getSchema(),t.typeCondition);if(n&&!C(n)){const r=v(t.typeCondition);e.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function pn(e){return{...mn(e),Argument(t){const n=e.getArgument(),r=e.getFieldDef(),i=e.getParentType();if(!n&&r&&i){const s=t.name.value,o=r.args.map(l=>l.name),a=F(s,o);e.reportError(new p(`Unknown argument "${s}" on field "${i.name}.${r.name}".`+D(a),{nodes:t}))}}}}function mn(e){const t=Object.create(null),n=e.getSchema(),r=n?n.getDirectives():B;for(const o of r)t[o.name]=o.args.map(a=>a.name);const i=e.getDocument().definitions;for(const o of i)if(o.kind===c.DIRECTIVE_DEFINITION){var s;const a=(s=o.arguments)!==null&&s!==void 0?s:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const f=u.name.value;if(!l.includes(f)){const d=F(f,l);e.reportError(new p(`Unknown argument "${f}" on directive "@${a}".`+D(d),{nodes:u}))}}return!1}}}function he(e){const t=Object.create(null),n=e.getSchema(),r=n?n.getDirectives():B;for(const s of r)t[s.name]=s.locations;const i=e.getDocument().definitions;for(const s of i)s.kind===c.DIRECTIVE_DEFINITION&&(t[s.name.value]=s.locations.map(o=>o.value));return{Directive(s,o,a,l,u){const f=s.name.value,d=t[f];if(!d){e.reportError(new p(`Unknown directive "@${f}".`,{nodes:s}));return}const m=gn(u);m&&!d.includes(m)&&e.reportError(new p(`Directive "@${f}" may not be used on ${m}.`,{nodes:s}))}}}function gn(e){const t=e[e.length-1];switch("kind"in t||I(!1),t.kind){case c.OPERATION_DEFINITION:return En(t.operation);case c.FIELD:return N.FIELD;case c.FRAGMENT_SPREAD:return N.FRAGMENT_SPREAD;case c.INLINE_FRAGMENT:return N.INLINE_FRAGMENT;case c.FRAGMENT_DEFINITION:return N.FRAGMENT_DEFINITION;case c.VARIABLE_DEFINITION:return N.VARIABLE_DEFINITION;case c.SCHEMA_DEFINITION:case c.SCHEMA_EXTENSION:return N.SCHEMA;case c.SCALAR_TYPE_DEFINITION:case c.SCALAR_TYPE_EXTENSION:return N.SCALAR;case c.OBJECT_TYPE_DEFINITION:case c.OBJECT_TYPE_EXTENSION:return N.OBJECT;case c.FIELD_DEFINITION:return N.FIELD_DEFINITION;case c.INTERFACE_TYPE_DEFINITION:case c.INTERFACE_TYPE_EXTENSION:return N.INTERFACE;case c.UNION_TYPE_DEFINITION:case c.UNION_TYPE_EXTENSION:return N.UNION;case c.ENUM_TYPE_DEFINITION:case c.ENUM_TYPE_EXTENSION:return N.ENUM;case c.ENUM_VALUE_DEFINITION:return N.ENUM_VALUE;case c.INPUT_OBJECT_TYPE_DEFINITION:case c.INPUT_OBJECT_TYPE_EXTENSION:return N.INPUT_OBJECT;case c.INPUT_VALUE_DEFINITION:{const n=e[e.length-3];return"kind"in n||I(!1),n.kind===c.INPUT_OBJECT_TYPE_DEFINITION?N.INPUT_FIELD_DEFINITION:N.ARGUMENT_DEFINITION}default:I(!1,"Unexpected kind: "+E(t.kind))}}function En(e){switch(e){case J.QUERY:return N.QUERY;case J.MUTATION:return N.MUTATION;case J.SUBSCRIPTION:return N.SUBSCRIPTION}}function Oe(e){return{FragmentSpread(t){const n=t.name.value;e.getFragment(n)||e.reportError(new p(`Unknown fragment "${n}".`,{nodes:t.name}))}}}function _e(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const s of e.getDocument().definitions)q(s)&&(r[s.name.value]=!0);const i=[...Object.keys(n),...Object.keys(r)];return{NamedType(s,o,a,l,u){const f=s.name.value;if(!n[f]&&!r[f]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&Tn(m);if(g&&ae.includes(f))return;const T=F(f,g?ae.concat(i):i);e.reportError(new p(`Unknown type "${f}".`+D(T),{nodes:s}))}}}}const ae=[...Ye,...Xe].map(e=>e.name);function Tn(e){return"kind"in e&&(on(e)||ln(e))}function Nn(e){let t=0;return{Document(n){t=n.definitions.filter(r=>r.kind===c.OPERATION_DEFINITION).length},OperationDefinition(n){!n.name&&t>1&&e.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:n}))}}}function vn(e){var t,n,r;const i=e.getSchema(),s=(t=(n=(r=i==null?void 0:i.astNode)!==null&&r!==void 0?r:i==null?void 0:i.getQueryType())!==null&&n!==void 0?n:i==null?void 0:i.getMutationType())!==null&&t!==void 0?t:i==null?void 0:i.getSubscriptionType();let o=0;return{SchemaDefinition(a){if(s){e.reportError(new p("Cannot define a new schema within a schema extension.",{nodes:a}));return}o>0&&e.reportError(new p("Must provide only one schema definition.",{nodes:a})),++o}}}const yn=3;function In(e){function t(n,r=Object.create(null),i=0){if(n.kind===c.FRAGMENT_SPREAD){const s=n.name.value;if(r[s]===!0)return!1;const o=e.getFragment(s);if(!o)return!1;try{return r[s]=!0,t(o,r,i)}finally{r[s]=void 0}}if(n.kind===c.FIELD&&(n.name.value==="fields"||n.name.value==="interfaces"||n.name.value==="possibleTypes"||n.name.value==="inputFields")&&(i++,i>=yn))return!0;if("selectionSet"in n&&n.selectionSet){for(const s of n.selectionSet.selections)if(t(s,r,i))return!0}return!1}return{Field(n){if((n.name.value==="__schema"||n.name.value==="__type")&&t(n))return e.reportError(new p("Maximum introspection depth exceeded",{nodes:[n]})),!1}}}function hn(e){const t=Object.create(null),n=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(s){return i(s),!1}};function i(s){if(t[s.name.value])return;const o=s.name.value;t[o]=!0;const a=e.getFragmentSpreads(s.selectionSet);if(a.length!==0){r[o]=n.length;for(const l of a){const u=l.name.value,f=r[u];if(n.push(l),f===void 0){const d=e.getFragment(u);d&&i(d)}else{const d=n.slice(f),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");e.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}n.pop()}r[o]=void 0}}}function On(e){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(n){const r=e.getRecursiveVariableUsages(n);for(const{node:i}of r){const s=i.name.value;t[s]!==!0&&e.reportError(new p(n.name?`Variable "$${s}" is not defined by operation "${n.name.value}".`:`Variable "$${s}" is not defined.`,{nodes:[i,n]}))}}},VariableDefinition(n){t[n.variable.name.value]=!0}}}function be(e){const t=[],n=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return n.push(r),!1},Document:{leave(){const r=Object.create(null);for(const i of t)for(const s of e.getRecursivelyReferencedFragments(i))r[s.name.value]=!0;for(const i of n){const s=i.name.value;r[s]!==!0&&e.reportError(new p(`Fragment "${s}" is never used.`,{nodes:i}))}}}}}function _n(e){let t=[];return{OperationDefinition:{enter(){t=[]},leave(n){const r=Object.create(null),i=e.getRecursiveVariableUsages(n);for(const{node:s}of i)r[s.name.value]=!0;for(const s of t){const o=s.variable.name.value;r[o]!==!0&&e.reportError(new p(n.name?`Variable "$${o}" is never used in operation "${n.name.value}".`:`Variable "$${o}" is never used.`,{nodes:s}))}}},VariableDefinition(n){t.push(n)}}}function x(e){switch(e.kind){case c.OBJECT:return{...e,fields:bn(e.fields)};case c.LIST:return{...e,values:e.values.map(x)};case c.INT:case c.FLOAT:case c.STRING:case c.BOOLEAN:case c.NULL:case c.ENUM:case c.VARIABLE:return e}}function bn(e){return e.map(t=>({...t,value:x(t.value)})).sort((t,n)=>pe(t.name.value,n.name.value))}function De(e){return Array.isArray(e)?e.map(([t,n])=>`subfields "${t}" conflict because `+De(n)).join(" and "):e}function Dn(e){const t=new $e,n=new Cn,r=new Map;return{SelectionSet(i){const s=Sn(e,r,t,n,e.getParentType(),i);for(const[[o,a],l,u]of s){const f=De(a);e.reportError(new p(`Fields "${o}" conflict because ${f}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:l.concat(u)}))}}}}function Sn(e,t,n,r,i,s){const o=[],[a,l]=Y(e,t,i,s);if($n(e,o,t,n,r,a),l.length!==0)for(let u=0;u<l.length;u++){L(e,o,t,n,r,!1,a,l[u]);for(let f=u+1;f<l.length;f++)M(e,o,t,n,r,!1,l[u],l[f])}return o}function L(e,t,n,r,i,s,o,a){if(r.has(o,a,s))return;r.add(o,a,s);const l=e.getFragment(a);if(!l)return;const[u,f]=H(e,n,l);if(o!==u){ee(e,t,n,r,i,s,o,u);for(const d of f)L(e,t,n,r,i,s,o,d)}}function M(e,t,n,r,i,s,o,a){if(o===a||i.has(o,a,s))return;i.add(o,a,s);const l=e.getFragment(o),u=e.getFragment(a);if(!l||!u)return;const[f,d]=H(e,n,l),[m,g]=H(e,n,u);ee(e,t,n,r,i,s,f,m);for(const T of g)M(e,t,n,r,i,s,o,T);for(const T of d)M(e,t,n,r,i,s,T,a)}function wn(e,t,n,r,i,s,o,a,l){const u=[],[f,d]=Y(e,t,s,o),[m,g]=Y(e,t,a,l);ee(e,u,t,n,r,i,f,m);for(const T of g)L(e,u,t,n,r,i,f,T);for(const T of d)L(e,u,t,n,r,i,m,T);for(const T of d)for(const h of g)M(e,u,t,n,r,i,T,h);return u}function $n(e,t,n,r,i,s){for(const[o,a]of Object.entries(s))if(a.length>1)for(let l=0;l<a.length;l++)for(let u=l+1;u<a.length;u++){const f=Se(e,n,r,i,!1,o,a[l],a[u]);f&&t.push(f)}}function ee(e,t,n,r,i,s,o,a){for(const[l,u]of Object.entries(o)){const f=a[l];if(f)for(const d of u)for(const m of f){const g=Se(e,n,r,i,s,l,d,m);g&&t.push(g)}}}function Se(e,t,n,r,i,s,o,a){const[l,u,f]=o,[d,m,g]=a,T=i||l!==d&&$(l)&&$(d);if(!T){const k=u.name.value,re=m.name.value;if(k!==re)return[[s,`"${k}" and "${re}" are different fields`],[u],[m]];if(!Rn(u,m))return[[s,"they have differing arguments"],[u],[m]]}const h=f==null?void 0:f.type,P=g==null?void 0:g.type;if(h&&P&&K(h,P))return[[s,`they return conflicting types "${E(h)}" and "${E(P)}"`],[u],[m]];const ne=u.selectionSet,te=m.selectionSet;if(ne&&te){const k=wn(e,t,n,r,T,_(h),ne,_(P),te);return Fn(k,s,u,m)}}function Rn(e,t){const n=e.arguments,r=t.arguments;if(n===void 0||n.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||n.length!==r.length)return!1;const i=new Map(r.map(({name:s,value:o})=>[s.value,o]));return n.every(s=>{const o=s.value,a=i.get(s.name.value);return a===void 0?!1:oe(o)===oe(a)})}function oe(e){return v(x(e))}function K(e,t){return A(e)?A(t)?K(e.ofType,t.ofType):!0:A(t)?!0:y(e)?y(t)?K(e.ofType,t.ofType):!0:y(t)?!0:U(e)||U(t)?e!==t:!1}function Y(e,t,n,r){const i=t.get(r);if(i)return i;const s=Object.create(null),o=Object.create(null);we(e,n,r,s,o);const a=[s,Object.keys(o)];return t.set(r,a),a}function H(e,t,n){const r=t.get(n.selectionSet);if(r)return r;const i=O(e.getSchema(),n.typeCondition);return Y(e,t,i,n.selectionSet)}function we(e,t,n,r,i){for(const s of n.selections)switch(s.kind){case c.FIELD:{const o=s.name.value;let a;($(t)||w(t))&&(a=t.getFields()[o]);const l=s.alias?s.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,s,a]);break}case c.FRAGMENT_SPREAD:i[s.name.value]=!0;break;case c.INLINE_FRAGMENT:{const o=s.typeCondition,a=o?O(e.getSchema(),o):t;we(e,a,s.selectionSet,r,i);break}}}function Fn(e,t,n,r){if(e.length>0)return[[t,e.map(([i])=>i)],[n,...e.map(([,i])=>i).flat()],[r,...e.map(([,,i])=>i).flat()]]}class $e{constructor(){this._data=new Map}has(t,n,r){var i;const s=(i=this._data.get(t))===null||i===void 0?void 0:i.get(n);return s===void 0?!1:r?!0:r===s}add(t,n,r){const i=this._data.get(t);i===void 0?this._data.set(t,new Map([[n,r]])):i.set(n,r)}}class Cn{constructor(){this._orderedPairSet=new $e}has(t,n,r){return t<n?this._orderedPairSet.has(t,n,r):this._orderedPairSet.has(n,t,r)}add(t,n,r){t<n?this._orderedPairSet.add(t,n,r):this._orderedPairSet.add(n,t,r)}}function Pn(e){return{InlineFragment(t){const n=e.getType(),r=e.getParentType();if(C(n)&&C(r)&&!ie(e.getSchema(),n,r)){const i=E(r),s=E(n);e.reportError(new p(`Fragment cannot be spread here as objects of type "${i}" can never be of type "${s}".`,{nodes:t}))}},FragmentSpread(t){const n=t.name.value,r=kn(e,n),i=e.getParentType();if(r&&i&&!ie(e.getSchema(),r,i)){const s=E(i),o=E(r);e.reportError(new p(`Fragment "${n}" cannot be spread here as objects of type "${s}" can never be of type "${o}".`,{nodes:t}))}}}}function kn(e,t){const n=e.getFragment(t);if(n){const r=O(e.getSchema(),n.typeCondition);if(C(r))return r}}function An(e){const t=e.getSchema(),n=Object.create(null);for(const i of e.getDocument().definitions)q(i)&&(n[i.name.value]=i);return{ScalarTypeExtension:r,ObjectTypeExtension:r,InterfaceTypeExtension:r,UnionTypeExtension:r,EnumTypeExtension:r,InputObjectTypeExtension:r};function r(i){const s=i.name.value,o=n[s],a=t==null?void 0:t.getType(s);let l;if(o?l=Un[o.kind]:a&&(l=Vn(a)),l){if(l!==i.kind){const u=jn(i.kind);e.reportError(new p(`Cannot extend non-${u} type "${s}".`,{nodes:o?[o,i]:i}))}}else{const u=Object.keys({...n,...t==null?void 0:t.getTypeMap()}),f=F(s,u);e.reportError(new p(`Cannot extend type "${s}" because it is not defined.`+D(f),{nodes:i.name}))}}}const Un={[c.SCALAR_TYPE_DEFINITION]:c.SCALAR_TYPE_EXTENSION,[c.OBJECT_TYPE_DEFINITION]:c.OBJECT_TYPE_EXTENSION,[c.INTERFACE_TYPE_DEFINITION]:c.INTERFACE_TYPE_EXTENSION,[c.UNION_TYPE_DEFINITION]:c.UNION_TYPE_EXTENSION,[c.ENUM_TYPE_DEFINITION]:c.ENUM_TYPE_EXTENSION,[c.INPUT_OBJECT_TYPE_DEFINITION]:c.INPUT_OBJECT_TYPE_EXTENSION};function Vn(e){if(Be(e))return c.SCALAR_TYPE_EXTENSION;if($(e))return c.OBJECT_TYPE_EXTENSION;if(w(e))return c.INTERFACE_TYPE_EXTENSION;if(qe(e))return c.UNION_TYPE_EXTENSION;if(me(e))return c.ENUM_TYPE_EXTENSION;if(R(e))return c.INPUT_OBJECT_TYPE_EXTENSION;I(!1,"Unexpected type: "+E(e))}function jn(e){switch(e){case c.SCALAR_TYPE_EXTENSION:return"scalar";case c.OBJECT_TYPE_EXTENSION:return"object";case c.INTERFACE_TYPE_EXTENSION:return"interface";case c.UNION_TYPE_EXTENSION:return"union";case c.ENUM_TYPE_EXTENSION:return"enum";case c.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:I(!1,"Unexpected kind: "+E(e))}}function Ln(e){return{...Mn(e),Field:{leave(t){var n;const r=e.getFieldDef();if(!r)return!1;const i=new Set((n=t.arguments)===null||n===void 0?void 0:n.map(s=>s.name.value));for(const s of r.args)if(!i.has(s.name)&&ge(s)){const o=E(s.type);e.reportError(new p(`Field "${r.name}" argument "${s.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function Mn(e){var t;const n=Object.create(null),r=e.getSchema(),i=(t=r==null?void 0:r.getDirectives())!==null&&t!==void 0?t:B;for(const a of i)n[a.name]=V(a.args.filter(ge),l=>l.name);const s=e.getDocument().definitions;for(const a of s)if(a.kind===c.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];n[a.name.value]=V(l.filter(Yn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=n[l];if(u){var f;const d=(f=a.arguments)!==null&&f!==void 0?f:[],m=new Set(d.map(g=>g.name.value));for(const[g,T]of Object.entries(u))if(!m.has(g)){const h=Ge(T.type)?E(T.type):v(T.type);e.reportError(new p(`Directive "@${l}" argument "${g}" of type "${h}" is required, but it was not provided.`,{nodes:a}))}}}}}}function Yn(e){return e.type.kind===c.NON_NULL_TYPE&&e.defaultValue==null}function Xn(e){return{Field(t){const n=e.getType(),r=t.selectionSet;if(n)if(U(_(n))){if(r){const i=t.name.value,s=E(n);e.reportError(new p(`Field "${i}" must not have a selection since type "${s}" has no subfields.`,{nodes:r}))}}else if(r){if(r.selections.length===0){const i=t.name.value,s=E(n);e.reportError(new p(`Field "${i}" of type "${s}" must have at least one field selected.`,{nodes:t}))}}else{const i=t.name.value,s=E(n);e.reportError(new p(`Field "${i}" of type "${s}" must have a selection of subfields. Did you mean "${i} { ... }"?`,{nodes:t}))}}}}function Bn(e,t,n){var r;const i={},s=(r=t.arguments)!==null&&r!==void 0?r:[],o=V(s,a=>a.name.value);for(const a of e.args){const l=a.name,u=a.type,f=o[l];if(!f){if(a.defaultValue!==void 0)i[l]=a.defaultValue;else if(y(u))throw new p(`Argument "${l}" of required type "${E(u)}" was not provided.`,{nodes:t});continue}const d=f.value;let m=d.kind===c.NULL;if(d.kind===c.VARIABLE){const T=d.name.value;if(n==null||!qn(n,T)){if(a.defaultValue!==void 0)i[l]=a.defaultValue;else if(y(u))throw new p(`Argument "${l}" of required type "${E(u)}" was provided the variable "$${T}" which was not provided a runtime value.`,{nodes:d});continue}m=n[T]==null}if(m&&y(u))throw new p(`Argument "${l}" of non-null type "${E(u)}" must not be null.`,{nodes:d});const g=Je(d,u,n);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${v(d)}.`,{nodes:d});i[l]=g}return i}function le(e,t,n){var r;const i=(r=t.directives)===null||r===void 0?void 0:r.find(s=>s.name.value===e.name);if(i)return Bn(e,i,n)}function qn(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function Gn(e,t,n,r,i){const s=new Map;return W(e,t,n,r,i,s,new Set),s}function W(e,t,n,r,i,s,o){for(const a of i.selections)switch(a.kind){case c.FIELD:{if(!Q(n,a))continue;const l=Jn(a),u=s.get(l);u!==void 0?u.push(a):s.set(l,[a]);break}case c.INLINE_FRAGMENT:{if(!Q(n,a)||!ue(e,a,r))continue;W(e,t,n,r,a.selectionSet,s,o);break}case c.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!Q(n,a))continue;o.add(l);const u=t[l];if(!u||!ue(e,u,r))continue;W(e,t,n,r,u.selectionSet,s,o);break}}}function Q(e,t){const n=le(Qe,t,e);if((n==null?void 0:n.if)===!0)return!1;const r=le(Ke,t,e);return(r==null?void 0:r.if)!==!1}function ue(e,t,n){const r=t.typeCondition;if(!r)return!0;const i=O(e,r);return i===n?!0:de(i)?e.isSubType(i,n):!1}function Jn(e){return e.alias?e.alias.value:e.name.value}function Qn(e){return{OperationDefinition(t){if(t.operation==="subscription"){const n=e.getSchema(),r=n.getSubscriptionType();if(r){const i=t.name?t.name.value:null,s=Object.create(null),o=e.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===c.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=Gn(n,a,s,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();e.reportError(new p(i!=null?`Subscription "${i}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&e.reportError(new p(i!=null?`Subscription "${i}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function Re(e,t){const n=new Map;for(const r of e){const i=t(r),s=n.get(i);s===void 0?n.set(i,[r]):s.push(r)}return n}function Fe(e){return{Field:t,Directive:t};function t(n){var r;const i=(r=n.arguments)!==null&&r!==void 0?r:[],s=Re(i,o=>o.name.value);for(const[o,a]of s)a.length>1&&e.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Kn(e){const t=Object.create(null),n=e.getSchema();return{DirectiveDefinition(r){const i=r.name.value;if(n!=null&&n.getDirective(i)){e.reportError(new p(`Directive "@${i}" already exists in the schema. It cannot be redefined.`,{nodes:r.name}));return}return t[i]?e.reportError(new p(`There can be only one directive named "@${i}".`,{nodes:[t[i],r.name]})):t[i]=r.name,!1}}}function Ce(e){const t=Object.create(null),n=e.getSchema(),r=n?n.getDirectives():B;for(const a of r)t[a.name]=!a.isRepeatable;const i=e.getDocument().definitions;for(const a of i)a.kind===c.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const s=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===c.SCHEMA_DEFINITION||a.kind===c.SCHEMA_EXTENSION)l=s;else if(q(a)||ye(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const f=u.name.value;t[f]&&(l[f]?e.reportError(new p(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],u]})):l[f]=u)}}}}function Hn(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),r=Object.create(null);return{EnumTypeDefinition:i,EnumTypeExtension:i};function i(s){var o;const a=s.name.value;r[a]||(r[a]=Object.create(null));const l=(o=s.values)!==null&&o!==void 0?o:[],u=r[a];for(const f of l){const d=f.name.value,m=n[a];me(m)&&m.getValue(d)?e.reportError(new p(`Enum value "${a}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):u[d]?e.reportError(new p(`Enum value "${a}.${d}" can only be defined once.`,{nodes:[u[d],f.name]})):u[d]=f.name}return!1}}function Wn(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),r=Object.create(null);return{InputObjectTypeDefinition:i,InputObjectTypeExtension:i,InterfaceTypeDefinition:i,InterfaceTypeExtension:i,ObjectTypeDefinition:i,ObjectTypeExtension:i};function i(s){var o;const a=s.name.value;r[a]||(r[a]=Object.create(null));const l=(o=s.fields)!==null&&o!==void 0?o:[],u=r[a];for(const f of l){const d=f.name.value;zn(n[a],d)?e.reportError(new p(`Field "${a}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):u[d]?e.reportError(new p(`Field "${a}.${d}" can only be defined once.`,{nodes:[u[d],f.name]})):u[d]=f.name}return!1}}function zn(e,t){return $(e)||w(e)||R(e)?e.getFields()[t]!=null:!1}function Zn(e){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(n){const r=n.name.value;return t[r]?e.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],n.name]})):t[r]=n.name,!1}}}function Pe(e){const t=[];let n=Object.create(null);return{ObjectValue:{enter(){t.push(n),n=Object.create(null)},leave(){const r=t.pop();r||I(!1),n=r}},ObjectField(r){const i=r.name.value;n[i]?e.reportError(new p(`There can be only one input field named "${i}".`,{nodes:[n[i],r.name]})):n[i]=r.name}}}function xn(e){const t=Object.create(null);return{OperationDefinition(n){const r=n.name;return r&&(t[r.value]?e.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function et(e){const t=e.getSchema(),n=Object.create(null),r=t?{query:t.getQueryType(),mutation:t.getMutationType(),subscription:t.getSubscriptionType()}:{};return{SchemaDefinition:i,SchemaExtension:i};function i(s){var o;const a=(o=s.operationTypes)!==null&&o!==void 0?o:[];for(const l of a){const u=l.operation,f=n[u];r[u]?e.reportError(new p(`Type for ${u} already defined in the schema. It cannot be redefined.`,{nodes:l})):f?e.reportError(new p(`There can be only one ${u} type in schema.`,{nodes:[f,l]})):n[u]=l}return!1}}function nt(e){const t=Object.create(null),n=e.getSchema();return{ScalarTypeDefinition:r,ObjectTypeDefinition:r,InterfaceTypeDefinition:r,UnionTypeDefinition:r,EnumTypeDefinition:r,InputObjectTypeDefinition:r};function r(i){const s=i.name.value;if(n!=null&&n.getType(s)){e.reportError(new p(`Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:i.name}));return}return t[s]?e.reportError(new p(`There can be only one type named "${s}".`,{nodes:[t[s],i.name]})):t[s]=i.name,!1}}function tt(e){return{OperationDefinition(t){var n;const r=(n=t.variableDefinitions)!==null&&n!==void 0?n:[],i=Re(r,s=>s.variable.name.value);for(const[s,o]of i)o.length>1&&e.reportError(new p(`There can be only one variable named "$${s}".`,{nodes:o.map(a=>a.variable.name)}))}}}function rt(e){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(n){t[n.variable.name.value]=n},ListValue(n){const r=We(e.getParentInputType());if(!A(r))return b(e,n),!1},ObjectValue(n){const r=_(e.getInputType());if(!R(r))return b(e,n),!1;const i=V(n.fields,s=>s.name.value);for(const s of Object.values(r.getFields()))if(!i[s.name]&&He(s)){const a=E(s.type);e.reportError(new p(`Field "${r.name}.${s.name}" of required type "${a}" was not provided.`,{nodes:n}))}r.isOneOf&&it(e,n,r,i)},ObjectField(n){const r=_(e.getParentInputType());if(!e.getInputType()&&R(r)){const s=F(n.name.value,Object.keys(r.getFields()));e.reportError(new p(`Field "${n.name.value}" is not defined by type "${r.name}".`+D(s),{nodes:n}))}},NullValue(n){const r=e.getInputType();y(r)&&e.reportError(new p(`Expected value of type "${E(r)}", found ${v(n)}.`,{nodes:n}))},EnumValue:n=>b(e,n),IntValue:n=>b(e,n),FloatValue:n=>b(e,n),StringValue:n=>b(e,n),BooleanValue:n=>b(e,n)}}function b(e,t){const n=e.getInputType();if(!n)return;const r=_(n);if(!U(r)){const i=E(n);e.reportError(new p(`Expected value of type "${i}", found ${v(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const s=E(n);e.reportError(new p(`Expected value of type "${s}", found ${v(t)}.`,{nodes:t}))}}catch(i){const s=E(n);i instanceof p?e.reportError(i):e.reportError(new p(`Expected value of type "${s}", found ${v(t)}; `+i.message,{nodes:t,originalError:i}))}}function it(e,t,n,r){var i;const s=Object.keys(r);if(s.length!==1){e.reportError(new p(`OneOf Input Object "${n.name}" must specify exactly one key.`,{nodes:[t]}));return}const a=(i=r[s[0]])===null||i===void 0?void 0:i.value;(!a||a.kind===c.NULL)&&e.reportError(new p(`Field "${n.name}.${s[0]}" must be non-null.`,{nodes:[t]}))}function st(e){return{VariableDefinition(t){const n=O(e.getSchema(),t.type);if(n!==void 0&&!ze(n)){const r=t.variable.name.value,i=v(t.type);e.reportError(new p(`Variable "$${r}" cannot be non-input type "${i}".`,{nodes:t.type}))}}}}function at(e){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(n){const r=e.getRecursiveVariableUsages(n);for(const{node:i,type:s,defaultValue:o,parentType:a}of r){const l=i.name.value,u=t[l];if(u&&s){const f=e.getSchema(),d=O(f,u.type);if(d&&!ot(f,d,u.defaultValue,s,o)){const m=E(d),g=E(s);e.reportError(new p(`Variable "$${l}" of type "${m}" used in position expecting type "${g}".`,{nodes:[u,i]}))}R(a)&&a.isOneOf&&Ze(d)&&e.reportError(new p(`Variable "$${l}" is of type "${d}" but must be non-nullable to be used for OneOf Input Object "${a}".`,{nodes:[u,i]}))}}}},VariableDefinition(n){t[n.variable.name.value]=n}}}function ot(e,t,n,r,i){if(y(r)&&!y(t)){if(!(n!=null&&n.kind!==c.NULL)&&!(i!==void 0))return!1;const a=r.ofType;return se(e,t,a)}return se(e,t,r)}const lt=Object.freeze([In]),ke=Object.freeze([Ie,xn,Nn,Qn,_e,dn,st,Xn,un,Zn,Oe,be,Pn,hn,tt,On,_n,he,Ce,pn,Fe,rt,Ln,at,Dn,Pe,...lt]);class ut{constructor(t,n){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=n}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let n;if(this._fragments)n=this._fragments;else{n=Object.create(null);for(const r of this.getDocument().definitions)r.kind===c.FRAGMENT_DEFINITION&&(n[r.name.value]=r);this._fragments=n}return n[t]}getFragmentSpreads(t){let n=this._fragmentSpreads.get(t);if(!n){n=[];const r=[t];let i;for(;i=r.pop();)for(const s of i.selections)s.kind===c.FRAGMENT_SPREAD?n.push(s):s.selectionSet&&r.push(s.selectionSet);this._fragmentSpreads.set(t,n)}return n}getRecursivelyReferencedFragments(t){let n=this._recursivelyReferencedFragments.get(t);if(!n){n=[];const r=Object.create(null),i=[t.selectionSet];let s;for(;s=i.pop();)for(const o of this.getFragmentSpreads(s)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(n.push(l),i.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,n)}return n}}class ct extends ut{constructor(t,n,r,i){super(n,i),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let n=this._variableUsages.get(t);if(!n){const r=[],i=new Ee(this._schema);Te(t,Ne(i,{VariableDefinition:()=>!1,Variable(s){r.push({node:s,type:i.getInputType(),defaultValue:i.getDefaultValue(),parentType:i.getParentInputType()})}})),n=r,this._variableUsages.set(t,n)}return n}getRecursiveVariableUsages(t){let n=this._recursiveVariableUsages.get(t);if(!n){n=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))n=n.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,n)}return n}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Ae(e,t,n=ke,r,i=new Ee(e)){var s;const o=(s=void 0)!==null&&s!==void 0?s:100;t||rn(!1,"Must provide document."),xe(e);const a=Object.freeze({}),l=[],u=new ct(e,t,i,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),f=en(n.map(d=>d(u)));try{Te(t,Ne(i,f))}catch(d){if(d!==a)throw d}return l}function ft(e){return{Field(t){const n=e.getFieldDef(),r=n==null?void 0:n.deprecationReason;if(n&&r!=null){const i=e.getParentType();i!=null||I(!1),e.reportError(new p(`The field ${i.name}.${n.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const n=e.getArgument(),r=n==null?void 0:n.deprecationReason;if(n&&r!=null){const i=e.getDirective();if(i!=null)e.reportError(new p(`Directive "@${i.name}" argument "${n.name}" is deprecated. ${r}`,{nodes:t}));else{const s=e.getParentType(),o=e.getFieldDef();s!=null&&o!=null||I(!1),e.reportError(new p(`Field "${s.name}.${o.name}" argument "${n.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const n=_(e.getParentInputType());if(R(n)){const r=n.getFields()[t.name.value],i=r==null?void 0:r.deprecationReason;i!=null&&e.reportError(new p(`The input field ${n.name}.${r.name} is deprecated. ${i}`,{nodes:t}))}},EnumValue(t){const n=e.getEnumValue(),r=n==null?void 0:n.deprecationReason;if(n&&r!=null){const i=_(e.getInputType());i!=null||I(!1),e.reportError(new p(`The enum value "${i.name}.${n.name}" is deprecated. ${r}`,{nodes:t}))}}}}var dt=Object.defineProperty,S=(e,t)=>dt(e,"name",{value:t,configurable:!0});const pt=[vn,et,nt,Hn,Wn,Kn,_e,he,Ce,An,Fe,Pe];function Ue(e,t,n,r,i){const s=ke.filter(a=>!(a===be||a===Ie||r&&a===Oe));return n&&Array.prototype.push.apply(s,n),i&&Array.prototype.push.apply(s,pt),Ae(e,t,s).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===c.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}S(Ue,"validateWithCustomRules");const ce={Error:"Error",Warning:"Warning"},z={[ce.Error]:1,[ce.Warning]:2},X=S((e,t)=>{if(!e)throw new Error(t)},"invariant");function Ve(e,t=null,n,r,i){var s,o;let a=null,l="";i&&(l=typeof i=="string"?i:i.reduce((f,d)=>f+v(d)+`

`,""));const u=l?`${e}

${l}`:e;try{a=sn(u)}catch(f){if(f instanceof p){const d=Le((o=(s=f.locations)===null||s===void 0?void 0:s[0])!==null&&o!==void 0?o:{line:0},u);return[{severity:z.Error,message:f.message,source:"GraphQL: Syntax",range:d}]}throw f}return je(a,t,n,r)}S(Ve,"getDiagnostics");function je(e,t=null,n,r){if(!t)return[];const i=Ue(t,e,n,r).flatMap(o=>Z(o,z.Error,"Validation")),s=Ae(t,e,[ft]).flatMap(o=>Z(o,z.Warning,"Deprecation"));return i.concat(s)}S(je,"validateQuery");function Z(e,t,n){if(!e.nodes)return[];const r=[];for(const[i,s]of e.nodes.entries()){const o=s.kind!=="Variable"&&"name"in s&&s.name!==void 0?s.name:"variable"in s&&s.variable!==void 0?s.variable:s;if(o){X(e.locations,"GraphQL validation error requires locations.");const a=e.locations[i],l=Me(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${n}`,message:e.message,severity:t,range:new ve(new j(a.line-1,a.column-1),new j(a.line-1,u))})}}return r}S(Z,"annotations");function Le(e,t){const n=nn(),r=n.startState(),i=t.split(`
`);X(i.length>=e.line,"Query text must have more lines than where the error happened");let s=null;for(let u=0;u<e.line;u++)for(s=new tn(i[u]);!s.eol()&&n.token(s,r)!=="invalidchar";);X(s,"Expected Parser stream to be available.");const o=e.line-1,a=s.getStartOfToken(),l=s.getCurrentPosition();return new ve(new j(o,a),new j(o,l))}S(Le,"getRange");function Me(e){const n=e.loc;return X(n,"Expected ASTNode to have a location."),n}S(Me,"getLocation");const fe=["error","warning","information","hint"],mt={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};G.registerHelper("lint","graphql",(e,t)=>{const{schema:n,validationRules:r,externalFragments:i}=t;return Ve(e,n,r,void 0,i).map(a=>({message:a.message,severity:a.severity?fe[a.severity-1]:fe[0],type:a.source?mt[a.source]:void 0,from:G.Pos(a.range.start.line,a.range.start.character),to:G.Pos(a.range.end.line,a.range.end.character)}))});
