#!/usr/bin/env bash

# This script generates source requirements files from the build requirements files
# It converts -e ./path/to/package to package_name @ file://${PWD}/path/to/package

# Function to convert path to package name
path_to_package_name() {
    local path="$1"
    local basename=$(basename "$path")

    # Convert underscores and hyphens appropriately
    # Most karrio packages use underscores in path but package name might differ
    echo "$basename" | sed 's/-/_/g'
}

# Function to generate source requirements file
generate_source_requirements() {
    local input_file=$1
    local output_file=$2

    echo "Generating ${output_file}..."

    # Create a temporary file
    TMP_FILE=$(mktemp)

    # Copy the header (--extra-index-url line)
    grep "^--extra-index" "$input_file" > "$TMP_FILE" || echo "--extra-index-url https://karrio.gateway.scarf.sh/simple/?sourceBuild" > "$TMP_FILE"

    # Process each line
    while IFS= read -r line; do
        if [[ $line == -e\ ./* ]]; then
            # Extract path from -e ./path
            path="${line#-e }"
            path="${path#./}"

            # Determine package name from path
            if [[ $path =~ karrio/modules/sdk ]]; then
                pkg_name="karrio"
            elif [[ $path =~ karrio/modules/connectors/([^/]+) ]]; then
                connector="${BASH_REMATCH[1]}"
                pkg_name="karrio_${connector}"
            elif [[ $path =~ karrio/community/plugins/([^/]+) ]]; then
                plugin="${BASH_REMATCH[1]}"
                pkg_name="karrio_${plugin}"
            elif [[ $path =~ karrio/modules/core ]]; then
                pkg_name="karrio_server_core"
            elif [[ $path =~ karrio/apps/api ]]; then
                pkg_name="karrio_server"
            elif [[ $path =~ karrio/modules/([^/]+) ]]; then
                module="${BASH_REMATCH[1]}"
                pkg_name="karrio_server_${module}"
            else
                # Fallback: use directory name
                pkg_name=$(basename "$path")
            fi

            # Write the file:// URL format
            echo "${pkg_name} @ file://\${PWD}/${path}" >> "$TMP_FILE"
        elif [[ $line != --extra-index* ]] && [[ -n "$line" ]] && [[ ! $line =~ ^# ]]; then
            # Copy non-git requirements as-is (skip comments and empty lines)
            echo "$line" >> "$TMP_FILE"
        fi
    done < "$input_file"

    # Add a newline at the end
    echo "" >> "$TMP_FILE"

    # Replace the original file
    mv "$TMP_FILE" "$output_file"

    echo "âœ… Generated $output_file"
}

# Main execution
if [ $# -eq 0 ]; then
    # No arguments, generate from default files
    if [ -f "requirements.build.txt" ]; then
        generate_source_requirements "requirements.build.txt" "requirements.source.txt"
    else
        echo "Error: requirements.build.txt not found"
        exit 1
    fi
else
    # Custom input and output files
    if [ $# -ne 2 ]; then
        echo "Usage: $0 [input_file output_file]"
        echo "   or: $0  (uses requirements.build.txt -> requirements.source.txt)"
        exit 1
    fi

    generate_source_requirements "$1" "$2"
fi

echo "Done! Source requirements file(s) generated."
