#!/usr/bin/env bash

# JTL Shipping Platform - Unified Version Update Script
# This script updates version across all JTL modules, docker images, and generates requirements files
# Usage: ./bin/update-jtl-version <old-version> <new-version>

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check arguments
if [ -z "$1" ] || [ -z "$2" ]; then
    log_error "Both old and new version arguments are required"
    echo "Usage: $0 <old-version> <new-version>"
    echo "Example: $0 2025.5rc26 2025.5rc27"
    exit 1
fi

OLD_VERSION=$1
NEW_VERSION=$2

log_info "Updating version from ${OLD_VERSION} to ${NEW_VERSION}..."

# Detect OS for sed compatibility
if [[ "$OSTYPE" == "darwin"* ]]; then
    SED_CMD="sed -i ''"
else
    SED_CMD="sed -i"
fi

# Function to update file with sed
update_file() {
    local file=$1
    local old=$2
    local new=$3

    if [ -f "$file" ]; then
        log_info "→ Updating $file"
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' -e "s/${old}/${new}/g" "$file"
        else
            sed -i "s/${old}/${new}/g" "$file"
        fi
    else
        log_warning "File not found: $file"
    fi
}

# Function to update pyproject.toml version
update_pyproject_version() {
    local pyproject_file="$1"
    local new_version="$2"

    if [ -f "$pyproject_file" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$new_version\"/" "$pyproject_file"
        else
            sed -i "s/^version = \".*\"/version = \"$new_version\"/" "$pyproject_file"
        fi
        log_info "→ Updated version in $pyproject_file"
    else
        log_warning "pyproject.toml not found: $pyproject_file"
    fi
}

echo ""
log_info "=== Step 1: Updating VERSION file ==="
echo "${NEW_VERSION}" > VERSION
log_success "Updated VERSION file"

echo ""
log_info "=== Step 2: Updating JTL module versions ==="
# Update JTL modules
declare -a jtl_modules=(
    "modules/jtl"
    "modules/shipping"
)

for module in "${jtl_modules[@]}"; do
    if [ -f "$module/pyproject.toml" ]; then
        update_pyproject_version "$module/pyproject.toml" "$NEW_VERSION"
    fi
done

echo ""
log_info "=== Step 3: Updating Docker Compose files ==="
update_file "docker-compose.yml" "$OLD_VERSION" "$NEW_VERSION"
update_file "docker/docker-compose.yml" "$OLD_VERSION" "$NEW_VERSION"

echo ""
log_info "=== Step 4: Updating environment files ==="
update_file ".env" "$OLD_VERSION" "$NEW_VERSION"
update_file ".env.sample" "$OLD_VERSION" "$NEW_VERSION"

echo ""
log_info "=== Step 5: Updating deployment scripts ==="
update_file "bin/deploy-jtl" "$OLD_VERSION" "$NEW_VERSION"
update_file "bin/upgrade-jtl" "$OLD_VERSION" "$NEW_VERSION"
update_file "bin/install-jtl" "$OLD_VERSION" "$NEW_VERSION"

echo ""
log_info "=== Step 6: Updating GitHub workflows ==="
if [ -f ".github/workflows/jtl-build.yml" ]; then
    update_file ".github/workflows/jtl-build.yml" "$OLD_VERSION" "$NEW_VERSION"
fi

echo ""
log_info "=== Step 7: Updating OpenAPI schemas ==="
update_file "schemas/openapi.yml" "$OLD_VERSION" "$NEW_VERSION"

echo ""
log_info "=== Step 8: Generating requirements files ==="

# Function to generate requirements.txt from requirements.build.txt
generate_requirements_txt() {
    log_info "→ Generating requirements.txt..."

    if [ ! -f "requirements.build.txt" ]; then
        log_error "requirements.build.txt not found"
        return 1
    fi

    # Activate virtual environment
    source bin/activate 2>/dev/null || {
        log_warning "Could not activate virtual environment"
    }

    # Install from build requirements
    log_info "Installing packages from requirements.build.txt..."
    pip install -q -r requirements.build.txt

    # Generate frozen requirements
    log_info "Freezing requirements..."
    {
        echo "--extra-index-url https://karrio.gateway.scarf.sh/simple/"
        pip freeze
    } > requirements.txt

    # Replace git+ssh:// with git+https://
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' -e 's/git+ssh:\/\/git@/git+https:\/\//g' requirements.txt
        # Fix community plugin paths
        sed -i '' -e 's/subdirectory=\.\.\/\.\.\/community\/plugins\//subdirectory=community\/plugins\//g' requirements.txt
    else
        sed -i 's/git+ssh:\/\/git@/git+https:\/\//g' requirements.txt
        sed -i 's/subdirectory=\.\.\/\.\.\/community\/plugins\//subdirectory=community\/plugins\//g' requirements.txt
    fi

    log_success "Generated requirements.txt"
}

# Function to generate requirements.source.txt from requirements.build.txt
generate_requirements_source() {
    log_info "→ Generating requirements.source.txt..."

    if [ ! -f "requirements.build.txt" ]; then
        log_error "requirements.build.txt not found"
        return 1
    fi

    # Create temporary file
    TMP_FILE=$(mktemp)

    # Add header
    echo "--extra-index-url https://karrio.gateway.scarf.sh/simple/?sourceBuild" > "$TMP_FILE"

    # Process each line in requirements.build.txt
    while IFS= read -r line; do
        if [[ $line == -e\ ./* ]]; then
            # Extract path from -e ./path
            path="${line#-e }"
            path="${path#./}"

            # Determine package name from path
            if [[ $path =~ modules/jtl ]]; then
                pkg_name="karrio_server_jtl"
            elif [[ $path =~ modules/shipping ]]; then
                pkg_name="karrio_server_jtl_shipping"
            elif [[ $path =~ karrio/modules/sdk ]]; then
                pkg_name="karrio"
            elif [[ $path =~ karrio/modules/connectors/([^/]+) ]]; then
                connector="${BASH_REMATCH[1]}"
                pkg_name="karrio_${connector}"
            elif [[ $path =~ karrio-insiders/modules/([^/]+) ]]; then
                module="${BASH_REMATCH[1]}"
                pkg_name="karrio_server_${module}"
            elif [[ $path =~ karrio/modules/core ]]; then
                pkg_name="karrio_server_core"
            elif [[ $path =~ karrio/apps/api ]]; then
                pkg_name="karrio_server"
            elif [[ $path =~ karrio/modules/([^/]+) ]]; then
                module="${BASH_REMATCH[1]}"
                pkg_name="karrio_server_${module}"
            else
                # Fallback: use directory name
                pkg_name=$(basename "$path")
            fi

            # Write the file:// URL format
            echo "${pkg_name} @ file://\${PWD}/${path}" >> "$TMP_FILE"
        elif [[ $line != --extra-index* ]] && [[ -n "$line" ]] && [[ ! $line =~ ^# ]]; then
            # Copy non-editable requirements as-is (skip comments and empty lines)
            echo "$line" >> "$TMP_FILE"
        fi
    done < "requirements.build.txt"

    # Add newline at the end
    echo "" >> "$TMP_FILE"

    # Replace the original file
    mv "$TMP_FILE" "requirements.source.txt"

    log_success "Generated requirements.source.txt"
}

# Generate both requirements files
generate_requirements_txt
generate_requirements_source

echo ""
log_success "=========================================="
log_success "✅ Version update complete!"
log_success "=========================================="
echo ""
log_info "Updated from ${OLD_VERSION} to ${NEW_VERSION}"
echo ""
log_info "Files updated:"
log_info "  • VERSION"
log_info "  • JTL module pyproject.toml files"
log_info "  • Docker Compose files"
log_info "  • Environment files (.env, .env.sample)"
log_info "  • Deployment scripts"
log_info "  • GitHub workflows"
log_info "  • OpenAPI schemas"
log_info "  • requirements.txt (frozen)"
log_info "  • requirements.source.txt (source)"
echo ""
log_warning "Next steps:"
log_warning "  1. Review changes: git diff"
log_warning "  2. Test the build: docker compose build"
log_warning "  3. Commit changes: git add . && git commit -m 'chore: bump version to ${NEW_VERSION}'"
log_warning "  4. Tag release: git tag ${NEW_VERSION}"
echo ""
