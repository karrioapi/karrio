#!/usr/bin/env bash
#
# create-github-release - Idempotently create a GitHub release from CHANGELOG.md
#
# Usage:
#   ./bin/create-github-release [version]
#
# If no version is provided, it reads from apps/api/karrio/server/VERSION
#
# This script:
#   1. Extracts release notes from CHANGELOG.md for the given version
#   2. Determines the release title format (major vs patch)
#   3. Creates the release idempotently (skips if it already exists)
#
# Environment variables:
#   DRY_RUN=1           - Print what would be done without creating the release
#   MARK_LATEST=1       - Mark the release as latest (default: auto-detect)
#   REPO=owner/repo     - Override the repository (default: current repo)
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get version from argument or VERSION file
get_version() {
    if [[ -n "${1:-}" ]]; then
        echo "$1"
    else
        cat "$ROOT_DIR/apps/api/karrio/server/VERSION"
    fi
}

# Determine if version is a major release (X.Y) or patch release (X.Y.Z)
is_major_release() {
    local version="$1"
    # Count the number of dots - if only one dot, it's a major release
    local dot_count
    dot_count=$(echo "$version" | tr -cd '.' | wc -c | tr -d ' ')
    [[ "$dot_count" -eq 1 ]]
}

# Generate release title based on version type
get_release_title() {
    local version="$1"
    if is_major_release "$version"; then
        echo "Karrio OSS $version"
    else
        echo "Karrio patch $version"
    fi
}

# Extract release notes from CHANGELOG.md for a specific version
extract_release_notes() {
    local version="$1"
    local changelog="$ROOT_DIR/CHANGELOG.md"

    if [[ ! -f "$changelog" ]]; then
        log_error "CHANGELOG.md not found at $changelog"
        return 1
    fi

    # Use awk to extract the section for this version
    # The section starts with "# Karrio $version" and ends at the next "---" or "# Karrio"
    # Also handles trimming leading/trailing blank lines
    awk -v version="$version" '
        BEGIN { found=0; printing=0 }
        /^# Karrio / {
            if (found) { exit }
            if ($0 ~ "# Karrio " version "$") {
                found=1
                printing=1
                next
            }
        }
        /^---$/ {
            if (printing) { exit }
        }
        printing { print }
    ' "$changelog" | awk '
        # Remove leading and trailing blank lines, collapse multiple blank lines
        NF { blank=0; for(i=1;i<=n;i++) print saved[i]; n=0; print; next }
        { saved[++n]=$0 }
    '
}

# Check if release already exists
release_exists() {
    local tag="$1"
    local repo="${REPO:-}"

    local repo_flag=""
    if [[ -n "$repo" ]]; then
        repo_flag="--repo $repo"
    fi

    # shellcheck disable=SC2086
    gh release view "$tag" $repo_flag >/dev/null 2>&1
}

# Print release notes body
print_release_notes() {
    local notes="$1"
    echo ""
    echo "Release notes:"
    echo "----------------------------------------"
    echo "$notes"
    echo "----------------------------------------"
    echo ""
}

# Create the GitHub release
create_release() {
    local version="$1"
    local tag="v$version"
    local title
    local notes
    local repo="${REPO:-}"
    local dry_run="${DRY_RUN:-}"
    local mark_latest="${MARK_LATEST:-}"

    title=$(get_release_title "$version")
    notes=$(extract_release_notes "$version")

    if [[ -z "$notes" ]]; then
        log_error "Could not extract release notes for version $version from CHANGELOG.md"
        log_error "Make sure CHANGELOG.md contains a section starting with '# Karrio $version'"
        return 1
    fi

    log_info "Tag: $tag"
    log_info "Title: $title"
    print_release_notes "$notes"

    # Check if release already exists
    if release_exists "$tag"; then
        log_info "Release $tag already exists, skipping creation"
        return 0
    fi

    # Build the gh release create command
    local cmd="gh release create \"$tag\" --title \"$title\""

    if [[ -n "$repo" ]]; then
        cmd="$cmd --repo \"$repo\""
    fi

    # Auto-detect latest flag based on version comparison
    # By default, mark as latest only if explicitly requested
    if [[ "$mark_latest" == "1" ]]; then
        cmd="$cmd --latest"
    fi

    if [[ "$dry_run" == "1" ]]; then
        log_info "[DRY RUN] Would create release with command:"
        echo "  $cmd --notes-file <temp_file>"
        return 0
    fi

    log_info "Creating GitHub release $tag..."

    # Create a temporary file for the release notes
    local notes_file
    notes_file=$(mktemp)
    echo "$notes" > "$notes_file"

    # Create the release
    local repo_flag=""
    if [[ -n "$repo" ]]; then
        repo_flag="--repo $repo"
    fi

    local latest_flag=""
    if [[ "$mark_latest" == "1" ]]; then
        latest_flag="--latest"
    fi

    # shellcheck disable=SC2086
    if gh release create "$tag" \
        --title "$title" \
        --notes-file "$notes_file" \
        $repo_flag \
        $latest_flag; then
        log_info "Successfully created release $tag"
        rm -f "$notes_file"
        return 0
    else
        log_error "Failed to create release $tag"
        rm -f "$notes_file"
        return 1
    fi
}

# Main
main() {
    local version
    version=$(get_version "${1:-}")

    if [[ -z "$version" ]]; then
        log_error "Could not determine version"
        exit 1
    fi

    log_info "Processing release for version: $version"

    # Verify gh CLI is available
    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is not installed or not in PATH"
        exit 1
    fi

    # Verify gh is authenticated
    if ! gh auth status &> /dev/null; then
        log_error "GitHub CLI is not authenticated. Run 'gh auth login' first."
        exit 1
    fi

    create_release "$version"
}

main "$@"
